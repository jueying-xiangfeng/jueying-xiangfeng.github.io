<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白夜追凶</title>
  
  <subtitle>Talk is cheap. Show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-15T14:24:18.415Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Key</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存管理原理探究-续</title>
    <link href="http://yoursite.com/2020/08/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-%E7%BB%AD/"/>
    <id>http://yoursite.com/2020/08/14/内存管理原理探究-续/</id>
    <published>2020-08-14T14:07:29.000Z</published>
    <updated>2020-08-15T14:24:18.415Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做皮肤适配时遇到了很多的坑，进而产生了很多的疑问。下面是想到了一些问题和最终得到的验证，内功太菜。之前一直在怀疑是他们都太飘了还是我拿不动刀了。现在看看内功太菜，确实是我打不动刀了。。。</p><p>之前看 Autorelease 时知道了底层是由 AutoreleasePoolPage 实现的，并且是由 RunLoop 来驱动的。那么的疑问就是我们在子线程中添加 Autorelease 时，这时没有 RunLoop，那么 autorelease 是怎样工作的呢？</p><a id="more"></a><p>最近遇到了一个疑问，之前看 Autorelease 时知道了底层是由 AutoreleasePoolPage 实现的，并且是由 RunLoop 来驱动的。那么的疑问就是我们在子线程中添加 Autorelease 时，这时没有 RunLoop，那么 autorelease 是怎样工作的呢？</p><p>在整理上面的疑问时还遇到了几个别的内存管理的问题：</p><ul><li>ARC 到底是怎样管理内存的，平时只知道在合适的位置帮我们release，那么这个时机是在哪里？</li><li>weak、strong、autoreleasing 在 ARC 下的具体实现是怎样的？</li></ul><h3 id="ARC-内存管理原理"><a href="#ARC-内存管理原理" class="headerlink" title="ARC 内存管理原理"></a>ARC 内存管理原理</h3><p><code>ARC</code>即OC的自动引用计数技术，通过在编译阶段自动添加引用计数，达到自动管理引用计数的目的。使用ARC可以做到接近垃圾回收的代码编写体验，同时拥有引用计数的性能与效率。那么ARC具体是怎做到自动添加添加和释放引用计数的呢。</p><h4 id="自动-release"><a href="#自动-release" class="headerlink" title="自动 release"></a>自动 release</h4><p>来一段测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (void)test &#123;    </span><br><span class="line">    id a;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>使用 <code>clang -S -fobjc-arc -emit-llvm Person.m -o person_arc.ll</code> 命令来查看下生成的中间代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define internal void @<span class="string">"\01-[Person test]"</span>(%0*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca %0*,<span class="built_in"> align </span>8</span><br><span class="line">  %4 = alloca i8*,<span class="built_in"> align </span>8</span><br><span class="line">  %5 = alloca i8*,<span class="built_in"> align </span>8</span><br><span class="line">  store %0* %0, %0** %3,<span class="built_in"> align </span>8</span><br><span class="line">  store i8* %1, i8** %4,<span class="built_in"> align </span>8</span><br><span class="line">  store i8* <span class="literal">null</span>, i8** %5,<span class="built_in"> align </span>8</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %5, i8* <span class="literal">null</span>) #2</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> alloca 是在当前执行的函数堆栈帧中分配内存。store 则表示将值存到指定地址。</p><p>关于 llvm 语法问题可以查看官方文档：<code>https://llvm.org/docs/LangRef.html</code></p><p>这里有一个很重要的函数：objc.storeStrong(i8*<em> %5, i8</em> null)，来看下 objc 的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    if (obj == prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其操作就是将 obj 做一次 retain 操作，然后再将 location 指向 obj，最后将 location 做一次 release。</p><p>OK，objc.storeStrong(i8*<em> %5, i8</em> null) 函数其实就是将 location 置空，并且是在函数作用域结束时做的。</p><h4 id="自动-retain"><a href="#自动-retain" class="headerlink" title="自动 retain"></a>自动 retain</h4><p>再来加点测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    id a;</span><br><span class="line">    __strong id b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal void @&quot;\01-[Person test]&quot;(%0*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca %0*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca i8*, align 8</span><br><span class="line">  %6 = alloca i8*, align 8</span><br><span class="line">  store %0* %0, %0** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  store i8* null, i8** %5, align 8</span><br><span class="line">  %7 = load i8*, i8** %5, align 8</span><br><span class="line">  %8 = call i8* @llvm.objc.retain(i8* %7) #1</span><br><span class="line">  store i8* %8, i8** %6, align 8</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %6, i8* null) #1</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %5, i8* null) #1</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给 b 指针赋值时调用了一次 retain。并在函数最后面调用了两次 objc.storeStrong。这里可以看到使用强指针会自动插入 retain 操作，而在作用域结束时会插入 release 操作。</p><p>再来试下其他修饰符：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/// __autoreleasing</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void @<span class="string">"\01-[Person test]"</span>(<span class="symbol">%0</span>*, <span class="keyword">i8</span>*) <span class="symbol">#0</span> &#123;</span><br><span class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="symbol">%0</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%4</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%5</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%6</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="symbol">%0</span>* <span class="symbol">%0</span>, <span class="symbol">%0</span>** <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%1</span>, <span class="keyword">i8</span>** <span class="symbol">%4</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="keyword">null</span>, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i8</span>*, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%8</span> = <span class="keyword">call</span> <span class="keyword">i8</span>* <span class="title">@llvm.objc.retainAutorelease</span>(<span class="keyword">i8</span>* <span class="symbol">%7</span>) <span class="symbol">#1</span>// 注意这里</span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%8</span>, <span class="keyword">i8</span>** <span class="symbol">%6</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.storeStrong</span>(<span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">i8</span>* <span class="keyword">null</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// __weak</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void @<span class="string">"\01-[Person test]"</span>(<span class="symbol">%0</span>*, <span class="keyword">i8</span>*) <span class="symbol">#0</span> &#123;</span><br><span class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="symbol">%0</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%4</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%5</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%6</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="symbol">%0</span>* <span class="symbol">%0</span>, <span class="symbol">%0</span>** <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%1</span>, <span class="keyword">i8</span>** <span class="symbol">%4</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="keyword">null</span>, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i8</span>*, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%8</span> = <span class="keyword">call</span> <span class="keyword">i8</span>* <span class="title">@llvm.objc.initWeak</span>(<span class="keyword">i8</span>** <span class="symbol">%6</span>, <span class="keyword">i8</span>* <span class="symbol">%7</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.destroyWeak</span>(<span class="keyword">i8</span>** <span class="symbol">%6</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.storeStrong</span>(<span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">i8</span>* <span class="keyword">null</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// __unsafe_unretained</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void @<span class="string">"\01-[Person test]"</span>(<span class="symbol">%0</span>*, <span class="keyword">i8</span>*) <span class="symbol">#0</span> &#123;</span><br><span class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="symbol">%0</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%4</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%5</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%6</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="symbol">%0</span>* <span class="symbol">%0</span>, <span class="symbol">%0</span>** <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%1</span>, <span class="keyword">i8</span>** <span class="symbol">%4</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="keyword">null</span>, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i8</span>*, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span>// 注意这里是直接赋值</span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%7</span>, <span class="keyword">i8</span>** <span class="symbol">%6</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.storeStrong</span>(<span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">i8</span>* <span class="keyword">null</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__autoreleasing 其实其实就是调用 objc_retainAutorelease 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 对 obj 做一次 retain 操作，然后加入自动释放池</span><br><span class="line">id objc_retainAutorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    return objc_autorelease(objc_retain(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__weak 是调用 objc_initWeak 对 weak 对象赋值，在作用域结束时调用 objc_destryWeak 进行释放。</p><p>__unsafe_unretained 则只是进行指针的赋值，并不考虑引用计数相关的问题。</p><p>综上我们可以看到，ARC 会自动的在赋值语句之前插入一些引用计数相关的函数，这就是 ARC 实现的主要原理。</p><h4 id="对-retain、release-的一些优化"><a href="#对-retain、release-的一些优化" class="headerlink" title="对 retain、release 的一些优化"></a>对 retain、release 的一些优化</h4><p><code>ARC</code>对于以<code>new</code>、<code>copy</code>、<code>mutableCopy</code>和<code>alloc</code>以及 以这四个单词开头的所有函数，默认认为函数返回值直接持有对象。这是ARC中必须要遵守的命名规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)newPerson &#123;</span><br><span class="line">    Person * p = [Person new];    </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)createPerson &#123;</span><br><span class="line">    Person * p = [Person new];</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i8* @&quot;\01+[Person newPerson]&quot;(i8*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca i8*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca %0*, align 8</span><br><span class="line">  store i8* %0, i8** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  %6 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %7 = bitcast %struct._class_t* %6 to i8*</span><br><span class="line">  %8 = call i8* @objc_opt_new(i8* %7)</span><br><span class="line">  %9 = bitcast i8* %8 to %0*</span><br><span class="line">  store %0* %9, %0** %5, align 8</span><br><span class="line">  %10 = load %0*, %0** %5, align 8</span><br><span class="line">  %11 = bitcast %0* %10 to i8*</span><br><span class="line">  %12 = call i8* @llvm.objc.retain(i8* %11) #1</span><br><span class="line">  %13 = bitcast i8* %12 to %0*</span><br><span class="line">  %14 = bitcast %0* %13 to i8*</span><br><span class="line">  %15 = bitcast %0** %5 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %15, i8* null) #1</span><br><span class="line">  ret i8* %14</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i8* @&quot;\01+[Person createPerson]&quot;(i8*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca i8*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca %0*, align 8</span><br><span class="line">  store i8* %0, i8** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  %6 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %7 = bitcast %struct._class_t* %6 to i8*</span><br><span class="line">  %8 = call i8* @objc_opt_new(i8* %7)</span><br><span class="line">  %9 = bitcast i8* %8 to %0*</span><br><span class="line">  store %0* %9, %0** %5, align 8</span><br><span class="line">  %10 = load %0*, %0** %5, align 8</span><br><span class="line">  %11 = bitcast %0* %10 to i8*</span><br><span class="line">  %12 = call i8* @llvm.objc.retain(i8* %11) #1</span><br><span class="line">  %13 = bitcast i8* %12 to %0*</span><br><span class="line">  %14 = bitcast %0* %13 to i8*</span><br><span class="line">  %15 = bitcast %0** %5 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %15, i8* null) #1</span><br><span class="line">  %16 = tail call i8* @llvm.objc.autoreleaseReturnValue(i8* %14) #1</span><br><span class="line">  ret i8* %16</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数 <code>newPerson</code> 中，函数的返回值不带 autorelease，是直接持有对象。而函数 <code>createPerson</code> 中返回对象的最后一步会调用 <code>autoreleaseReturnValue</code>。</p><p>再来看下使用赋值的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    Person * a = [Person createPerson];</span><br><span class="line">    Person * b = [Person newPerson];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal void @&quot;\01-[Person test]&quot;(%0*, i8*) #1 &#123;</span><br><span class="line">  %3 = alloca %0*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca %0*, align 8</span><br><span class="line">  %6 = alloca %0*, align 8</span><br><span class="line">  store %0* %0, %0** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  %7 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %8 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !9</span><br><span class="line">  %9 = bitcast %struct._class_t* %7 to i8*</span><br><span class="line">  %10 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %9, i8* %8)</span><br><span class="line">  %11 = notail call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %10) #2</span><br><span class="line">  %12 = bitcast i8* %11 to %0*</span><br><span class="line">  store %0* %12, %0** %5, align 8</span><br><span class="line">  %13 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %14 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !9</span><br><span class="line">  %15 = bitcast %struct._class_t* %13 to i8*</span><br><span class="line">  %16 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %15, i8* %14)</span><br><span class="line">  %17 = bitcast i8* %16 to %0*</span><br><span class="line">  store %0* %17, %0** %6, align 8</span><br><span class="line">  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*))</span><br><span class="line">  %18 = bitcast %0** %6 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %18, i8* null) #2</span><br><span class="line">  %19 = bitcast %0** %5 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %19, i8* null) #2</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，赋值前不会对 <code>[Person newPerson]</code> 进行操作，因为外面是一个 strong 指针，而返回的对象已经持有引用计数。</p><p>而对 <code>[Person createPerson]</code> 的返回值需要 retain，因为函数对返回的对象进行了一次 autoreleaseReturnValue 操作，和前面的 retain 操作对应，正好达到引用计数器的加减平衡，所以外面的 strong 指针需要对返回值进行持有。</p><p>这里还有一个ARC 的优化，如果返回值使用了 <code>objc_autoreleaseReturnValue</code>函数，则在赋值时对应使用 <code>objc_retainAutoreleasedReturnValue</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span><br><span class="line">id </span><br><span class="line">objc_autoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_autorelease(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id</span><br><span class="line">objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (acceptOptimizedReturn() == ReturnAtPlus1) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_retain(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC 对内存调用函数进行了优化，即 ARC 相关的函数不通过 OC 的消息发送机制，而是直接调用底层的 C 函数，而且 ARC 是在编译阶段有编译器自动添加引用计数函数调用，而不是运行时判断。综上，ARC 性能要优于 MRC。</p><h5 id="PerformSelector-问题"><a href="#PerformSelector-问题" class="headerlink" title="PerformSelector 问题"></a>PerformSelector 问题</h5><p>当我们调用 performSelector 时来看一个比较经典的警告：</p><p><code>PerformSelector may cause a leak because its selector is unknown</code></p><p>当我们了解完 ARC 的原理后，这个就不难解释了，对于 <code>performSelector</code> 返回值是 id，对于以下调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)newP &#123;    </span><br><span class="line">    return [Person new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    SEL sel = NSSelectorFromString(@&quot;newP&quot;);</span><br><span class="line">    Person * person = [self performSelector:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 person 为强指针，会对 performSelector 的返回值进行一次 retain 操作，然后在 person 离开作用域时进行一次 release 操作。</p><p>而如果 sel 是以 new、copy、mutableCopy、alloc 开头的，则返回的对象时带有一个引用计数的，所以 person 只进行了一次 retain 和一次 release，此时引用计数还是为 1，这就会发生内存泄漏问题。</p><h5 id="NSInvocation-返回值问题"><a href="#NSInvocation-返回值问题" class="headerlink" title="NSInvocation 返回值问题"></a>NSInvocation 返回值问题</h5><p>当我们使用 NSInvocation 的 <code>getReturnValue</code>获取返回值时，看苹果的声明，这个函数由于不知道返回值类型，只进行指针赋值不进行对象的内存管理操作，所以结合上面讲到的 ARC 内存管理问题我们就要考虑如何避免内存问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)newP &#123;</span><br><span class="line">    return [Person new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)createPerson &#123;</span><br><span class="line">    return [Person new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    Person * targetPerson = [Person new];</span><br><span class="line">    SEL sel = @selector(newP);</span><br><span class="line">    NSMethodSignature * signature = [self methodSignatureForSelector:sel];</span><br><span class="line">    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">    invocation.selector = sel;</span><br><span class="line">    [invocation invokeWithTarget:targetPerson];</span><br><span class="line">    </span><br><span class="line">    __strong Person * returnValue;</span><br><span class="line">    [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先当被调用函数是以<code>new</code>，<code>copy</code>,<code>mutableCopy</code>和<code>alloc</code>开头的特殊函数时，函数返回的的对象持有引用计数，所以我们设置<code>returnValue</code>的类型是<code>__strong</code>，这样在这个<code>returnValue</code>的作用域结束时，会进行<code>release</code>，内存处理正常。</p><p>当被调用的函数是 createPerson 时，由于函数内部最后执行了 autorelease，如果此时我们再使用 strong 指针的话，就会导致内存泄漏问题。所以这里我们要使用 autoreleasing 来修饰 returnValue。</p><h3 id="子线程的-Autorelease-是怎样维护的"><a href="#子线程的-Autorelease-是怎样维护的" class="headerlink" title="子线程的 Autorelease 是怎样维护的"></a>子线程的 Autorelease 是怎样维护的</h3><p>前面一章中我们知道了主线程的 autorelease 对象是由 AutoreleasePoolPage 对象管理的，并且 AutoreleasePoolPage 的push 和 pop 操作是由主线程中在 RunLoop 中注册的两个 observer 维护的。那么在子线程中 autorelease 对象是如何维护的呢？因为我们知道子线程一般是没有 RunLoop的，那么在子线程中是如何维护的呢？来源码中找下答案：</p><p>子线程 AutoreleasePoolPage 创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    // 加入 autorealease 对象到 page 的入口函数</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line">    ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">    // 调用 autoreleaseFast</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果当前 page 为空</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary = false;</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        pushExtraBoundary = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        return setEmptyPoolPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line">    // Install the first page.</span><br><span class="line">    // 关键来了：如果 page 为空则创建 page 对象</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    // Push a boundary on behalf of the previously-placeholder&apos;d pool.</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Push the requested object or pool.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程 AutoreleasePoolPage 管理对象的释放，在线程退出时会调用 <code>pthread_exit</code>方法，最终回来到 <code>tls_dealloc</code> 函数。由于 objc 的源码不能调试到 pthread_exit 方法，所以这里我们只能看关于 AutoreleasePoolPage 的相关源码，当 if (!page-&gt;empty()) 满足时执行：objc_autoreleasePoolPop(page-&gt;begin()); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void tls_dealloc(void *p) </span><br><span class="line">&#123;</span><br><span class="line">    if (p == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reinstate TLS value while we work</span><br><span class="line">    setHotPage((AutoreleasePoolPage *)p);</span><br><span class="line"></span><br><span class="line">    if (AutoreleasePoolPage *page = coldPage()) &#123;</span><br><span class="line">        if (!page-&gt;empty()) objc_autoreleasePoolPop(page-&gt;begin());  // pop all of the pools</span><br><span class="line">        if (slowpath(DebugMissingPools || DebugPoolAllocation)) &#123;</span><br><span class="line">            // pop() killed the pages already</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            page-&gt;kill();  // free all of the pages</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // clear TLS value so TLS destruction doesn&apos;t loop</span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，子线程的 autorelease 对象也是由 AutoreleasePoolPage 来管理的，再加入page时如果 page 为空则新建一个。</p><p>在线程退出时则会调用 <code>tls_dealloc</code> 方法，然后进行 pop 操作 来释放所有相关的 autorelease 对象。</p><p>参考：</p><ul><li><a href="[https://suhou.github.io/2018/01/21/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E7%9C%8B%E6%BA%90%E7%A0%81----%E5%AD%90%E7%BA%BF%E7%A8%8BAutoRelease%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E9%87%8A%E6%94%BE/](https://suhou.github.io/2018/01/21/带着问题看源码----子线程AutoRelease对象何时释放/">带着问题看源码—-子线程AutoRelease对象何时释放</a>)</li><li><a href="http://luoxianming.cn/2017/05/06/arc/" target="_blank" rel="noopener">ARC原理探究</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做皮肤适配时遇到了很多的坑，进而产生了很多的疑问。下面是想到了一些问题和最终得到的验证，内功太菜。之前一直在怀疑是他们都太飘了还是我拿不动刀了。现在看看内功太菜，确实是我打不动刀了。。。&lt;/p&gt;
&lt;p&gt;之前看 Autorelease 时知道了底层是由 AutoreleasePoolPage 实现的，并且是由 RunLoop 来驱动的。那么的疑问就是我们在子线程中添加 Autorelease 时，这时没有 RunLoop，那么 autorelease 是怎样工作的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="内存管理、RunLoop、Autorelease" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81RunLoop%E3%80%81Autorelease/"/>
    
  </entry>
  
  <entry>
    <title>内存管理原理探究</title>
    <link href="http://yoursite.com/2020/08/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2020/08/08/内存管理原理探究/</id>
    <published>2020-08-08T08:42:16.000Z</published>
    <updated>2020-08-15T14:24:20.984Z</updated>
    
    <content type="html"><![CDATA[<p>最近时间比较散，还有就是公司比较动荡😌，当初怀着一颗做事的心来到这里，没想到最后落得这样的结局。不说了，还是保持本心比较好，尽管想做好飞读，但是我们小职员也改变不了什么。做好自己的事情就好，按着学习计划继续。。。</p><a id="more"></a><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>iOS 的内存管理必然少不了定时器，以前没有深究过具体的原理，只知道 timer 会对 target 产生强引用，现在来分析下为什么会产生强引用以及怎样解决。</p><p>先来看一段测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)testTimer &#123;   </span><br><span class="line">    self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerAction &#123;</span><br><span class="line">    NSLog(@&quot;-- %s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，当我们销毁控制器时没有调用 dealloc 方法， 说明此时有循环引用。之前只是知道 timer 会对 self 产生强引用，那么具体怎么产生的呢，这里可以看一下 <a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNU</a> 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (id) initWithFireDate: (NSDate*)fd</span><br><span class="line">       interval: (NSTimeInterval)ti</span><br><span class="line"> target: (id)object</span><br><span class="line">       selector: (SEL)selector</span><br><span class="line">       userInfo: (id)info</span><br><span class="line">repeats: (BOOL)f</span><br><span class="line">&#123;</span><br><span class="line">  if (ti &lt;= 0.0)</span><br><span class="line">    &#123;</span><br><span class="line">      ti = 0.0001;</span><br><span class="line">    &#125;</span><br><span class="line">  if (fd == nil)</span><br><span class="line">    &#123;</span><br><span class="line">      _date = [[NSDate_class allocWithZone: NSDefaultMallocZone()]</span><br><span class="line">        initWithTimeIntervalSinceNow: ti];</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      _date = [fd copyWithZone: NSDefaultMallocZone()];</span><br><span class="line">    &#125;</span><br><span class="line">  _target = RETAIN(object);</span><br><span class="line">  _selector = selector;</span><br><span class="line">  _info = RETAIN(info);</span><br><span class="line">  if (f == YES)</span><br><span class="line">    &#123;</span><br><span class="line">      _repeats = YES;</span><br><span class="line">      _interval = ti;</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      _repeats = NO;</span><br><span class="line">      _interval = 0.0;</span><br><span class="line">    &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以看出 timer 会对 target 做一次 retain 操作，这也就解释了为什么使用 __weak 解决不了循环引用的问题，因为不管 target 传入 self 还是 weakSelf，timer 都会对 self 做一次 retain 操作。</p><p><br></p><p>要想解决循环引用，那么直接的办法就是添加一个中间代理，使用到了 NSProxy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface TargetProxy : NSProxy</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TargetProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target &#123;</span><br><span class="line">    TargetProxy * proxy = [TargetProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这样就能解决循环引用的问题。这里还有一个注意点：当程序退到后台时 timer 就会停止，因为 timer 是基于 RunLoop 的，如之前 RunLoop 章节所讲， timer 也是不精准的。可以通过添加 observer 来验证我们的猜想，当程序退到后台时，最终会走到 kCFRunLoopBeforeWaiting 状态，从而 timer 停止工作，当程序从后台回到前台时，RunLoop 又从 kCFRunLoopAfterWaiting 状态开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self testTimer];</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        NSLog(@&quot;%lu&quot;, activity);</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CADisplayLink</code> 原理和 <code>NSTimer</code> 相同。</p><p>如果想要更精准的设置 timer，我们可以使用 GCD 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@interface CTTimer : NSObject</span><br><span class="line">+ (id)executeTask:(dispatch_block_t)task</span><br><span class="line">            start:(NSTimeInterval)star</span><br><span class="line">         interval:(NSTimeInterval)interval</span><br><span class="line">         repeates:(BOOL)repeates</span><br><span class="line">            async:(BOOL)async;</span><br><span class="line"></span><br><span class="line">+ (id)executeWithTarget:(id)target</span><br><span class="line">                 action:(SEL)action</span><br><span class="line">                  start:(NSTimeInterval)star</span><br><span class="line">               interval:(NSTimeInterval)interval</span><br><span class="line">               repeates:(BOOL)repeates</span><br><span class="line">                  async:(BOOL)async;</span><br><span class="line"></span><br><span class="line">+ (void)cancelTask:(id)key;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CTTimer</span><br><span class="line">static NSMutableDictionary * timers_;</span><br><span class="line">dispatch_semaphore_t semphore_;</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    timers_ = [NSMutableDictionary dictionary];</span><br><span class="line">    semphore_ = dispatch_semaphore_create(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)executeTask:(dispatch_block_t)task</span><br><span class="line">            start:(NSTimeInterval)star</span><br><span class="line">         interval:(NSTimeInterval)interval</span><br><span class="line">         repeates:(BOOL)repeates</span><br><span class="line">            async:(BOOL)async &#123;</span><br><span class="line">    </span><br><span class="line">    if (!task || star &lt; 0 || (interval &lt; 0 &amp;&amp; repeates)) &#123; return nil; &#125;</span><br><span class="line">    </span><br><span class="line">    static dispatch_queue_t _queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _queue = dispatch_queue_create(&quot;queue timer&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t timerQueue = async ? _queue : dispatch_get_main_queue();</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, timerQueue);</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, star), interval * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSString * key = [NSString stringWithFormat:@&quot;key_%lu&quot;, (unsigned long)timers_.count];</span><br><span class="line">    timers_[key] = timer;</span><br><span class="line">    dispatch_semaphore_signal(semphore_);</span><br><span class="line">    </span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        if (task) &#123; task(); &#125;</span><br><span class="line">        if (!repeates) &#123;</span><br><span class="line">            [self cancelTask:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)executeWithTarget:(id)target</span><br><span class="line">                 action:(SEL)action</span><br><span class="line">                  start:(NSTimeInterval)star</span><br><span class="line">               interval:(NSTimeInterval)interval</span><br><span class="line">               repeates:(BOOL)repeates</span><br><span class="line">                  async:(BOOL)async &#123;</span><br><span class="line">    </span><br><span class="line">    if (!target || !action) &#123; return nil; &#125;</span><br><span class="line">    </span><br><span class="line">    return [self executeTask:^&#123;</span><br><span class="line">        if ([target respondsToSelector:action]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            [target performSelector:action];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; start:star interval:interval repeates:repeates async:async];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)cancelTask:(id)key &#123;</span><br><span class="line">    if (!key) &#123; return; &#125;</span><br><span class="line">    dispatch_semaphore_wait(semphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_source_t timer = timers_[key];</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">        [timers_ removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(semphore_);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="iOS-程序内存布局"><a href="#iOS-程序内存布局" class="headerlink" title="iOS 程序内存布局"></a>iOS 程序内存布局</h3><p>iOS 内存布局如下所示：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="内存布局"></p><p>来做个简单验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        static int c = 20;</span><br><span class="line">        static int d;</span><br><span class="line">        int e;</span><br><span class="line">        int f = 20;</span><br><span class="line">        NSString *str = @&quot;123&quot;;</span><br><span class="line">        NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;\n&amp;a=%p\n&amp;b=%p\n&amp;c=%p\n&amp;d=%p\n&amp;e=%p\n&amp;f=%p\nstr=%p\nobj=%p\n&quot;,</span><br><span class="line">              &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, str, obj);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">/*</span><br><span class="line"> 字符串常量</span><br><span class="line"> str=0x10dfa0068</span><br><span class="line"> </span><br><span class="line"> 已初始化的全局变量、静态变量</span><br><span class="line"> &amp;a =0x10dfa0db8</span><br><span class="line"> &amp;c =0x10dfa0dbc</span><br><span class="line"> </span><br><span class="line"> 未初始化的全局变量、静态变量</span><br><span class="line"> &amp;d =0x10dfa0e80</span><br><span class="line"> &amp;b =0x10dfa0e84</span><br><span class="line"> </span><br><span class="line"> 堆</span><br><span class="line"> obj=0x608000012210</span><br><span class="line"> </span><br><span class="line"> 栈</span><br><span class="line"> &amp;f =0x7ffee1c60fe0</span><br><span class="line"> &amp;e =0x7ffee1c60fe4</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><blockquote><p>从64 bit 开始，iOS 引入了 TaggedPointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象的存储。</p><p>在没有 Tagged Pointer 之前，NSNumber 等对象需要动态分配内存、维护引用计数等，NSNumber 指针存储的是堆中 NSNumber 对象的地址值。</p><p>在使用了 Tagged Pointer 之后，NSNumber 指针里面存储的数据标称了：Tag+Data，也就是将数据直接存储在了指针中。</p><p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。</p><p>objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据，节省了以前的调用开销。</p></blockquote><p>下面来看下怎么样判断一个指针是否是 Tagged Pointer 呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static inline bool </span><br><span class="line">_objc_isTaggedPointer(const void * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_OSX &amp;&amp; __x86_64__</span><br><span class="line">    // 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">    // Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 1</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK 0xfUL</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如上，指针是否是 Tagged Pointer 是通过 <code>&amp;mask</code> 得到的，看下上面的 mask 值是区分 <code>iPhone</code> 和 <code>Mac</code> 的。</p><p>可以看到：</p><ul><li>iOS 平台：最高有效位是 1（第64 bit）</li><li>Mac 平台：最低有效位是 1</li></ul><p>具体的 isa 指针各个位的标识之前在 <a href="https://jueying-xiangfeng.github.io/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">Runtime原理探究</a> 中有讲到过。</p><h3 id="OC-对象的内存管理"><a href="#OC-对象的内存管理" class="headerlink" title="OC 对象的内存管理"></a>OC 对象的内存管理</h3><p>在 iOS 中，使用引用计数来管理 OC 对象的内存。</p><p>一个新创建的 OC 对象引用计数默认为 1，当引用计数器减为0，OC 对象就销毁，释放占用的内存空间。</p><p>调用 retain 会让 OC 对象的引用计数 +1，release 会 -1.</p><p>内存管理经验总结：</p><ul><li>当调用 alloc、malloc、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放。</li><li>想拥有某个对象，就让它的引用计数 +1，不想在拥有某个对象，就让它的引用计数 -1。</li></ul><h3 id="copy、mutableCopy"><a href="#copy、mutableCopy" class="headerlink" title="copy、mutableCopy"></a>copy、mutableCopy</h3><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/copy%E3%80%81mutableCopy.png" alt="copy、mutableCopy"></p><h3 id="weak-原理"><a href="#weak-原理" class="headerlink" title="weak 原理"></a>weak 原理</h3><p>先来看下 dealloc 方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        // Slow path for raw pointer isa.</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://jueying-xiangfeng.github.io/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">Runtime原理探究</a> 中我们讲到过 ISA 指针的各个位的作用，在 dealloc 时如果没有 <code>关联对象(has_assoc)</code>、<code>c++析构函数(has_cxx_dtor)</code>、<code>弱引用(weakly_referenced)</code>、<code>是否使用 sidetable(has_sidetable_rc)</code> 时释放会更快。这里我们单独看一下 weak，跟到 <code>clearDeallocating_slow</code> 方法可以看到最终的结构：<code>SideTable</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// RefcountMap disguises its pointers because we </span><br><span class="line">// don&apos;t want the table to act as a root for `leaks`.</span><br><span class="line">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</span><br><span class="line"></span><br><span class="line">struct weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef DisguisedPtr&lt;objc_object *&gt; weak_referrer_t;</span><br><span class="line"></span><br><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : 2;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool out_of_line() &#123;</span><br><span class="line">        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(this, &amp;other, sizeof(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[0] = newReferrer;</span><br><span class="line">        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上，Sidetable 包含三部分内容，lock 部分不用管，这里的 RefcountMap 就是当 ISA 指针存储不下引用计数时有 Sidetable 存储的散列表。如果 <code>isa.has_sidetable_rc</code> 为 true，则会调用 <code>table.refcnts.erase(this);</code> 清除相关的引用。</p><p>再来看下 <code>weak_table</code> 结构，可以看到 weak_table 不会对修饰的对象产生强引用，而当对象被 <code>weak</code> 修饰过，则在释放时就会调用 <code>weak_clear_no_lock(&amp;table.weak_table, (id)this);</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            // 重点：这里将 weakReference 置为 nil</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上源码所示，在释放内存时，会将相关的 weak reference 设置为 nil，这也就是为什么使用 <code>__weak</code> 修饰过的变量在被修饰的对象释放时能置为 nil 的原理。</p><blockquote><p>ARC 就是 LLVM 编译器和 Runtime 系统相互协作的结果</p></blockquote><h3 id="Autorelease-原理"><a href="#Autorelease-原理" class="headerlink" title="Autorelease 原理"></a>Autorelease 原理</h3><p>当将对象调用 <code>autorelease</code> 方法后，就会被加入到 <code>自动释放池</code> 里面，使用 clang 命令来看下 autoreleasepool 到底被编译成了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里被编译成了 <code>__AtAutoreleasePool</code>，然后在 objc 源码里面查找 <code>autorelease</code> 方法，最终可以看到 autorelease 的管理类：<code>autoreleasepoolpage</code>。</p><p>所以自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code>。调用了 autorelease 的对象最终都是通过 AutoreleasePoolPage 对象来管理的。来看下 AutoreleasePoolPage 的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    static size_t const SIZE = </span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MAX_SIZE;  // size and alignment, power of 2 -- 4096</span><br><span class="line">#endif</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">  </span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 AutoreleasePoolPage 定义里面的 PAGE_MAX_SIZE 可以看到占用 4096 字节的内存。除了用来存放它内存的成员变量，剩下的空间用来存放 autorelease 对象的地址。</p><p>所有的 AutoreleasePoolPage 对象都是通过双向量表的形式连接在一起的。</p><p>来看下原理结构图：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autoreleasepoolpage.png" alt="autoreleasepoolpage原理"></p><p>调用 push 方法会将一个 POOL_BOUNDARY 入栈，并且返回其存放的内存地址。</p><p>调用 pop 方法时传入一个 POOL_BOUNDARY 的内存地址，会从最后一个入栈的对象开始发送 release 消息，直到遇到这个 POOL)BOUNDARY。</p><p>id *next 指向了下一个能存放 autorelease 对象地址的区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="comment">// push 时将 POOL_BOUNDARY 入栈，并返回 POOL_BOUNDARY 入栈的地址</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">    <span class="comment">// 判断当前是否是 hotpage，如果不是则调用 coldePage 的 pop 方法</span></span><br><span class="line">    <span class="comment">// 如果当前是 hotPage，则调用 releaseUntil 方法</span></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">            <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">            <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">            pop(coldPage()-&gt;begin());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can't prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 知道找到上一个与之对应的 POOL_BOUNDARY，否则中间的对象都调用 release 方法进行释放</span></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下一个变量被标记为 autorelease 后，是在什么时候 release 的。</p><p>自动释放池是有 RunLoop 控制的，加入自动释放池的变量会在某次 RunLoop 循环中，RunLoop休眠之前调用 release。</p><p>而我们平时开发时主线程的 RunLoop 中已经注册了 2 个 observer：</p><ol><li>第一个 observer 监听了 kCFRunLoopEntry 事件，会调用 objc_autoreleasePoolPush()。</li><li>第二个 observer 监听了两个事件<ul><li>kCFRunLoopBeforeWaiting 事件，会调用 objc_autoreleasePoolPop()、objc_autoreleasePoolPush()。</li><li>kCFRunLoopBeforeExit 事件，会调用 objc_autoreleasePoolPop()。</li></ul></li></ol><p>具体的应用可以看下 YY 大神的 <a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Base/Foundation/NSThread%2BYYAdd.m" target="_blank" rel="noopener">YYKit</a>  NSThread+YYAdd 相关代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">static inline void YYAutoreleasePoolPush() &#123;</span><br><span class="line">    NSMutableDictionary *dic =  [NSThread currentThread].threadDictionary;</span><br><span class="line">    NSMutableArray *poolStack = dic[YYNSThreadAutoleasePoolStackKey];</span><br><span class="line">    </span><br><span class="line">    if (!poolStack) &#123;</span><br><span class="line">        /*</span><br><span class="line">         do not retain pool on push,</span><br><span class="line">         but release on pop to avoid memory analyze warning</span><br><span class="line">         */</span><br><span class="line">        CFArrayCallBacks callbacks = &#123;0&#125;;</span><br><span class="line">        callbacks.retain = PoolStackRetainCallBack;</span><br><span class="line">        callbacks.release = PoolStackReleaseCallBack;</span><br><span class="line">        poolStack = (id)CFArrayCreateMutable(CFAllocatorGetDefault(), 0, &amp;callbacks);</span><br><span class="line">        dic[YYNSThreadAutoleasePoolStackKey] = poolStack;</span><br><span class="line">        CFRelease(poolStack);</span><br><span class="line">    &#125;</span><br><span class="line">    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // create</span><br><span class="line">    [poolStack addObject:pool]; // push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void YYAutoreleasePoolPop() &#123;</span><br><span class="line">    NSMutableDictionary *dic =  [NSThread currentThread].threadDictionary;</span><br><span class="line">    NSMutableArray *poolStack = dic[YYNSThreadAutoleasePoolStackKey];</span><br><span class="line">    [poolStack removeLastObject]; // pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void YYRunLoopAutoreleasePoolObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">        // 进入 loop 时 push</span><br><span class="line">        case kCFRunLoopEntry: &#123;</span><br><span class="line">            YYAutoreleasePoolPush();</span><br><span class="line">        &#125; break;</span><br><span class="line">        // loop 一圈走完，先 pop 然后在 push</span><br><span class="line">        case kCFRunLoopBeforeWaiting: &#123;</span><br><span class="line">            YYAutoreleasePoolPop();</span><br><span class="line">            YYAutoreleasePoolPush();</span><br><span class="line">        &#125; break;</span><br><span class="line">        // 退出时 pop</span><br><span class="line">        case kCFRunLoopExit: &#123;</span><br><span class="line">            YYAutoreleasePoolPop();</span><br><span class="line">        &#125; break;</span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void YYRunloopAutoreleasePoolSetup() &#123;</span><br><span class="line">    CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line">    // 当前线程添加监听：kCFRunLoopEntry、kCFRunLoopBeforeWaiting | kCFRunLoopExit</span><br><span class="line">    CFRunLoopObserverRef pushObserver;</span><br><span class="line">    pushObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopEntry,</span><br><span class="line">                                           true,         // repeat</span><br><span class="line">                                           -0x7FFFFFFF,  // before other observers</span><br><span class="line">                                           YYRunLoopAutoreleasePoolObserverCallBack, NULL);</span><br><span class="line">    CFRunLoopAddObserver(runloop, pushObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(pushObserver);</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverRef popObserver;</span><br><span class="line">    popObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                          true,        // repeat</span><br><span class="line">                                          0x7FFFFFFF,  // after other observers</span><br><span class="line">                                          YYRunLoopAutoreleasePoolObserverCallBack, NULL);</span><br><span class="line">    CFRunLoopAddObserver(runloop, popObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(popObserver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation NSThread (YYAdd)</span><br><span class="line"></span><br><span class="line">+ (void)addAutoreleasePoolToCurrentRunloop &#123;</span><br><span class="line">    // 主线程存在自动释放池，所以这里只需要在子线程中添加  </span><br><span class="line">    if ([NSThread isMainThread]) return; // The main thread already has autorelease pool.</span><br><span class="line">    NSThread *thread = [self currentThread];</span><br><span class="line">    if (!thread) return;</span><br><span class="line">    if (thread.threadDictionary[YYNSThreadAutoleasePoolKey]) return; // already added</span><br><span class="line">    YYRunloopAutoreleasePoolSetup();</span><br><span class="line">    thread.threadDictionary[YYNSThreadAutoleasePoolKey] = YYNSThreadAutoleasePoolKey; // mark the state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近时间比较散，还有就是公司比较动荡😌，当初怀着一颗做事的心来到这里，没想到最后落得这样的结局。不说了，还是保持本心比较好，尽管想做好飞读，但是我们小职员也改变不了什么。做好自己的事情就好，按着学习计划继续。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2020/08/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/05/多线程/</id>
    <published>2020-08-05T07:11:52.000Z</published>
    <updated>2020-08-05T14:51:49.736Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RunLoop原理探究</title>
    <link href="http://yoursite.com/2020/07/29/RunLoop%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2020/07/29/RunLoop原理探究/</id>
    <published>2020-07-29T03:17:19.000Z</published>
    <updated>2020-08-15T14:30:57.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RunLoop-概念"><a href="#RunLoop-概念" class="headerlink" title="RunLoop 概念"></a>RunLoop 概念</h3><p>顾名思义，RunLoop 就是运行循环，在程序运行过程中循环做一些事情。这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event Loop</a>，这种模型的关键点在于：如何管理事件/消息，如果保证线程在没有处理消息时休眠避免资源占用、再有消息到来时立刻被唤醒。</p><a id="more"></a><p>一般来说，一个线程一次只能执行一次任务，执行完成后线程就会退出，如果要保证线程能随时处理事件但不退出，我们可能需要这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 睡眠中等待消息</span><br><span class="line">            int message = sleep_and_wait();</span><br><span class="line">            // 处理消息</span><br><span class="line">            retVal = process_message(message);</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 其实就是一个对象，这个对象管理了其需要处理的消息和事件，并且提供了一个入口函数来执行上面的 Event Loop 逻辑。线程执行了这个函数后，会一直处于：接受消息-&gt;等待-&gt;处理消息 的循环中，直到 retVal 为0才会退出函数。</p><p>可以在<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">这里</a>下载到 CoreFoundation的源码来查看具体实现。</p><h3 id="RunLoop-结构"><a href="#RunLoop-结构" class="headerlink" title="RunLoop 结构"></a>RunLoop 结构</h3><p>iOS 有两套 API 来访问和使用 RunLoop：<code>NSRunLoop</code>、<code>CFRunLoop</code>。NSRunLoop 是基于 CFRunLoop 的包装</p><p>Core Foundation 中关于 RunLoop 的类有5个：</p><ol><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ol><p>CFRunLoopRef：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    CFMutableSetRef _commonModes;<span class="comment">// set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// set&lt;Source、Observer、Timer&gt;</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;<span class="comment">// current mode</span></span><br><span class="line">    CFMutableSetRef _modes;<span class="comment">// set</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CFRunLoopModeRef：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFStringRef _name; <span class="comment">// mode name：such as - kCFRunLoopDefaultMode</span></span><br><span class="line">    CFMutableSetRef _sources0;<span class="comment">// set</span></span><br><span class="line">    CFMutableSetRef _sources1;<span class="comment">// set</span></span><br><span class="line">    CFMutableArrayRef _observers;<span class="comment">// array</span></span><br><span class="line">    CFMutableArrayRef _timers;<span class="comment">// array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有个概念叫做 commonModes：一个 mode 可以将自己标记为 common 属性（通过将其 mode name 添加到 RunLoop 的 commonModes 中）。每当 RunLoop 内容发生时，RunLoop 会自动将 commonModeItems 里面的 source/observer/timer 同步到具有 common 标记的所有 mode 里面。</p><p>CFRunLoop 对外暴露的管理 mode 的接口有两个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure><p>mode 暴露的管理 mode item 的接口有以下几个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure><p>这里只能通过 mode name 来操作内部的 mode，当传入一个新的 mode name 单 RunLoop 里面没有对应的 mode 时，RunLoop 内部会自动创建 CFRunLoopModeRef。对于一个 Runloop 来说，内部的 mode 只能增加，不能删除。</p><p>苹果公开的 mode 有两个</p><ol><li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</li><li>UITrackingRunLoopMode</li></ol><p>这里还提供了一个操作 common 标记符的字符串 kCFRunLoopCommonModes (NSRunLoopCommonModes)。使用时注意这个标记和其他的 mode name。</p><p>看下 RunLoop 图示结构：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runloop/runloop%E7%BB%93%E6%9E%84.png" alt="RunLoop结构"></p><p>从上图的结构可以看到，一个 RunLoop 包含若干个 mode，每个 mode 有包含若干个 source/observer/timer，每次调用 RunLoop 的主函数时，只能指定其中一个 mode 作为 currentMode。如果需要切换 mode，只能退出当前 loop，再重新指定一个 mode 进入。这样做是为了不同组的 source/observer/timer，可以做到互不影响。</p><p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。source 有两个版本：source0 和 source1</p><ul><li>source0：只包含了一个回调（函数指针），它并不能主动触发事件。使用时需要先调用 CFRunLoopSourceSignal(source)，将这个 source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 – 触摸事件处理、performSelector:onThread；</li><li>source1：包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息，这种 source 能主动唤醒 RunLoop 的线程。 – 基于 port 的线程间通信、系统事件捕捉。</li></ul><p><strong>CFRunLoopTimerRef</strong> 是基于事件的触发器，它和 NSTimer 是可以混用的。当加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个任务。 – NSTimer、performSelector:withObject:afterDelay:</p><p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 observer 都包含了一个回调，当 RunLoop 的状态发生改变时，观察者就能通过回调接收到这个变化。</p><p>– 用于监听 RunLoop 的状态、UI 刷新（BeforeWaiting）、Autorelease pool（BeforeWaiting）</p><p>可以观测到的状态有一下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入 RunLoop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 即将被唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出 RunLoop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 source/timer/observer 统称为 mode item，一个 item 可以被同时加入多个 mode，但一个 item 被重复加入同一个 mode 是不会有效果的。如果一个 mode 里面一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h3><p>每条线程都有唯一一个与之对应的 RunLoop 对象，他们是一一对应的。</p><p>线程在刚创建时是没有 RunLoop 对象的，RunLoop 会在第一次获取它时创建，我们通常获取的方式有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopGetMain();</span><br><span class="line">[NSRunLoop currentRunLoop];</span><br><span class="line">[NSRunLoop mainRunLoop];</span><br></pre></td></tr></table></figure><p>来看下获取的源码，已 getCurrent 为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的 Dictionary，key 是 pthread_t，value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> CFLock_t loopsLock = CFLockInit;<span class="comment">// 访问 __CFRunLoops 时的锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for "main thread" that always works</span></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">// 线程为空则获取主线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果全局的 CFMutableDictionaryRef 为空，则先初始化全局的 CFMutableDictionaryRef，并先为主线程创建一个 RunLoop</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接从全局 CFMutableDictionaryRef 里面获取</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取不到则创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop</span></span><br><span class="line">    _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有源码分析可知：</p><ul><li>线程和 RunLoop 是一一对应的</li><li>RunLoop 保存在一个全局的 Dictionary 里面，pthread_t 为 key，RunLoop 为 value</li><li>线程刚创建时并没有 RunLoop，RunLoop 会在第一次获取它时创建</li><li>RunLoop 会在线程结束时销毁</li><li>只能在线程内部获取 RunLoop（主线程除外）</li></ul><h3 id="4、RunLoop-的运行逻辑"><a href="#4、RunLoop-的运行逻辑" class="headerlink" title="4、RunLoop 的运行逻辑"></a>4、RunLoop 的运行逻辑</h3><p>先来看流程图：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runloop/runloop%E6%B5%81%E7%A8%8B.png" alt="runloop流程"></p><p>来分析下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;/* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    </span><br><span class="line">    /// 根据 mode name 找打对应 mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    /// 如果 mode 里面没有 source/timer/observer 则直接返回</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; return; &#125;</span><br><span class="line">    </span><br><span class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">/// 1、通知 observer 即将进入 loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    /// 进入 RunLoop</span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    /// 11、通知 observer 退出 loop</span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* rl, rlm are locked on entrance and exit */</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    </span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 2、通知Observers：即将处理Timers</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        // 3、通知Observers：即将处理Sources</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        // 4、处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        // 5、处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        // 6、判断有无Source1</span><br><span class="line">        if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">            // 如果有Source1 则跳转到 handle_msg -- 即 第 8 步</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 7、通知Observers：即将休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 等待别的消息唤醒当前线程</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        // 8、通知Observers：结束休眠 -- 被某个消息唤醒</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    handle_msg:</span><br><span class="line">        </span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            // 8.1、处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">        &#125; else if (被GCD唤醒) &#123;</span><br><span class="line">            // 8.2、处理 GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 8.3、处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        // 9、处理BLocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        // 10、根据当前结果决定如何操作</span><br><span class="line">        // -- 1&gt; 回到第 2 步</span><br><span class="line">        // -- 2&gt; 退出 RunLoop</span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            // 进入 loop 时处理完事件就返回</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            // 超出传入参数标记的时间了</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            // 被外部调用强制停止了</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;  else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            // source/timer/observer 一个都没有时</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">        </span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下 RunLoop 休眠原理：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runloop/runloop%E4%BC%91%E7%9C%A0%E5%8E%9F%E7%90%86.png" alt="runloop休眠原理"></p><h3 id="RunLoop-应用"><a href="#RunLoop-应用" class="headerlink" title="RunLoop 应用"></a>RunLoop 应用</h3><h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>我们知道 NSTimer 是一个不准确的定时器，是有误差的。</p><p>当一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">uint16_t</span> _bits;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;<span class="comment">/* immutable */</span></span><br><span class="line">  <span class="comment">/// 误差 -- 宽容度</span></span><br><span class="line">    CFTimeInterval _tolerance;          <span class="comment">/* mutable */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _fireTSR;<span class="comment">/* TSR units */</span></span><br><span class="line">    CFIndex _order;<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerCallBack _callout;<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerContext _context;<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 timer 错过了某个时间点，例如执行一个很长的任务，则这个时间点的回调也会跳过去，不会延后执行。所以错过了就需要等下一次的 loop，这也就是 timer 不准确的原因。</p><p>再有就是 Timer 在滑动时会失效的问题。因为 RunLoop 只能选择一个 mode 运行，如果 timer 处于 kCFRunLoopDefaultMode 时，此时界面滑动，RunLoop 会切换到另一种模式：UITrackingRunLoopMode，此时界面处于跟踪 mode，此种模式用于 scrollView 追踪触摸滑动，保证界面滑动时不受其他 mode 影响，但是相对了也会使处于 default mode 的 timer 失效。</p><p>有两种方式解决：</p><ol><li>将 timer 依次加入到上述两个 mode 里面</li><li>将 timer 放到顶层的 commonModeItems 里面，commonModeItems 会被 RunLoop 自动更新到具有 common 属性的 mode 里面去</li></ol><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD 的某些接口也用到了 RunLoop，例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    // 处理一些子线程的逻辑</span><br><span class="line">    </span><br><span class="line">    // 回到主线程去刷新UI界面</span><br><span class="line">    dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>当调用 <code>dispatch_async(dispatch_get_main_queue(), ^{})</code> 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调里面执行这个 block。这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是有 libDispatch 处理的。 </p><h4 id="PerformSelector"><a href="#PerformSelector" class="headerlink" title="PerformSelector"></a>PerformSelector</h4><p>看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [self performSelector:@selector(test1)];</span><br><span class="line">        [self performSelector:@selector(test2) withObject:nil];</span><br><span class="line">        [self performSelector:@selector(test3) withObject:nil withObject:nil];</span><br><span class="line">        </span><br><span class="line">        [self performSelector:@selector(test4) withObject:nil afterDelay:0];</span><br><span class="line">        </span><br><span class="line">        [self performSelector:@selector(test5) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">        </span><br><span class="line">//        [[NSRunLoop currentRunLoop] addPort:[NSPort new] forMode:NSDefaultRunLoopMode];</span><br><span class="line">//        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test1 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test2 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test3 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test4 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test5 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有在子线程获取 RunLoop 时，是没有 test4 和 test5 方法打印的，当添加 RunLoop 时才会有方法打印。因为子线程默认是没有 RunLoop 的。</p><p>来看下 <code>[self performSelector:@selector(test4) withObject:nil afterDelay:0];</code>的调用栈：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* thread #<span class="number">4</span>, queue = <span class="string">'com.apple.root.default-qos'</span>, stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x0000000109013387</span> Interview01-runloop流程`-[ViewController test4](self=<span class="number">0x00007fd80c40b680</span>, _cmd=<span class="string">"test4"</span>) at ViewController.m:<span class="number">66</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff25958d64</span> Foundation`__NSFireDelayedPerform + <span class="number">420</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x00007fff23da2414</span> CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + <span class="number">20</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00007fff23da20ae</span> CoreFoundation`__CFRunLoopDoTimer + <span class="number">1038</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00007fff23da170a</span> CoreFoundation`__CFRunLoopDoTimers + <span class="number">282</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x00007fff23d9c35e</span> CoreFoundation`__CFRunLoopRun + <span class="number">1950</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00007fff23d9b8a4</span> CoreFoundation`CFRunLoopRunSpecific + <span class="number">404</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x00007fff25957c71</span> Foundation`-[NSRunLoop(NSRunLoop) runMode:beforeDate:] + <span class="number">211</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00007fff25957e85</span> Foundation`-[NSRunLoop(NSRunLoop) run] + <span class="number">76</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000109013254</span> Interview01-runloop流程`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="number">0x00006000022fe3d0</span>) at ViewController.m:<span class="number">48</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x000000010927af11</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x000000010927be8e</span> libdispatch.dylib`_dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x000000010927e2d8</span> libdispatch.dylib`_dispatch_queue_override_invoke + <span class="number">1022</span></span><br><span class="line">    frame #<span class="number">13</span>: <span class="number">0x000000010928d399</span> libdispatch.dylib`_dispatch_root_queue_drain + <span class="number">351</span></span><br><span class="line">    frame #<span class="number">14</span>: <span class="number">0x000000010928dca6</span> libdispatch.dylib`_dispatch_worker_thread2 + <span class="number">135</span></span><br><span class="line">    frame #<span class="number">15</span>: <span class="number">0x00007fff522b39f7</span> libsystem_pthread.dylib`_pthread_wqthread + <span class="number">220</span></span><br><span class="line">    frame #<span class="number">16</span>: <span class="number">0x00007fff522b2b77</span> libsystem_pthread.dylib`start_wqthread + <span class="number">15</span></span><br></pre></td></tr></table></figure><p>可以看出触发的是 timer。</p><p>再来看下 <code>[self performSelector:@selector(test5) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</code>的调用栈：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* thread #<span class="number">4</span>, queue = <span class="string">'com.apple.root.default-qos'</span>, stop reason = breakpoint <span class="number">2.1</span></span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001090133b7</span> Interview01-runloop流程`-[ViewController test5](self=<span class="number">0x00007fd80c40b680</span>, _cmd=<span class="string">"test5"</span>) at ViewController.m:<span class="number">70</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff2596de42</span> Foundation`__NSThreadPerformPerform + <span class="number">209</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x00007fff23da1c91</span> CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + <span class="number">17</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00007fff23da1bbc</span> CoreFoundation`__CFRunLoopDoSource0 + <span class="number">76</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00007fff23da1394</span> CoreFoundation`__CFRunLoopDoSources0 + <span class="number">180</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x00007fff23d9bf8e</span> CoreFoundation`__CFRunLoopRun + <span class="number">974</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00007fff23d9b8a4</span> CoreFoundation`CFRunLoopRunSpecific + <span class="number">404</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x00007fff25957c71</span> Foundation`-[NSRunLoop(NSRunLoop) runMode:beforeDate:] + <span class="number">211</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00007fff25957e85</span> Foundation`-[NSRunLoop(NSRunLoop) run] + <span class="number">76</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000109013254</span> Interview01-runloop流程`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="number">0x00006000022fe3d0</span>) at ViewController.m:<span class="number">48</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x000000010927af11</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x000000010927be8e</span> libdispatch.dylib`_dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x000000010927e2d8</span> libdispatch.dylib`_dispatch_queue_override_invoke + <span class="number">1022</span></span><br><span class="line">    frame #<span class="number">13</span>: <span class="number">0x000000010928d399</span> libdispatch.dylib`_dispatch_root_queue_drain + <span class="number">351</span></span><br><span class="line">    frame #<span class="number">14</span>: <span class="number">0x000000010928dca6</span> libdispatch.dylib`_dispatch_worker_thread2 + <span class="number">135</span></span><br><span class="line">    frame #<span class="number">15</span>: <span class="number">0x00007fff522b39f7</span> libsystem_pthread.dylib`_pthread_wqthread + <span class="number">220</span></span><br><span class="line">    frame #<span class="number">16</span>: <span class="number">0x00007fff522b2b77</span> libsystem_pthread.dylib`start_wqthread + <span class="number">15</span></span><br></pre></td></tr></table></figure><p>这次触发的是 source0。</p><h4 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h4><p>我们知道当线程在执行完当前任务后就会退出，那么如果想要线程在执行完任务后依然保留，当我们彻底不需要时再将线程退出。这个时候就需要使用 RunLoop 来做到线程保活，我们自己来控制线程的生命周期。</p><p>来做个测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface XFThread : NSThread</span><br><span class="line">@end</span><br><span class="line">@implementation XFThread</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) XFThread * thread;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.thread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;---- tread begin -----&quot;);</span><br><span class="line">      </span><br><span class="line">        NSLog(@&quot;---- tread end -----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    [self performSelector:@selector(threadAction) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadAction &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当 push 进 ViewController 时，可以看到 thread 的 begin、end 都已经打印完，此时当我们点击屏幕的时候，并没有走 <code>threadAction</code>方法，而当把 waitUntilDone 参数设置为 YES 时，会直接报出坏内存访问的 crash，因为线程在 start 时已经执行完任务了，这条线程已经是一个没用的线程，不能再用来执行任务了。</p><p>这是就需要用到了 RunLoop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    self.thread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;---- tread begin -----&quot;);</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line"> </span><br><span class="line">        NSLog(@&quot;---- tread end -----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)stop:(id)sender &#123;</span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopThread &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 RunLoop 后再增加一个 stop 按钮，当点击 stop 时，我们发现并没有执行 tread end。这是因为 run 方法导致的，来看下 run 方法的官方解释：</p><blockquote><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the <code>NSDefaultRunLoopMode</code> by repeatedly invoking <a href="apple-reference-documentation://hcGlc34FMW" target="_blank" rel="noopener"><code>runMode:beforeDate:</code></a>. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers. </p><p>Manually removing all known input sources and timers from the run loop is not a guarantee that the run loop will exit. macOS can install and remove additional input sources as needed to process requests targeted at the receiver’s thread. Those sources could therefore prevent the run loop from exiting. </p><p>If you want the run loop to terminate, you shouldn’t use this method. Instead, use one of the other run methods and also check other arbitrary conditions of your own, in a loop. A simple example would be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BOOL shouldKeepRunning = YES; // global</span><br><span class="line">&gt; NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">&gt; while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>where <code>shouldKeepRunning</code> is set to <code>NO</code> somewhere else in the program.</p></blockquote><p>可以看到 run 方法是用来设置永不销毁的线程的，如果想要控制线程的生命周期，需要使用 example 里面的方法。来试下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) XFThread * thread;</span><br><span class="line">@property (nonatomic, assign, getter=isStoped) BOOL stoped;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    typeof(self) __weak weakSelf = self;</span><br><span class="line">    self.stoped = NO;</span><br><span class="line">    </span><br><span class="line">    self.thread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;---- tread begin -----&quot;);</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        while (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;---- tread end -----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadAction &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)stop:(id)sender &#123;</span><br><span class="line">    if (!self.thread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopThread &#123;</span><br><span class="line">    self.stoped = YES;</span><br><span class="line"></span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line"></span><br><span class="line">    self.thread = nil;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    if (!self.thread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(threadAction) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此时直接退出界面或者主动触发 stop，会出现 crash，因为此时 stopThread 和 dealloc 方法是同事进行的，这里需要保证先执行 stopTread，然后在执行 dealloc。所以这里需要把 waitUntilDone 方法设置为 YES：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)stop:(id)sender &#123;</span><br><span class="line">    if (!self.thread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美解决~</p><p>简单来封装下 thread：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">@interface XFThread : NSThread</span><br><span class="line">@end</span><br><span class="line">@implementation XFThread</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@interface XFPermenentThread : NSObject</span><br><span class="line">- (void)stop;</span><br><span class="line">- (void)executeTask:(dispatch_block_t)task;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface XFPermenentThread ()</span><br><span class="line">@property (nonatomic, strong) XFThread * innerThread;</span><br><span class="line">@property (nonatomic, assign, getter=isStopped) BOOL stopped;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XFPermenentThread</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.stopped = NO;</span><br><span class="line">        </span><br><span class="line">        typeof(self) __weak weakSelf = self;</span><br><span class="line">        </span><br><span class="line">        self.innerThread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line">            </span><br><span class="line">            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">            </span><br><span class="line">            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [self.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stop &#123;</span><br><span class="line">    if (!self.innerThread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)executeTask:(dispatch_block_t)task &#123;</span><br><span class="line">    if (!self.innerThread || !task) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__stop &#123;</span><br><span class="line">    self.stopped = YES;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    self.innerThread = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__executeTask:(dispatch_block_t)task &#123;</span><br><span class="line">    !task ? : task();</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>至此我们可以做到手动控制一条线程的生命周期。</p><h3 id="参考-："><a href="#参考-：" class="headerlink" title="参考 ："></a>参考 ：</h3><ol><li>YY 大神：<a href="https://blog.ibireme.com/2015/05/18/runloop/#more-41710" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/#more-41710</a></li><li>官方源码：<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RunLoop-概念&quot;&gt;&lt;a href=&quot;#RunLoop-概念&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 概念&quot;&gt;&lt;/a&gt;RunLoop 概念&lt;/h3&gt;&lt;p&gt;顾名思义，RunLoop 就是运行循环，在程序运行过程中循环做一些事情。这种模型通常被称作 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event_loop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Event Loop&lt;/a&gt;，这种模型的关键点在于：如何管理事件/消息，如果保证线程在没有处理消息时休眠避免资源占用、再有消息到来时立刻被唤醒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RunLoop" scheme="http://yoursite.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>Runtime原理探究</title>
    <link href="http://yoursite.com/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2020/07/20/Runtime原理探究/</id>
    <published>2020-07-20T02:39:44.000Z</published>
    <updated>2020-08-15T14:30:11.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原计划一周一个模块，但是看到 runTime 这里持续时间有点长，底层内容很多啊，原因还是之前基础太差，菜的抠脚。。。还有整理完 block 后再想 block hook 应该怎么实现，瞎搞了一通最后找到了开源的库 <code>blockHook</code>，看了几天的源码发现底层掌握的还是不牢，其中包括 runtime 部分，先整理完 runtime 部分然后再回头重新分析 blockHook。</p></blockquote><p>下文内容是根据 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a> 版本分析的，目前最新版本是 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-781</a>，最新版本做了一些优化，不过不影响我们理解。</p><h3 id="isa-详解"><a href="#isa-详解" class="headerlink" title="isa 详解"></a>isa 详解</h3><a id="more"></a><p>在 arm64 结构之前，isa 就是一个普通指针，存储着 Class、Meta-Class 对象的内存地址。</p><p>从 arm64 结构开始，对 isa 进行了优化，变成了一个共用体（union）结构，使用位域来存储更多信息</p><p>更多信息是指 isa 除了存储对象内存地址外还存储了其他的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL  </span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33;</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>nonpointer：0 代表普通指针，存储着 Class、Meta-Class 对象的内存地址，1 代表优化过，使用位域存储更对信息</li><li>has_assoc：是否有设置过关联对象，如果没有释放时更快</li><li>has_cxx_dtor：是否有 C++ 的析构函数（.cxx_destruct），如果没有释放时更快</li><li>shiftcls：存储着 Class、Meta-Class 对象的内存地址信息</li><li>magic：用于在调试时分辨对相关是否完成初始化</li><li>weakly_referenced：是否有被弱引用指向过，如果没有，释放更快</li><li>deallocating： 对象是否正在释放</li><li>has_sidetable_rc：引用计数器是否过大无法存储在isa中。1标识引用计数会存储在side table的类属性中</li><li>extra_rc：里面存储的值是引用计数器减1</li></ul><p>这里可以简单看一下实例对象 isa 指针里面存储的类，我们这里只研究 arm64 架构，可以看到上面有 ISA_MASK，这个是用来取 Class、Meta-Class 对象的内存地址的，来个小实验：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"--- %p"</span>, [ViewController <span class="class"><span class="keyword">class</span>]);</span></span><br><span class="line"></span><br><span class="line">结果<span class="symbol">:</span></span><br><span class="line">--- <span class="number">0x1000b1cf0</span></span><br><span class="line"></span><br><span class="line">再来打印 <span class="keyword">self</span> 的 isa：</span><br><span class="line">(lldb) p/x <span class="keyword">self</span>-&gt;isa</span><br><span class="line">(Class) $0 = <span class="number">0x000005a1000b1cf7</span> ViewController</span><br><span class="line"></span><br><span class="line">可以看到上面的两个地址是不一样的，根据上面的结构，我们使用 ISA_MASK 来取一下 isa 中关于对象的内存地址：</span><br><span class="line">(lldb) p/x <span class="number">0x000005a1000b1cf7</span> &amp; <span class="number">0x0000000ffffffff8</span>ULL</span><br><span class="line">(unsigned long long) $1 = <span class="number">0x00000001000b1cf0</span></span><br><span class="line"></span><br><span class="line">由上可以看到，由 isa 取出来的地址和 ViewController <span class="class"><span class="keyword">class</span> 类的真实地址是一样的。</span></span><br></pre></td></tr></table></figure><p>关于上述标记位中更快释放，可以再 objc4 里面看到源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，在 dealloc 时会分别获取是否有关联对象、析构函数、弱指针等标记位，如果没有是直接释放的，否则会调用相关的方式释放对应的资源。</p><h3 id="Class-结构"><a href="#Class-结构" class="headerlink" title="Class 结构"></a>Class 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bits &amp; FAST_DATA_MASK 可以拿到 class_rw_t</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>class_rw_t 里面的 methods、properties、protocols 是二维数组，是可读可写的，包含类的初始内容、分类的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">method_array_t</span> :</span> </span><br><span class="line"><span class="keyword">public</span> list_array_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_array_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>&gt; Super;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Class_ro_t 里面的 baseMethodList、baseProtocols、ivars、baseProperties 是一维数组，是只读的，包含了类的初始信息。</p><p>下面来看下 method_t 的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;// 函数名</span><br><span class="line">    const char *types;// 编码（返回值类型、参数类型）</span><br><span class="line">    IMP imp; // 指向函数的指针（函数地址）</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,</span><br><span class="line">                                    const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>IMP 代表函数的具体实现：</p><p><code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p><p>SEL 代表方法\函数名，一般称作选择器，底层结构和 char* 类型</p><ul><li>可以通过 @selector() 和 sel_registerName() 获得</li><li>可以通过 sel_getName() 和 NSStringFromSelector() 转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul><p><code>typedef struct objc_selector *SEL;</code></p><p>types 是包含了函数返回值、参数编码的字符串</p><h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><p>Class 内部结构用有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key; // SEL 作为 key</span><br><span class="line">    IMP _imp;// 函数的内存地址</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets; // 散列表</span><br><span class="line">    mask_t _mask;// 散列表长度 - 1</span><br><span class="line">    mask_t _occupied; // 已经缓存的方法数量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t occupied();</span><br><span class="line">    void incrementOccupied();</span><br><span class="line">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class="line">    void initializeToEmpty();</span><br><span class="line"></span><br><span class="line">    mask_t capacity();</span><br><span class="line">    bool isConstantEmptyCache();</span><br><span class="line">    bool canBeFreed();</span><br><span class="line"></span><br><span class="line">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class="line">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    void expand();</span><br><span class="line">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class="line">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看下获取 cache 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 如果 i为0则从mask开始查找（mask为表长度-1），如果i不为空则从i-1开始查找</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = mask();</span><br><span class="line">    mask_t begin = cache_hash(k, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    // hack</span><br><span class="line">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>散列表扩容，从源码可以看到，每次扩容都是原来容积的两倍，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity = capacity();</span><br><span class="line">    uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    if ((uint32_t)(mask_t)newCapacity != newCapacity) &#123;</span><br><span class="line">        // mask overflow - can&apos;t grow further</span><br><span class="line">        // fixme this wastes one bit of mask</span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="objc-msgSend-执行流程"><a href="#objc-msgSend-执行流程" class="headerlink" title="objc_msgSend 执行流程"></a>objc_msgSend 执行流程</h3><h4 id="第一个阶段-消息发送"><a href="#第一个阶段-消息发送" class="headerlink" title="第一个阶段 - 消息发送"></a>第一个阶段 - 消息发送</h4><p>看一下下面的经典调用图片</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/oc-class.png" alt="oc-class.png"></p><p>下面看下消息发送的流程：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.png" alt="消息发送"></p><h4 id="第二个阶段-动态方法解析"><a href="#第二个阶段-动态方法解析" class="headerlink" title="第二个阶段 - 动态方法解析"></a>第二个阶段 - 动态方法解析</h4><p>调用流程如下：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90.png" alt="动态方法解析"></p><p>这里可以从 objc 的源码里面查到（lookUpImpOrForward 方法）：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    _class_resolveMethod(<span class="keyword">cls</span>, sel, inst);</span><br><span class="line">    runtimeLock.read();</span><br><span class="line">    <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">    <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line"><span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">cache_fill(<span class="keyword">cls</span>, sel, imp, inst);</span><br></pre></td></tr></table></figure><p>可以看到标记位 triedResolver 和我们流程图里面对应。</p><h4 id="第三个阶段-消息转发"><a href="#第三个阶段-消息转发" class="headerlink" title="第三个阶段 - 消息转发"></a>第三个阶段 - 消息转发</h4><p>看下流程图：</p><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="消息转发"></p><p>由于消息转发阶段没有开源，这里在网上扒出大神整理的伪代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">    <span class="keyword">id</span> receiver = *(<span class="keyword">id</span> *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        <span class="keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStret == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 僵尸对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(receiverClass);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *zombiePrefix = <span class="string">"_NSZombie_"</span>;</span><br><span class="line">    size_t prefixLen = strlen(zombiePrefix); <span class="comment">// 0xa</span></span><br><span class="line">    <span class="keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelError,</span><br><span class="line">              <span class="string">@"*** -[%s %s]: message sent to deallocated instance %p"</span>,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(methodSignatureForSelector:))) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">                <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">                      <span class="string">@"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s."</span>,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? <span class="string">""</span> : not,</span><br><span class="line">                      isStret ? <span class="string">""</span> : not);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardInvocation:))) &#123;</span><br><span class="line">                <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">                      <span class="string">@"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message"</span>,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selector 是否已经在 Runtime 注册过</span></span><br><span class="line">    <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort"</span>,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; <span class="comment">// doesNotRecognizeSelector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass,<span class="keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort"</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The point of no return.</span></span><br><span class="line">    kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Super-本质"><a href="#Super-本质" class="headerlink" title="Super 本质"></a>Super 本质</h3><h4 id="super-本质调用"><a href="#super-本质调用" class="headerlink" title="super 本质调用"></a>super 本质调用</h4><p>了解完 objc_msgSend 机制再来看下 super 的本质。</p><p>做个测试，重写 forwardInvocation 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用 clang 查看转换成的 c++ 代码</span><br><span class="line"></span><br><span class="line">((void (*)(__rw_objc_super *, SEL, NSInvocation *))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;MJPerson&quot;))&#125;, sel_registerName(&quot;forwardInvocation:&quot;), (NSInvocation *)anInvocation);</span><br><span class="line"></span><br><span class="line">删除强制转换：</span><br><span class="line">    objc_msgSendSuper(</span><br><span class="line">                      &#123;self, (id)class_getSuperclass(objc_getClass(&quot;MJPerson&quot;))&#125;,</span><br><span class="line">                      sel_registerName(&quot;forwardInvocation:&quot;),</span><br><span class="line">                      anInvocation);</span><br></pre></td></tr></table></figure><p>如上，使用 super 调用方法的时候不再是 objc_msgSend，而是 objc_msgSendSuper，发送消息时有三个参数：</p><ol><li>结构体 struct __rw_objc_super</li><li>方法名 SEL</li><li>参数 anInvocation</li></ol><p>这里主要看下第一个参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__rw_objc_super</span></span> &#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *object; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *superClass; </span><br><span class="line">__rw_objc_super(<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *o, <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面  objc_msgSendSuper 初始化的调用可以看到，super 的实质其实还是向 self 发送消息，receiver 依然是 self，只不过第二个参数是 superClass。</p><p>所以 super 的本质就是向 self（receiver）发送消息，不过查找方法时是从 super 开始查找。</p><p>其实这里看到的也并非最终的调用方式，通过源码或者汇编代码，或者用 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">这里</a> 调试查看，最终 super 生成的结构是：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct </span>objc_super2 &#123;</span><br><span class="line">    id receiver<span class="comment">;</span></span><br><span class="line">    Class current_class<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">ENTRY</span> _objc_msgSendSuper2</span><br><span class="line"></span><br><span class="line"><span class="keyword">ldr</span><span class="built_in">r9</span>, [<span class="built_in">r0</span>, <span class="symbol">#CLASS</span>]// class = <span class="keyword">struct </span>super-&gt;class</span><br><span class="line">// 通过 current_class 找到 superClass</span><br><span class="line"><span class="keyword">ldr</span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="symbol">#SUPERCLASS</span>]   // class = class-&gt;superclass</span><br><span class="line"><span class="symbol">CacheLookup</span> NORMAL, _objc_msgSendSuper2</span><br><span class="line">// cache hit, IMP in <span class="built_in">r12</span>, eq already set for nonstret forwarding</span><br><span class="line"><span class="keyword">ldr</span><span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="symbol">#RECEIVER</span>]// load real receiver</span><br><span class="line"><span class="keyword">bx</span><span class="built_in">r12</span>// call imp</span><br><span class="line"></span><br><span class="line"><span class="symbol">CacheLookup2</span> NORMAL, _objc_msgSendSuper2</span><br><span class="line">// cache miss</span><br><span class="line"><span class="keyword">ldr</span><span class="built_in">r9</span>, [<span class="built_in">r0</span>, <span class="symbol">#CLASS</span>]// class = <span class="keyword">struct </span>super-&gt;class</span><br><span class="line"><span class="keyword">ldr</span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="symbol">#SUPERCLASS</span>]   // class = class-&gt;superclass</span><br><span class="line"><span class="keyword">ldr</span><span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="symbol">#RECEIVER</span>]// load real receiver</span><br><span class="line"><span class="keyword">b</span>__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line"><span class="symbol">END_ENTRY</span> _objc_msgSendSuper2</span><br></pre></td></tr></table></figure><p>不管是 objc_super 还是 objc_super2，对这里的理解是没有影响的，消息的接收者就是 self，不过查找方法是从 superClass 开始查找的。</p><h4 id="结合消息发送机制对-super-调用方法的疑问"><a href="#结合消息发送机制对-super-调用方法的疑问" class="headerlink" title="结合消息发送机制对 super 调用方法的疑问"></a>结合消息发送机制对 super 调用方法的疑问</h4><blockquote><p>昨天写到 super 的时候突然想到了一个问题，就是 super 的本质是：消息接受者为 self，不过查找方法是在 superClass 开始查找，根据消息发送机制，查找到方法后会将 IMP 存入到 bucket 里面。</p><p>注意：这里的 bucket 是哪个 cls 的呢？</p><p>由于对上面 【4、消息发送】那张经典图片理解的不够，认为查找到目标方法后就是把对应的方法放到 receiver 的 cache_t 里面，结果就有了下面的这个猜想。。。</p></blockquote><p>猜想是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">- (void)studentTest;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">- (void)studentTest &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface GoodStudent : Student</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation GoodStudent</span><br><span class="line">- (void)studentTest &#123;</span><br><span class="line">    [super studentTest];</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    [super studentTest];</span><br><span class="line">    [self studentTest];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如上我们使用 GoodStudent 实例调用 test 方法，</p><ol><li>当调用完 <code>[super studentTest];</code>后，GoodStudent 的 cache_t 里面就应该有了<code>studentTest</code>方法的缓存</li><li>当执行 <code>[self studentTest];</code>时，根据消息发送机制，在缓存中查找到了第一步调用的缓存，也就是 superClass 的方法缓存</li><li>所以结果就是只要缓存还在就不会调用到 self 的 <code>studentTest</code> 方法</li></ol><p>看完我的猜想是不是感觉很扯，但是就这困惑了我很久，从昨天晚上开始查资料，一直到今天早上早早来公司，看了半天 objc 的源码才找到答案，其实答案已经看过很多遍，不过由于根据网络上面各种文章的洗脑，从来没有静下心来一句一句的分析 objc 的源码，现在来看下这个很扯的想法是怎样被推翻的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 1、执行 [super studentTest]; </span><br><span class="line">// 2、会调用 lookUpImpOrForward 方法，注意：inst 就是 receiver(self)，cls 就是 superClass</span><br><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line"></span><br><span class="line">// 3、查找到方法后会调用 log_and_fill_cache，这里 receiver 就是 self，cls 为 superClass</span><br><span class="line">static void</span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line"></span><br><span class="line">// 4、调用 cache_fill 方法</span><br><span class="line">// 看下缓存的 cache_t 是在 cls 里面取出来的，而将 imp 缓存到 cache 时会调用 cache-&gt;insert</span><br><span class="line">void cache_fill(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    if (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cache_t *cache = getCache(cls);</span><br><span class="line">        cache-&gt;insert(cls, sel, imp, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 5、cache-&gt;insert 方法</span><br><span class="line">// 注意这里 set 缓存时，是放在了 cls 里面，而 receiver 的作用就是在设置缓存失败时接收消息，这就对上了，因为self 本来就是单纯的 receiver，和方法的缓存没有关系，这里方法的缓存只和 cls 有关</span><br><span class="line">void cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    // Use the cache as-is if it is less than 3/4 full</span><br><span class="line">    mask_t newOccupied = occupied() + 1;</span><br><span class="line">    unsigned oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    if (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        // Cache is read-only. Replace it.</span><br><span class="line">        if (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class="line">        reallocate(oldCapacity, capacity, /* freeOld */false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (fastpath(newOccupied &lt;= capacity / 4 * 3)) &#123;</span><br><span class="line">        // Cache is less than 3/4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;</span><br><span class="line">        if (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        reallocate(oldCapacity, capacity, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - 1;</span><br><span class="line">    mask_t begin = cache_hash(sel, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line"></span><br><span class="line">    // Scan for the first unused slot and insert there.</span><br><span class="line">    // There is guaranteed to be an empty slot because the</span><br><span class="line">    // minimum size is 4 and we resized at 3/4 full.</span><br><span class="line">    do &#123;</span><br><span class="line">        if (fastpath(b[i].sel() == 0)) &#123;</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(sel, imp, cls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b[i].sel() == sel) &#123;</span><br><span class="line">            // The entry was added to the cache by some other thread</span><br><span class="line">            // before we grabbed the cacheUpdateLock.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (fastpath((i = cache_next(i, m)) != begin));</span><br><span class="line"></span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)sel, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6、经过上面分析，在调用 [self studentTest]; 时，会先从 self.class 里面查找缓存，此时是没有的，因为 super 调用时缓存是在 superClass 里面的，所以这里会从新走消息发送的流程。</span><br></pre></td></tr></table></figure><p>扯归扯，但是这里一定要清楚这里的方法查找和缓存是针对 cls 的。</p><p>关于这个很扯问题的分析使用的是 objc 最新的代码版本（781），和之前的版本是有一些不同的，关于最新版本 objc 的优化项可以看<a href="https://mp.weixin.qq.com/s/47fSMCwhl8KwhVWk9uRoag" target="_blank" rel="noopener">这里</a>。 </p><h3 id="几个-runtime-相关的应用"><a href="#几个-runtime-相关的应用" class="headerlink" title="几个 runtime 相关的应用"></a>几个 runtime 相关的应用</h3><h4 id="常用的几个类的实现"><a href="#常用的几个类的实现" class="headerlink" title="常用的几个类的实现"></a>常用的几个类的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    return self-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return [self class]-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return self-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的有两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 1、isKindOfClass 与 isMemberOfClass 的区别</span><br><span class="line">-+ (BOOL)isKindOfClass:(Class)cls;</span><br><span class="line">-+ (BOOL)isMemberOfClass:(Class)cls;</span><br><span class="line"></span><br><span class="line">// 2、object_getClass 与 objc_getClass 的区别</span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class objc_getClass(const char *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    if (!aClassName) return Nil;</span><br><span class="line"></span><br><span class="line">    // NO unconnected, YES class handler</span><br><span class="line">    return look_up_class(aClassName, NO, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经典的-hook-实现"><a href="#经典的-hook-实现" class="headerlink" title="经典的 hook 实现"></a>经典的 hook 实现</h4><p>创建两个测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Animal</span><br><span class="line">- (void)animalTest &#123;</span><br><span class="line">    NSLog(@&quot;Animal test&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Person : Animal</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self, @selector(animalTest));</span><br><span class="line">        Method swizzlingMethod = class_getInstanceMethod(self, @selector(hook_animalTest));</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hook_animalTest &#123;</span><br><span class="line">    NSLog(@&quot;hook_animalTest test&quot;);</span><br><span class="line">    [self hook_animalTest];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // 测试 1</span><br><span class="line">        Person * p = [[Person alloc] init];</span><br><span class="line">        [p animalTest];</span><br><span class="line">      </span><br><span class="line">        // 测试 2</span><br><span class="line">        Animal * a = [[Animal alloc] init];</span><br><span class="line">        [a animalTest];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们 hook <code>animalTest</code>方法，然后运行</p><p>测试1 可以看到如下打印：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020<span class="selector-tag">-07-22</span> 14<span class="selector-pseudo">:53</span><span class="selector-pseudo">:25.496785+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[75368:2985804]</span> <span class="selector-tag">hook_animalTest</span> <span class="selector-tag">test</span></span><br><span class="line">2020<span class="selector-tag">-07-22</span> 14<span class="selector-pseudo">:53</span><span class="selector-pseudo">:25.500559+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[75368:2985804]</span> <span class="selector-tag">Animal</span> <span class="selector-tag">test</span></span><br></pre></td></tr></table></figure><p>但是到测试2 的时候程序程序挂掉了，可以看下crash信息：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2020-07-22 14:54:43.493195+0800 debug-objc[75425:2989235] hook_animalTest test</span><br><span class="line">2020-07-22 14:54:43.493866+0800 debug-objc[75425:2989235] Animal test</span><br><span class="line">2020-07-22 14:54:45.558115+0800 debug-objc[75425:2989235] hook_animalTest test</span><br><span class="line">2020-07-22 14:54:45.558828+0800 debug-objc[75425:2989235] -[Animal hook_animalTest]: unrecognized selector sent to<span class="built_in"> instance </span>0x1019183a0</span><br><span class="line">2020-07-22 14:54:45.563992+0800 debug-objc[75425:2989235] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Animal hook_animalTest]: unrecognized selector sent to<span class="built_in"> instance </span>0x1019183a0'</span><br><span class="line">*** First<span class="built_in"> throw </span>call stack:</span><br><span class="line">(</span><br><span class="line">0   CoreFoundation                      0x00007fff374ffbe7 __exceptionPreprocess + 250</span><br><span class="line">1   libobjc.A.dylib                     0x000000010038f350 objc_exception_throw + 48</span><br><span class="line">2   CoreFoundation                      0x00007fff3757ec77 -[NSObject(NSObject) __retain_OA] + 0</span><br><span class="line">3   CoreFoundation                      0x00007fff3746444b ___forwarding___ + 1427</span><br><span class="line">4   CoreFoundation                      0x00007fff37463e28 _CF_forwarding_prep_0 + 120</span><br><span class="line">5   debug-objc                          0x0000000100001bfd -[Person hook_animalTest] + 61</span><br><span class="line">6   debug-objc                          0x0000000100001c9d main + 141</span><br><span class="line">7   libdyld.dylib                       0x00007fff7147ecc9 start + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure><p>为什么会出现这种情况呢？</p><p>来分析下 <code>method_exchangeImplementations</code>其实就是交换两个方法的 IMP，由于 <code>animalTest</code>方法是在父类 Animal 里面，所以在子类 Person 要交换方法时，其实交换的是父类 Animal 里面的方法实现，这种情况对子类Person是没有影响的，完全可以达到 hook 的目的，但是对父类 Animal 就不一样了，因为这种方法直接替换了父类的实现，当父类在调用 <code>animalTest</code>时其实最终就是在调用子类的 <code>hook_animalTest</code>，因为两个方法的IMP已经交换了，然后子类里面在执行 <code>[self hook_animalTest]</code>时，此时的 self 是 Animal，意思是向 Animal 发送 <code>hook_animalTest</code>的消息，根据我们上面分析的消息发送机制可以得到这里必然会出现这个经典的crash <code>**unrecognized selector sent to instance</code>。</p><p>为了解决上面的隐藏问题，我们来看下 hook 的正确姿势：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self, @selector(animalTest));</span><br><span class="line">        Method swizzlingMethod = class_getInstanceMethod(self, @selector(hook_animalTest));</span><br><span class="line">        </span><br><span class="line">        // 如果返回 YES 则证明当前类没有这个方法，也就是说该方法可能在父类里面，所以需要将我们最终目标的 method 添加到 Person 里面，并且将 Person 的 hook_animalTest 方法与原来 method 互换。</span><br><span class="line">        // 如果返回 NO 则证明当前类有这个方法，直接交换就好</span><br><span class="line">        BOOL addResult = class_addMethod(self,</span><br><span class="line">                                         method_getName(originalMethod),</span><br><span class="line">                                         method_getImplementation(swizzlingMethod),</span><br><span class="line">                                         method_getTypeEncoding(swizzlingMethod));</span><br><span class="line">        if (addResult) &#123;</span><br><span class="line">            class_replaceMethod(self,</span><br><span class="line">                                method_getName(swizzlingMethod),</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下 objc 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">BOOL </span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return NO;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line">    // addMethod返回的 IMP == nil ? YES : NO</span><br><span class="line">    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static IMP </span><br><span class="line">addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)</span><br><span class="line">&#123;</span><br><span class="line">    IMP result = nil;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    </span><br><span class="line">    ASSERT(types);</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    method_t *m;</span><br><span class="line">  </span><br><span class="line">    // 1、如果 cls 里面有 name 对应的 method，则直接返回对应的 IMP</span><br><span class="line">    if ((m = getMethodNoSuper_nolock(cls, name))) &#123;</span><br><span class="line">        // already exists</span><br><span class="line">        if (!replace) &#123;</span><br><span class="line">            result = m-&gt;imp;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = _method_setImplementation(cls, m, imp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 2、如果没有，则将 hook 的方法添加到 cls 中</span><br><span class="line">        method_list_t *newlist;</span><br><span class="line">        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);</span><br><span class="line">        newlist-&gt;entsizeAndFlags = </span><br><span class="line">            (uint32_t)sizeof(method_t) | fixed_up_method_list;</span><br><span class="line">        newlist-&gt;count = 1;</span><br><span class="line">        newlist-&gt;first.name = name;</span><br><span class="line">        newlist-&gt;first.types = strdupIfMutable(types);</span><br><span class="line">        newlist-&gt;first.imp = imp;</span><br><span class="line"></span><br><span class="line">        prepareMethodLists(cls, &amp;newlist, 1, NO, NO);</span><br><span class="line">        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1);</span><br><span class="line">        flushCaches(cls);</span><br><span class="line"></span><br><span class="line">        result = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下 replace 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 可以看出和 class_addMethod 源码调用的是同一个方法，只不过给 addMethod 的最后一个参数：replace 传的 YES</span><br><span class="line">IMP </span><br><span class="line">class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line">    return addMethod(cls, name, imp, types ?: &quot;&quot;, YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 replace 为 YES是走的 _method_setImplementation 方法</span><br><span class="line">// 可以看出这里就是替换了 method_t 的 IMP</span><br><span class="line">static IMP </span><br><span class="line">_method_setImplementation(Class cls, method_t *m, IMP imp)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    if (!m) return nil;</span><br><span class="line">    if (!imp) return nil;</span><br><span class="line"></span><br><span class="line">    IMP old = m-&gt;imp;</span><br><span class="line">    m-&gt;imp = imp;</span><br><span class="line"></span><br><span class="line">    // Cache updates are slow if cls is nil (i.e. unknown)</span><br><span class="line">    // RR/AWZ updates are slow if cls is nil (i.e. unknown)</span><br><span class="line">    // fixme build list of classes whose Methods are known externally?</span><br><span class="line"></span><br><span class="line">    flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    adjustCustomFlagsForMethodChange(cls, m);</span><br><span class="line"></span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考神经病院系列："><a href="#参考神经病院系列：" class="headerlink" title="参考神经病院系列："></a>参考神经病院系列：</h3><ol><li><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="noopener">https://halfrost.com/objc_runtime_isa_class/</a></li><li><a href="https://halfrost.com/objc_runtime_objc_msgsend/" target="_blank" rel="noopener">https://halfrost.com/objc_runtime_objc_msgsend/</a></li><li><a href="https://halfrost.com/how_to_use_runtime/" target="_blank" rel="noopener">https://halfrost.com/how_to_use_runtime/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原计划一周一个模块，但是看到 runTime 这里持续时间有点长，底层内容很多啊，原因还是之前基础太差，菜的抠脚。。。还有整理完 block 后再想 block hook 应该怎么实现，瞎搞了一通最后找到了开源的库 &lt;code&gt;blockHook&lt;/code&gt;，看了几天的源码发现底层掌握的还是不牢，其中包括 runtime 部分，先整理完 runtime 部分然后再回头重新分析 blockHook。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下文内容是根据 &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objc4-723&lt;/a&gt; 版本分析的，目前最新版本是 &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objc4-781&lt;/a&gt;，最新版本做了一些优化，不过不影响我们理解。&lt;/p&gt;
&lt;h3 id=&quot;isa-详解&quot;&gt;&lt;a href=&quot;#isa-详解&quot; class=&quot;headerlink&quot; title=&quot;isa 详解&quot;&gt;&lt;/a&gt;isa 详解&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>block6-循环引用</title>
    <link href="http://yoursite.com/2020/07/06/block6-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/06/block6-循环引用/</id>
    <published>2020-07-06T03:15:01.000Z</published>
    <updated>2020-08-15T14:26:10.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>下面是 block 循环引用的经典图片：</p><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ggh999v50lj30pa0h6n31.jpg" alt="retaincircly.png"></p><a id="more"></a><p>看一下测试代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Animal * animal = [[Animal alloc] init];</span><br><span class="line">animal.block = ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"--- %d"</span>, animal.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"---- "</span>);</span><br></pre></td></tr></table></figure><p>分析下各个部分指针指向：</p><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ggh3caddxqj317w0t4acx.jpg" alt="retaincircle1.png"></p><p>解决循环引用的办法也很简单，这里只需要将其中的一个强指针改为弱指针就可以了，根据前面 block 捕获的知识可以得到：使用 __weak 可以解决：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;   </span><br><span class="line">__weak typeof(<span class="keyword">animal</span>) weakAnimal = <span class="keyword">animal</span>;</span><br><span class="line"><span class="keyword">animal</span>.block = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- %d"</span>, weakAnimal.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ggh3fzscb9j317g0po0vh.jpg" alt="retaincircly2.png"></p><p>还可以使用 <code>__unsafe_unretained</code> 来解决，不过和 <code>__weak</code> 的区别是：<code>__unsafe_unretained</code> 不会将释放的指针置为 nil。</p><h4 id="block-解决循环引用"><a href="#block-解决循环引用" class="headerlink" title="__block 解决循环引用"></a>__block 解决循环引用</h4><p>__block 也可以解决循环引用，不过方法有点特殊：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;   </span><br><span class="line"><span class="keyword">animal</span>.block = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- %d"</span>, <span class="keyword">animal</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析下指针的指向：</p><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ggh3nyy6hbj31hw102n2w.jpg" alt="retaincircly3.png"></p><p>现在是三角的闭环，这里可以使用如下方法来解决循环引用的问题：</p><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ggh41xn5gcj31hy0ymjx3.jpg" alt="retaincircly4.png"></p><p>具体代码如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">animal</span>.block = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- %d"</span>, <span class="keyword">animal</span>.age);</span><br><span class="line">  <span class="keyword">animal</span> = nil;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">animal</span>.block();</span><br></pre></td></tr></table></figure><p>此种方发必须调用 block，而且在调用完 block 后需要设置 __block 变量为 nil。</p><h3 id="MRC-的循环引用"><a href="#MRC-的循环引用" class="headerlink" title="MRC 的循环引用"></a>MRC 的循环引用</h3><p>1、使用 __unsafe_unretained 解决。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;   </span><br><span class="line">__unsafe_unretained <span class="keyword">Animal</span> * weakAnimal = <span class="keyword">animal</span>;</span><br><span class="line"><span class="keyword">animal</span>.block = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- %d"</span>, weakAnimal.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、使用 __block，前面讲到过在 MRC 环境下 __block 变量对 animal 一直都是弱引用，所以这里使用 __block 就能解决。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;   </span><br><span class="line"><span class="keyword">animal</span>.block = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- %d"</span>, <span class="keyword">animal</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;循环引用&quot;&gt;&lt;a href=&quot;#循环引用&quot; class=&quot;headerlink&quot; title=&quot;循环引用&quot;&gt;&lt;/a&gt;循环引用&lt;/h3&gt;&lt;p&gt;下面是 block 循环引用的经典图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/005O0Zogly1ggh999v50lj30pa0h6n31.jpg&quot; alt=&quot;retaincircly.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="block 循环引用" scheme="http://yoursite.com/tags/block-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>block5-block内存管理</title>
    <link href="http://yoursite.com/2020/07/06/block5-block%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/06/block5-block内存管理/</id>
    <published>2020-07-06T01:09:58.000Z</published>
    <updated>2020-08-15T14:26:04.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="block-内存管理"><a href="#block-内存管理" class="headerlink" title="block 内存管理"></a>block 内存管理</h3><p>测试代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSObject * object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">__block NSObject * <span class="keyword">blockObject </span>= [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">void (^<span class="keyword">block)(void) </span>= ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- %@"</span>, object)<span class="comment">;</span></span><br><span class="line">  NSLog(@<span class="string">"--- %@"</span>, <span class="keyword">blockObject);</span></span><br><span class="line"><span class="keyword">&#125;;</span></span><br><span class="line"><span class="keyword">block(); </span></span><br><span class="line">NSLog(@<span class="string">"----"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>查看 cpp 文件代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_blockObject_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockObject_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 最终被捕获到的 blockObject 变量</span></span><br><span class="line"> <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> blockObject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> object;</span><br><span class="line">  __Block_byref_blockObject_0 *blockObject; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> _object, __Block_byref_blockObject_0 *_blockObject, <span class="keyword">int</span> flags=<span class="number">0</span>) : object(_object), blockObject(_blockObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    </span><br><span class="line">    __Block_byref_blockObject_0 *blockObject = __cself-&gt;blockObject; <span class="comment">// bound by ref</span></span><br><span class="line">    <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> object = __cself-&gt;object; <span class="comment">// bound by copy</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_1x_bw2dcypj2dng06lb8qw1h8gh0000gn_T_main_3a341f_mi_0, object);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_1x_bw2dcypj2dng06lb8qw1h8gh0000gn_T_main_3a341f_mi_1, (blockObject-&gt;__forwarding-&gt;blockObject));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    </span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;object, (<span class="keyword">void</span>*)src-&gt;object, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;blockObject, (<span class="keyword">void</span>*)src-&gt;blockObject, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    </span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;object, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;blockObject, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSObject</span> * object = ((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_blockObject_0 blockObject = &#123;</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (__Block_byref_blockObject_0 *)&amp;blockObject,</span><br><span class="line">            <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_blockObject_0),</span><br><span class="line">            __Block_byref_id_object_copy_131,</span><br><span class="line">            __Block_byref_id_object_dispose_131,</span><br><span class="line">            ((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSObject</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))&#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                                   &amp;__main_block_desc_0_DATA,</span><br><span class="line">                                                   object,</span><br><span class="line">                                                   (__Block_byref_blockObject_0 *)&amp;blockObject,</span><br><span class="line">                                                   <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_1x_bw2dcypj2dng06lb8qw1h8gh0000gn_T_main_3a341f_mi_2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上面的代码可以看出，对于非 __block 修饰的 auto 变量 object 内存管理和我们 <a href="https://jueying-xiangfeng.github.io/2020/07/02/block3-%E7%B1%BB%E5%9E%8B%E3%80%81copy%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">前面</a> 讲过的 copy 过程一样：</p><p>持有：</p><blockquote><p>1、block 内部调用 desp 里面的 copy 函数<br>2、copy 函数会调用 <code>_Block_object_assign</code><br>3、<code>_Block_object_assign</code> 函数会根据 auto 变量修饰符的类型（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用或弱引用</p></blockquote><p>销毁：</p><blockquote><p>1、block 内部调用 得搜 里面的 dispose 函数<br>2、dispose 函数会调用 <code>_Block_object_dispose</code><br>3、<code>_Block_object_dispose</code> 函数会释放引用的 auto 变量</p></blockquote><p>上面就是非 __block 修饰的对象类型的 auto 变量内存管理。</p><p><br></p><p>下面来分析下 __block 修饰的对象类型的 auto 变量内存管理：<br><a href="https://jueying-xiangfeng.github.io/2020/07/03/block3-block%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">上一节</a> 讲到了 __block 的原理，可以想到 blockObject 被包装成了一个对象，而 <code>\_\_Block\_byref\_blockObject\_0</code> 里面的 <code>NSObject *\_\_strong blockObject;</code> 就是最终被捕获的变量，可以看到这里的修饰符是 __strong，根据前面讲过的 copy 原理猜想一下这里的捕获结果可能和被修饰的 auto 变量的强弱有关，来做一个测试：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^<span class="keyword">block)(void);</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span> Animal * object = [[Animal alloc] init]<span class="comment">;</span></span><br><span class="line">  __block __weak Animal * weakObject = object<span class="comment">;</span></span><br><span class="line">  <span class="keyword">block </span>= ^&#123;</span><br><span class="line">      NSLog(@<span class="string">"--- %@"</span>, weakObject)<span class="comment">;</span></span><br><span class="line">  &#125;<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果，Animal 是在作用域结束后就释放了，而此时 block 还没有被释放，看下 cpp 文件的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_weakObject_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_weakObject_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> Animal *__weak weakObject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明捕获到的确实是 __weak 的类型。</p><p>再来看一下上面 blockObject 被捕获对象初始化的地方，这里多了两个函数：<code>__Block_byref_id_object_copy_131</code>、<code>__Block_byref_id_object_dispose_131</code>，来看一下这两个函数的实现：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">__Block_byref_id_object_copy_131</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src)</span> </span>&#123;</span><br><span class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">__Block_byref_id_object_dispose_131</span><span class="params">(<span class="keyword">void</span> *src)</span> </span>&#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是不是很熟悉，跟我们前面讲 copy 的时候调用的方法是一样，看下 _Block_object_assign 函数的参数：<code>(char*)dst + 40</code>，这里的 dst 就是 <code>__Block_byref_blockObject_0</code>，那么 +40 代表什么呢？看下 <code>__Block_byref_blockObject_0</code> 的结构：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_blockObject_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;  <span class="number">8</span></span><br><span class="line">__Block_byref_blockObject_0 *__forwarding; <span class="number">8</span></span><br><span class="line"> <span class="keyword">int</span> __flags; <span class="number">4</span></span><br><span class="line"> <span class="keyword">int</span> __size; <span class="number">4</span></span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*); <span class="number">8</span></span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*); <span class="number">8</span></span><br><span class="line"> <span class="built_in">NSObject</span> *__<span class="keyword">strong</span> blockObject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>+40 的地址正好是 blockObject 的地址，所以这两个函数是用来管理 blockObject 的。</p><p>总结下 __block 修饰变量的内存管理：</p><p>持有：</p><blockquote><p>1、blockObject 被包装成 <code>__Block_byref_blockObject_0</code> 对象，<code>__Block_byref_blockObject_0</code> 对象里面持有 blockObject（blockObject 的强弱是根据自身的修饰符决定的）<br>2、<code>__main_block_impl_0</code> 持有 <code>__Block_byref_blockObject_0</code><br>3、<code>__Block_byref_blockObject_0</code> 的内存管理依赖 <code>__main_block_impl_0</code> 的 desp 的 copy 函数（<code>_Block_object_assign</code>）<br>4、blockObject 对象的内存管理依赖 <code>__Block_byref_blockObject_0</code> 的 copy 函数（<code>_Block_object_assign</code>）</p></blockquote><p>销毁：</p><blockquote><p>1、<code>__main_block_impl_0</code> 通过 desp 的 dispose 函数释放 <code>__Block_byref_blockObject_0</code>（<code>_Block_object_dispose</code>）<br>2、<code>__Block_byref_blockObject_0</code> 通过调用内部的 <code>__Block_byref_blockObject_0</code> 函数释放最终的 blockObject 对象</p></blockquote><p><br></p><h4 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h4><ul><li>当 block 在栈上时，对对象类型的 auto 变量、__block 变量不会产生强引用</li><li>当 block 被 copy 到堆上面时会通过 copy 函数来处理 (__block 变量：    _Block_object_assign((void<em>)&amp;dst-&gt;a, (void</em>)src-&gt;a, 8/<em>BLOCK_FIELD_IS_BYREF</em>/)， auto 变量：_Block_object_assign((void<em>)&amp;dst-&gt;p, (void</em>)src-&gt;p, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/))</li><li>_Block_object_assign函数会根据所指向对象的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）</li><li>当 block 从堆上移除时会调用 dispose 函数处理（__block 变量：_Block_object_dispose((void<em>)src-&gt;a, 8/</em>BLOCK_FIELD_IS_BYREF<em>/)， auto 变量：_Block_object_dispose((void</em>)src-&gt;p, 3/<em>BLOCK_FIELD_IS_OBJECT</em>/)）</li><li>_Block_object_dispose函数会自动释放指向的对象（release）</li></ul><h3 id="block-的-forwarding-指针"><a href="#block-的-forwarding-指针" class="headerlink" title="block 的 forwarding 指针"></a><strong>block 的 </strong>forwarding 指针</h3><p>上面 blockObject 的访问其实是：blockObject-&gt;__forwarding-&gt;blockObject，为什么这里要多一步 __forwarding 的操作呢，而且 __forwarding 还是指向自己的。<br>因为当栈上的 block copy 到堆上时，block 实际访问的其实是堆上的内存，如果这时再访问栈内存是不正确的，所以此时栈上的 __forwarding 指针会指向堆上面的内存，当访问 blockObject 的时候其实访问的是最终被 copy 到堆上面的内存，这样就不会出现访问错乱的问题。</p><p>可以来验证一下，使用 MRC 的环境：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * object = [[<span class="built_in">NSObject</span> alloc] init];     </span><br><span class="line">__block <span class="built_in">NSObject</span> * blockObject = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"--- %@"</span>, object);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"--- %@"</span>, blockObject);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 * blockImpl = (<span class="keyword">struct</span> __main_block_impl_0 *)block;   </span><br><span class="line">[block <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"---- %@"</span>, blockImpl);</span><br></pre></td></tr></table></figure><p>此时 block 是在栈上面，来打印下此时的地址：<code>(__Block_byref_blockObject_0 *) __forwarding = 0x00007ffeefbff468</code><br>当调用完 copy 函数之后：<code>(__Block_byref_blockObject_0 *) __forwarding = 0x000000010053af80</code>，很明显，此时的地址从栈上指向了堆空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;block-内存管理&quot;&gt;&lt;a href=&quot;#block-内存管理&quot; class=&quot;headerlink&quot; title=&quot;block 内存管理&quot;&gt;&lt;/a&gt;block 内存管理&lt;/h3&gt;&lt;p&gt;测试代码：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSObject * object = [[NSObject alloc] init]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__block NSObject * &lt;span class=&quot;keyword&quot;&gt;blockObject &lt;/span&gt;= [[NSObject alloc] init]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^&lt;span class=&quot;keyword&quot;&gt;block)(void) &lt;/span&gt;= ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;--- %@&quot;&lt;/span&gt;, object)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;--- %@&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;blockObject);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;block(); &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;----&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="block 内存管理" scheme="http://yoursite.com/tags/block-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>block4-__block原理</title>
    <link href="http://yoursite.com/2020/07/03/block3-block%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/03/block3-block原理/</id>
    <published>2020-07-03T03:25:51.000Z</published>
    <updated>2020-08-15T14:25:45.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Block-原理"><a href="#Block-原理" class="headerlink" title="__Block 原理"></a>__Block 原理</h4><p>先来测试一个经典的案例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">int</span> <span class="string">age</span> <span class="string">=</span> <span class="number">10</span><span class="string">;</span></span><br><span class="line"><span class="string">void</span> <span class="string">(^block)(void)</span> <span class="string">=</span> <span class="string">^&#123;</span></span><br><span class="line"><span class="string">NSLog(@"---</span> <span class="string">age</span> <span class="string">=</span> <span class="string">%d",</span> <span class="string">age);</span></span><br><span class="line"><span class="string">&#125;;</span> </span><br><span class="line"><span class="string">age</span> <span class="string">=</span> <span class="number">20</span><span class="string">;</span></span><br><span class="line"><span class="string">block();</span></span><br><span class="line"></span><br><span class="line"><span class="string">///</span> <span class="string">输出结果</span> <span class="meta">---</span> <span class="string">age</span> <span class="string">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>这个案例想必不会陌生，原理可以根据前面变量的捕获分析，来看下 cpp 代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  int age; <span class="comment">/// 被捕获的 age 值</span></span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int _age, int flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>age 被捕获到了 block 里面，此时 age 和被 block 捕获的 age 完全就是两个不相干的内存地址，所以修改外面的 age 对 block 里面的 age 是没有影响的，试下在 block 里面直接修改 age 的值呢？可以看到编译报错，提示不能修改 age 的值，我们来从 cpp 代码分析下为什么：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">__main_block_func_0</span><span class="params">(struct __main_block_impl_0 *__cself)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，在 block 里面访问 age，最终是在函数 <strong>main_block_func_0 访问的结构体 </strong>main_block_impl_0 里面捕获的 age，而且 age 变量是在主函数声明的，现在想要在 <strong>main_block_func_0 函数修改是不被允许的，因为这是两个函数，调用栈也不一样。<br>那么怎么才能在 block 里面修改这种 auto 类型的变量呢，答案就是使用 `</strong>block`。</p><p>把上面的 int age 变量加上修饰符 __block，再来看 cpp 代码：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="variable">__Block_byref_age_0</span> &#123;</span><br><span class="line">  void *<span class="variable">__isa</span>;</span><br><span class="line"><span class="variable">__Block_byref_age_0</span> *<span class="variable">__forwarding</span>;</span><br><span class="line"> int <span class="variable">__flags</span>;</span><br><span class="line"> int <span class="variable">__size</span>;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="variable">__main_block_impl_0</span> &#123;</span><br><span class="line">  struct <span class="variable">__block_impl</span> impl;</span><br><span class="line">  struct <span class="variable">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="variable">__Block_byref_age_0</span> *age; <span class="comment">// by ref</span></span><br><span class="line">  <span class="variable">__main_block_impl_0</span>(void *fp, struct <span class="variable">__main_block_desc_0</span> *desc, <span class="variable">__Block_byref_age_0</span> *<span class="variable">_age</span>, int flags=<span class="number">0</span>) : age(<span class="variable">_age</span>-&gt;<span class="variable">__forwarding</span>) &#123;</span><br><span class="line">    impl.isa = &amp;<span class="variable">_NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">  <span class="variable">__Block_byref_age_0</span> *age = <span class="variable">__cself</span>-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_1x_bw2dcypj2dng06lb8qw1h8gh0000gn_T_main_f5d64f_mi_0</span>, (age-&gt;<span class="variable">__forwarding</span>-&gt;age));</span><br><span class="line">        &#125;</span><br><span class="line">static void <span class="variable">__main_block_copy_0</span>(struct <span class="variable">__main_block_impl_0</span>*dst, struct <span class="variable">__main_block_impl_0</span>*src) &#123;<span class="variable">_Block_object_assign</span>((void*)&amp;dst-&gt;age, (void*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="variable">__main_block_dispose_0</span>(struct <span class="variable">__main_block_impl_0</span>*src) &#123;<span class="variable">_Block_object_dispose</span>((void*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line">static struct <span class="variable">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct <span class="variable">__main_block_impl_0</span>*, struct <span class="variable">__main_block_impl_0</span>*);</span><br><span class="line">  void (*dispose)(struct <span class="variable">__main_block_impl_0</span>*);</span><br><span class="line">&#125; <span class="variable">__main_block_desc_0_DATA</span> = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(struct <span class="variable">__main_block_impl_0</span>), <span class="variable">__main_block_copy_0</span>, <span class="variable">__main_block_dispose_0</span>&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; <span class="variable">__AtAutoreleasePool</span> <span class="variable">__autoreleasepool</span>; </span><br><span class="line"></span><br><span class="line">        <span class="variable">__attribute__</span>((<span class="variable">__blocks__</span>(byref))) <span class="variable">__Block_byref_age_0</span> age = &#123;(void*)<span class="number">0</span>,(<span class="variable">__Block_byref_age_0</span> *)&amp;age, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="variable">__Block_byref_age_0</span>), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        void (*block)(void) = ((void (*)())&amp;<span class="variable">__main_block_impl_0</span>((void *)<span class="variable">__main_block_func_0</span>, &amp;<span class="variable">__main_block_desc_0_DATA</span>, (<span class="variable">__Block_byref_age_0</span> *)&amp;age, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        (age.<span class="variable">__forwarding</span>-&gt;age) = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        ((void (*)(<span class="variable">__block_impl</span> *))((<span class="variable">__block_impl</span> *)block)-&gt;FuncPtr)((<span class="variable">__block_impl</span> *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************* 来整理一下上面的代码 *************/</span></span><br><span class="line"></span><br><span class="line">struct <span class="variable">__Block_byref_age_0</span> &#123;</span><br><span class="line">  void *<span class="variable">__isa</span>;</span><br><span class="line"><span class="variable">__Block_byref_age_0</span> *<span class="variable">__forwarding</span>;</span><br><span class="line"> int <span class="variable">__flags</span>;</span><br><span class="line"> int <span class="variable">__size</span>;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="variable">__main_block_impl_0</span> &#123;</span><br><span class="line">  struct <span class="variable">__block_impl</span> impl;</span><br><span class="line">  struct <span class="variable">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="variable">__Block_byref_age_0</span> *age; <span class="comment">// by ref</span></span><br><span class="line">  <span class="variable">__main_block_impl_0</span>(void *fp, struct <span class="variable">__main_block_desc_0</span> *desc, <span class="variable">__Block_byref_age_0</span> *<span class="variable">_age</span>, int flags=<span class="number">0</span>) : age(<span class="variable">_age</span>-&gt;<span class="variable">__forwarding</span>) &#123;</span><br><span class="line">    impl.isa = &amp;<span class="variable">_NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">  <span class="variable">__Block_byref_age_0</span> *age = <span class="variable">__cself</span>-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="variable">__main_block_copy_0</span>(struct <span class="variable">__main_block_impl_0</span>*dst, struct <span class="variable">__main_block_impl_0</span>*src) &#123;</span><br><span class="line"><span class="variable">_Block_object_assign</span>((void*)&amp;dst-&gt;age, (void*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="variable">__main_block_dispose_0</span>(struct <span class="variable">__main_block_impl_0</span>*src) &#123;</span><br><span class="line"><span class="variable">_Block_object_dispose</span>((void*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct <span class="variable">__main_block_desc_0</span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct <span class="variable">__main_block_impl_0</span>*, struct <span class="variable">__main_block_impl_0</span>*);</span><br><span class="line">  void (*dispose)(struct <span class="variable">__main_block_impl_0</span>*);</span><br><span class="line">&#125; <span class="variable">__main_block_desc_0_DATA</span> = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(struct <span class="variable">__main_block_impl_0</span>), <span class="variable">__main_block_copy_0</span>, <span class="variable">__main_block_dispose_0</span>&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; <span class="variable">__AtAutoreleasePool</span> <span class="variable">__autoreleasepool</span>; </span><br><span class="line"></span><br><span class="line">        <span class="variable">__Block_byref_age_0</span> age = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (<span class="variable">__Block_byref_age_0</span> *)&amp;age,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="variable">__Block_byref_age_0</span>), </span><br><span class="line">        <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        void (*block)(void) = &amp;<span class="variable">__main_block_impl_0</span>(</span><br><span class="line">        <span class="variable">__main_block_func_0</span>,</span><br><span class="line">         &amp;<span class="variable">__main_block_desc_0_DATA</span>,</span><br><span class="line">         &amp;age,</span><br><span class="line">         <span class="number">570425344</span>);</span><br><span class="line"></span><br><span class="line">        (age.<span class="variable">__forwarding</span>-&gt;age) = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上 <strong>block 后可以看到在 block 里面捕获的 age 的位置变成了 </strong>Block_byref_age_0，而在 <strong>Block_byref_age_0 里面有一个 int age 变量，在 main 函数里面声明的 int age 被包装成了 </strong>Block_byref_age_0 的类型，在修改 age = 20 时实际代码是通过 __Block_byref_age_0 来访问 int age 的，也就是说不管在 main 函数还是在 block 内部，修改 age 的话都是修改的包装类型里面的 age。</p><p><strong>__block 原理总结</strong></p><ul><li>__block 修饰符可以用以解决 block 内部无法修改 auto 变量值的问题</li><li>__block 不能修改全局变量、static 变量</li><li>编译器会将 __block 变量包装成一个对象</li></ul><p>具体流程如下</p><blockquote><p>1、将 <strong>block 变量包装成 </strong>Block_byref_age_0 类型的对象<br>2、访问 age 时都是访问的 <strong>Block_byref_age_0 里面的 age<br>3、访问 age 时是通过 `</strong>forwarding` 指针来访问的（初始化默认指向自己）</p></blockquote><p>再来看下如果在 block 外面打印 age 的地址，这个地址到底是 __Block_byref_age_0 age 的地址还是 int age 的地址：</p><p>为了方便查看，将 block 生成的结构体拿过来用一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *__isa;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  __<span class="title">Block_byref_age_0</span> *__<span class="title">forwarding</span>;</span></span><br><span class="line">    <span class="keyword">int</span> __flags;</span><br><span class="line">    <span class="keyword">int</span> __size;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">void</span>);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> *<span class="title">age</span>;</span> <span class="comment">// by ref</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// main 函数代码</span></span><br><span class="line">__block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"--- age = %d"</span>, age);</span><br><span class="line">  age = <span class="number">30</span>;</span><br><span class="line">  NSLog(@<span class="string">"--- age = %d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> * <span class="title">blockImpl</span> = (__<span class="title">bridge</span> <span class="title">struct</span> __<span class="title">main_block_impl_0</span> *)<span class="title">block</span>;</span></span><br><span class="line">   </span><br><span class="line">NSLog(@<span class="string">"-- age address : %p"</span>, &amp;age);</span><br></pre></td></tr></table></figure><p>在 NSLog(@”– age address : %p”, &amp;age); 处打断点，来查看一下两个 age 变量的地址：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p/x &amp;(blockImpl-&gt;age) : (__Block_byref_age_0 **) <span class="variable">$2</span> = 0x000000010064a030</span><br><span class="line"></span><br><span class="line">p/x &amp;(blockImpl-&gt;age-&gt;age) : (int *) <span class="variable">$3</span> = 0x000000010064a058</span><br><span class="line"></span><br><span class="line">NSLog 打印地址： -- age<span class="built_in"> address </span>: 0x10064a058</span><br></pre></td></tr></table></figure><p>可以看出来打印 age 的地址和生成的包装对象里面的 age 变量地址是一样的，这里可能类似 KVO，苹果不想让开发者看到实现的过程，直接屏蔽了，对于我们开发者来说，访问的其实就是 int age 本身。</p><p>最后再来看下面一个例子：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *<span class="built_in"> array </span>= [NSMutableArray array];        </span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">  [array addObject:@<span class="string">"1"</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译一下成功，执行完 block 后在打印 array，添加 object 成功，为什么呢？因为这里是使用指针 array，并不是修改指针，如果 array = nil 那么就会出现编译错误，因为要修改的话需要使用 __block 修饰符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Block-原理&quot;&gt;&lt;a href=&quot;#Block-原理&quot; class=&quot;headerlink&quot; title=&quot;__Block 原理&quot;&gt;&lt;/a&gt;__Block 原理&lt;/h4&gt;&lt;p&gt;先来测试一个经典的案例：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;(^block)(void)&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;^&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;NSLog(@&quot;---&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;%d&quot;,&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;age);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#125;;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;block();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;输出结果&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="block 原理" scheme="http://yoursite.com/tags/block-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>block3-类型、copy原理</title>
    <link href="http://yoursite.com/2020/07/02/block3-%E7%B1%BB%E5%9E%8B%E3%80%81copy%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/02/block3-类型、copy原理/</id>
    <published>2020-07-02T08:15:21.000Z</published>
    <updated>2020-08-15T14:25:20.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="block-类型"><a href="#block-类型" class="headerlink" title="block 类型"></a>block 类型</h3><p>block 的类型有3中，可以通过调用 class 方法或者 isa 指针查看具体类型，最终都是集成子 NSBlock 类型</p><ol><li>数据区：<strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）</li><li>栈区：<strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）</li><li>堆区：<strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）</li></ol><blockquote><p>block 类型的具体类型区分：</p></blockquote><table><thead><tr><th>block 类型</th><th>环境</th></tr></thead><tbody><tr><td>__NSGlobalBlock__</td><td>没有访问 auto 变量</td></tr><tr><td>__NSStackBlock__</td><td>访问了 auto 变量</td></tr><tr><td>__NSMallocBlock__</td><td>__NSStackBlock__ 调用了 copy</td></tr></tbody></table><a id="more"></a><p>看一下测试代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> (^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"block2 -- %d"</span>, age);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@  %@  %@"</span>, [block1 <span class="keyword">class</span>], [block2 <span class="keyword">class</span>], [^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block3 -- %d"</span>, age);</span><br><span class="line">        &#125; <span class="keyword">class</span>]);</span><br><span class="line">        </span><br><span class="line">ARC 环境打印结果：</span><br><span class="line">__NSGlobalBlock__  __NSMallocBlock__  __NSStackBlock__</span><br></pre></td></tr></table></figure><p>根据上面 block 的类型区分分析测试代码里面的 block2 应该是在栈空间的，可是打印出的类型却是在堆空间，这是为什么呢？我看来看下生成的 cpp 文件，三种类型的 block isa 指针类型都是：_NSConcreteStackBlock，感觉也不对。<br>到这里就不能只看静态编译的 cpp 文件代码来分析了，这里要以运行时的结果为准，就是我们上面打印的结果，因为目前的环境是 ARC 环境，ARC 帮我们做了一些处理，下面我们使用 MRC 环境在走一遍上面的打印：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// MRC 环境打印结果</span></span><br><span class="line"><span class="variable">__NSGlobalBlock__</span>  <span class="variable">__NSStackBlock__</span>  <span class="variable">__NSStackBlock__</span></span><br></pre></td></tr></table></figure></p><p>ARC 结果与我们分析的不正确是因为在 ARC 环境下会对 stack 类型的 block 做一次 copy 操作。</p><p><br></p><h3 id="block-copy"><a href="#block-copy" class="headerlink" title="block copy"></a>block copy</h3><p>不同类型的 block copy 结果</p><table><thead><tr><th>Block 类型</th><th>副本源的配置存储域</th><th>copy 效果</th></tr></thead><tbody><tr><td>__NSGlobalBlock__</td><td>程序的数据区域</td><td>什么也不做</td></tr><tr><td>__NSStackBlock__</td><td>栈</td><td>从栈赋值到堆</td></tr><tr><td>__NSMallocBlock__</td><td>堆</td><td>引用计数增加</td></tr></tbody></table><p>再来看下 ARC 环境下栈空间 block 自动 copy 的情况：</p><blockquote><p>block 作为参数返回值<br>将 block 赋值给 __strong 指针时<br>block 作为 cocoa api 中方法名含有 usingBlock 的方法参数时<br>block 作为 GCD api 的方法参数时</p></blockquote><p>栈空间的 block 是捕获了 auto 的类型变量，而 auto 类型是自动销毁类型，在作用域消失后会回收内存，如果栈空间的 block 不做 copy 的话内存访问可能会出现错乱的问题，看下测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// MRC 环境</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^Block)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Block block;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"---- block -- %d"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">       test();</span><br><span class="line">       block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上打印的结果就是随机值，因为上面 block 的内存分配在栈空间，当作用域结束后内存会回收，所以捕获的age的内存空间会回收，当我们再次访问时就会成为随机值。</p><p><br></p><h3 id="对象类型的-auto-变量"><a href="#对象类型的-auto-变量" class="headerlink" title="对象类型的 auto 变量"></a>对象类型的 auto 变量</h3><p>特殊的结论：</p><blockquote><p>当 block 内存访问了对象类型的 auto 变量时，如果 block 是在栈上，将不会对 auto 变量产生强引用。</p></blockquote><p>因为栈空间的 block 自己都可能随时销毁，这里不会对对象类型的 auto 变量产生强引用。</p><p><br></p><p>block 被拷贝到堆上面的情况：<br>看下测试代码：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1、访问 <span class="keyword">animal</span></span><br><span class="line">Block testBlock;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">animal</span>.age = 10;</span><br><span class="line"></span><br><span class="line">testBlock = ^&#123;</span><br><span class="line">NSLog(@<span class="string">"--- %d"</span>, <span class="keyword">animal</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2、wealAnimal</span><br><span class="line">Block testBlock;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">Animal</span> * <span class="keyword">animal</span> = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">animal</span>.age = 10;</span><br><span class="line">__weak <span class="keyword">Animal</span> * weakAnimal = <span class="keyword">animal</span>;</span><br><span class="line">testBlock = ^&#123;</span><br><span class="line">NSLog(@<span class="string">"--- %d"</span>, weakAnimal.age);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，第一种情况 animal 的释放是在 testBlock 销毁时才会释放，第二种是在 animal 作用域结束也就是大括号结束时就释放了，说明这两种情况下的捕获有区别，来 cpp 文件看下捕获的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、访问 animal</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 捕获的是 __strong 类型</span></span><br><span class="line">  Animal *__strong animal;</span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, Animal *__strong _animal, int flags=<span class="number">0</span>) : animal(_animal) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、wealAnimal</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 捕获的是 __weak 类型</span></span><br><span class="line">  Animal *__weak weakAnimal;</span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, Animal *__weak _weakAnimal, int flags=<span class="number">0</span>) : weakAnimal(_weakAnimal) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到在堆空间 block 对象类型的 auto 变量捕获是根据捕获的指针的强弱进行的。<br>再看 cpp 代码，生成的 __main_block_desc_0 结构有一点点的差别：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*dst, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakAnimal, (void*)src-&gt;weakAnimal, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*src) &#123;_Block_object_dispose((void*)src-&gt;weakAnimal, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*);</span><br><span class="line">  void (*dispose)(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>在生成的  __main_block_desc_0 中多了两个函数： <code>copy</code> 和 <code>dispose</code>。这两个函数就是用来管理捕获到的对象指针的。</p><p>总结调用流程：</p><p><strong>如果 block 被拷贝到堆上</strong></p><blockquote><p>1、调用 block 内部的 copy 函数<br>2、copy 函数会调用 <code>_Block_object_assign</code> 函数<br>3、<code>_Block_object_assign</code> 函数会根据 auto 变量修饰符的类型（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用或弱引用</p></blockquote><p><strong>block 从堆上面移除</strong></p><blockquote><p>1、调用 block 内部的 dispose 函数<br>2、dispose 函数会调用 <code>_Block_object_dispose</code> 函数<br>3、<code>_Block_object_dispose</code> 函数会自动释放引用的 auto 变量</p></blockquote><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy</td><td>栈上的 block 赋值到堆上</td></tr><tr><td>dispose</td><td>栈上的 block 被废弃</td></tr></tbody></table><p><br></p><h4 id="clang-命令："><a href="#clang-命令：" class="headerlink" title="clang 命令："></a>clang 命令：</h4><p>普通：<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p><p>需要编译 <code>__weak</code> 修饰符：<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 main.m</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;block-类型&quot;&gt;&lt;a href=&quot;#block-类型&quot; class=&quot;headerlink&quot; title=&quot;block 类型&quot;&gt;&lt;/a&gt;block 类型&lt;/h3&gt;&lt;p&gt;block 的类型有3中，可以通过调用 class 方法或者 isa 指针查看具体类型，最终都是集成子 NSBlock 类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据区：&lt;strong&gt;NSGlobalBlock&lt;/strong&gt; （ _NSConcreteGlobalBlock ）&lt;/li&gt;
&lt;li&gt;栈区：&lt;strong&gt;NSStackBlock&lt;/strong&gt; （ _NSConcreteStackBlock ）&lt;/li&gt;
&lt;li&gt;堆区：&lt;strong&gt;NSMallocBlock&lt;/strong&gt; （ _NSConcreteMallocBlock ）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;block 类型的具体类型区分：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;block 类型&lt;/th&gt;
&lt;th&gt;环境&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;__NSGlobalBlock__&lt;/td&gt;
&lt;td&gt;没有访问 auto 变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;__NSStackBlock__&lt;/td&gt;
&lt;td&gt;访问了 auto 变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;__NSMallocBlock__&lt;/td&gt;
&lt;td&gt;__NSStackBlock__ 调用了 copy&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="block 类型、copy" scheme="http://yoursite.com/tags/block-%E7%B1%BB%E5%9E%8B%E3%80%81copy/"/>
    
  </entry>
  
  <entry>
    <title>block2-变量的捕获</title>
    <link href="http://yoursite.com/2020/07/02/block2-%E5%8F%98%E9%87%8F%E7%9A%84%E6%8D%95%E8%8E%B7/"/>
    <id>http://yoursite.com/2020/07/02/block2-变量的捕获/</id>
    <published>2020-07-02T06:14:51.000Z</published>
    <updated>2020-08-15T14:25:10.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量的捕获"><a href="#变量的捕获" class="headerlink" title="变量的捕获"></a>变量的捕获</h3><p>为了保证 block 内部能够正常访问外部变量，block 有个变量捕获机制：</p><table><thead><tr><th>变量类型</th><th>捕获到 block 内部</th><th>访问方式</th></tr></thead><tbody><tr><td>局部变量 - auto</td><td>√</td><td>值传递</td></tr><tr><td>局部变量 - static</td><td>√</td><td>指针传递</td></tr><tr><td>全局变量</td><td>x</td><td>直接访问</td></tr></tbody></table><a id="more"></a><p>下面我们来验证一下，测试代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> a_ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa_ = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">/// 局部 auto 变量</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">/// 局部 static 变量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> sb = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"log -- %d, %d, %d, %d"</span>, a_, sa_, b, sb);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 clang 查看上面代码的编译结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a_ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa_ = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> *sb;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _b, <span class="keyword">int</span> *_sb, <span class="keyword">int</span> flags=<span class="number">0</span>) : b(_b), sb(_sb) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> b = __cself-&gt;b; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> *sb = __cself-&gt;sb; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1x_bw2dcypj2dng06lb8qw1h8gh0000gn_T_main_3ee42d_mi_0, a_, sa_, b, (*sb));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> sb = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, b, &amp;sb));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 这里是删除类型转换后的结果</span></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                                   &amp;__main_block_desc_0_DATA,</span><br><span class="line">                                                   b,</span><br><span class="line">                                                   &amp;sb));</span><br><span class="line"></span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以看到 block 结构体初始化时除了传递 FuncPtr 和 desp 两个参数外，多了 b 和 &amp;sb 参数，再看结构体 <code>__main_block_impl_0</code> 里面确实多了这两个参数，注意这里并没有和 a 相关的捕获。<br>我们在 block 里面访问了四个变量，来看 <code>__main_block_func_0</code> 函数里面是如何访问的：</p><ol><li>全局变量 a_ 和 sa_ 是直接访问的</li><li>局部变量 b 和 sb 是访问的 <code>__main_block_impl_0</code> 里面捕获的值</li><li>b 是捕获的值，sb 是 int* 类型，标识的是捕获的地址</li></ol><p>由上可以验证我们变量捕获的结论。</p><p><br></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>下面我们来做一个测试，新建一个 <code>Animal</code> 的类，声明一个 age 属性和 test 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--- %d"</span>, <span class="keyword">self</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如上测试代码，block 有捕获 self 吗？</p><p>来看下 clang 编译的结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__Animal__test_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__Animal__test_block_desc_0</span></span>* Desc;</span><br><span class="line">  Animal *<span class="keyword">const</span> __strong <span class="keyword">self</span>;</span><br><span class="line">  __Animal__test_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__Animal__test_block_desc_0</span></span> *desc, Animal *<span class="keyword">const</span> __strong _<span class="keyword">self</span>, int flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看结果是有捕获的，这里有没有疑问，self 难道不是全局变量吗？为什么这里会有捕获呢？根据 block 捕获的机制，只有 auto 变量才会捕获，这里既然有捕获 self，就证明 self 不是全局变量，下面我们看下 test 方法，验证一下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> _I_Animal_test(Animal * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="literal">void</span> (*block)(<span class="literal">void</span>) = ((<span class="literal">void</span> (*)())&amp;__Animal__test_block_impl_0((<span class="literal">void</span> *)__Animal__test_block_func_0, &amp;__Animal__test_block_desc_0_DATA, self, <span class="number">570425344</span>));</span><br><span class="line">    <span class="function"><span class="params">((<span class="literal">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block)</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">   /// 简化一下</span></span><br><span class="line"><span class="function">    <span class="title">void</span> <span class="params">(*block)(<span class="literal">void</span>)</span> = &amp;<span class="title">__Animal__test_block_impl_0</span><span class="params">(__Animal__test_block_func_0, </span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;__Animal__test_block_desc_0_DATA,</span></span></span><br><span class="line"><span class="function"><span class="params">         self,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="number">570425344</span>)</span>);</span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">    <span class="title">block</span>-&gt;</span>FuncPtr(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可以看到 <strong>Animal</strong>test_block_impl_0 在初始化时确实传递了 self 参数，再看 test 方法的两个参数：<code>self</code>、<code>_cmd</code>，是不是很熟悉，这是每个方法里面默认自带的参数，所以我们才能在方法里面使用 self 和 _cmd。<br>到这里也就明白了，self 是作为形参被捕获的，完全符合我们总结的 block 捕获机制。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>变量有没有被 block 捕获，就看变量的类型是全局变量还是局部变量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量的捕获&quot;&gt;&lt;a href=&quot;#变量的捕获&quot; class=&quot;headerlink&quot; title=&quot;变量的捕获&quot;&gt;&lt;/a&gt;变量的捕获&lt;/h3&gt;&lt;p&gt;为了保证 block 内部能够正常访问外部变量，block 有个变量捕获机制：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量类型&lt;/th&gt;
&lt;th&gt;捕获到 block 内部&lt;/th&gt;
&lt;th&gt;访问方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;局部变量 - auto&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;值传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;局部变量 - static&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;指针传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全局变量&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;直接访问&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="block 变量捕获" scheme="http://yoursite.com/tags/block-%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7/"/>
    
  </entry>
  
  <entry>
    <title>block原理探究</title>
    <link href="http://yoursite.com/2020/07/01/block%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2020/07/01/block原理探究/</id>
    <published>2020-07-01T11:36:19.000Z</published>
    <updated>2020-08-15T14:28:02.349Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><blockquote><p>最近在做业务时，可谓一步一个坑，所以回过头来补充下最基础的原理知识。<br>PS：基础好才是真的好！！！</p></blockquote><a id="more"></a><h3 id="Block-原理探究"><a href="#Block-原理探究" class="headerlink" title="Block 原理探究"></a>Block 原理探究</h3><p>将 block 相关的知识点归纳如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>block 本质</span><br><span class="line"><span class="bullet">2. </span>block 变量捕获</span><br><span class="line"><span class="bullet">3. </span>block 类型、copy 原理</span><br><span class="line"><span class="bullet">4. </span>__block 原理</span><br><span class="line"><span class="bullet">5. </span>block 内存管理</span><br><span class="line"><span class="bullet">6. </span>block 循环引用</span><br></pre></td></tr></table></figure><h3 id="Block-本质"><a href="#Block-本质" class="headerlink" title="Block 本质"></a>Block 本质</h3><p>测试代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;  </span><br><span class="line">            NSLog(@<span class="string">"block --"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请出 <code>clang</code> 命令看一下 block 被编译成了什么：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(<span class="name">int</span> argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        void (*block)(<span class="name">void</span>) = ((<span class="name">void</span> (<span class="name">*</span>)())<span class="symbol">&amp;__main_block_impl_0</span>((<span class="name">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">        ((void (*)(<span class="name">__block_impl</span> *))((__block_impl *)block)-&gt;FuncPtr)((<span class="name">__block_impl</span> *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的类型转换代码删除之后可以得到如下结构：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                           &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>可以看到调用 block() 其实就是调用 block-&gt;FuncPtr(block)。</p><p>再来看看 block 被编译后的具体结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1x_bw2dcypj2dng06lb8qw1h8gh0000gn_T_main_395a2c_mi_0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><p>由 <code>void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</code> 参照上面 block 被编译的具体结构可以看到，block 被编译成了结构体 <code>struct __main_block_impl_0</code>，而 <code>struct __main_block_impl_0</code> 由结构体 <code>struct __block_impl impl</code> 和 <code>struct __main_block_desc_0* Desc</code> 构成，再来看下 impl 的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是不是很熟悉，第一个就是 isa 指针，而最后一个 FuncPtr 指针就是我们调用 block 时所调用的：<code>block-&gt;FuncPtr(block)</code>。</p><p>由上分析可以得出 block 调用的流程：</p><ol><li>block 被编译成了结构体 <code>struct __main_block_impl_0</code></li><li>结构体初始化时传递了两个参数：<code>__main_block_func_0</code> 和 <code>&amp;__main_block_desc_0_DATA</code></li><li><code>__main_block_func_0</code> 就是我们要实现的 block 内部的代码(block 内部代码被包装到了这个函数里面)</li><li><code>&amp;__main_block_desc_0_DATA</code> 的结构里面有一个 size，看结构体的初始化赋值：sizeof(struct __main_block_impl_0) 可以得出，size 存储的就是整体 block 的大小</li><li><code>__main_block_impl_0</code> 结构体初始化时通过内部的同名构造函数将包装好的 block 实现函数 <code>__main_block_func_0</code> 指针和结构体 <code>__main_block_desc_0_DATA</code> 的地址传给了 <code>__main_block_impl_0</code> 相关的值</li><li><code>__block_impl</code> 里面的 FuncPtr 存储的就是 block 内存代码被包装的函数指针</li><li>block 调用最终就是通过 <code>void (*block)(void)</code> block 指针调用 FuncPtr 函数：<code>block-&gt;FuncPtr(block)</code></li></ol><p>通过 struct __block_impl 里面的 isa 指针可以想到 block 可能是一个 OC 对象，下面我们来验证一下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%@ - %@ - %@ - %@"</span>,</span><br><span class="line">              </span><br><span class="line">              [block class],</span><br><span class="line">              [[block superclass] class],</span><br><span class="line">              [[[block superclass] superclass] class],</span><br><span class="line">              [[[[block superclass] superclass] superclass] class]);</span><br></pre></td></tr></table></figure></p><p>输出结果</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ - __NSGlobalBlock - <span class="built_in">NSBlock</span> - <span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure><p>可以看到，block 最终的 superclass 就是继承自 NSObject，所以 block 就是一个 OC 对象。</p><h4 id="综合上得出："><a href="#综合上得出：" class="headerlink" title="综合上得出："></a>综合上得出：</h4><blockquote><p>block 就是封装了函数调用和函数调用环境的 OC 对象</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在做业务时，可谓一步一个坑，所以回过头来补充下最基础的原理知识。&lt;br&gt;PS：基础好才是真的好！！！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="block" scheme="http://yoursite.com/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>2018总结-2019计划</title>
    <link href="http://yoursite.com/2019/01/22/2018%E6%80%BB%E7%BB%93-2019%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/01/22/2018总结-2019计划/</id>
    <published>2019-01-22T07:31:50.000Z</published>
    <updated>2020-08-15T14:23:23.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018总结"><a href="#2018总结" class="headerlink" title="2018总结"></a>2018总结</h3><p>不平凡的2018，很无奈的换了四份工作，最近也在想原因，总结如下：</p><ul><li>技术不够硬</li><li>处世不够圆滑</li><li>运气不好</li></ul><p>怎么会说运气呢？个人性格是那种实干行的，有什么事都会比较负责的去完成，但是在渣浪好像刷新了我的三观，就是不合适吧，换个环境也许不是坏事。</p><p>断断续续的写了几篇技术博客，算是笔记吧，在渣浪确实是太放松了，上班开小差下班各种玩，接下来应该改变一下了，继续写博客记笔记。</p><p>坚持是2018一点都没有做下去的，跑步、看书、电子琴、博客… 一件也没有坚持下去，接下来怎么办心里没点数吗(~~)。</p><p>以前总觉得自己还小，有什么事都可以交给老爸老妈，2018之后不会再有这种想法了，发什么好多事，突然发现原来老爸老妈真的老了，有些事需要自己成熟点认真对待了。</p><p>就在刚刚写到一半接到了离职申请的通过通知，不知咋地_如释重负。来渣浪6个月勤勤恳恳的工作，最后是这样的结果有觉得有点不甘，或者说有点不值得，总之以后再没交集，此刻很想大喊一句：渣浪~一生黑~~拜拜~</p><h4 id="2018最大的收获"><a href="#2018最大的收获" class="headerlink" title="2018最大的收获"></a>2018最大的收获</h4><p>2018.5.20很特别的一天，想好各种姿势表白，没想到最后憋了半天就蹦出一句做我女朋友吧，真想说当时真是怂的一批，有点遗憾没有给她一个隆重的最起码正式的表白(当时真的很怂~很怂~怂)…</p><p>跟她的休息时间有点不太搭，只能选择周末等她下班，但是每周等的时候就是最期待的事情吧(\^\^)，每次在地铁里面的人群中看到她，真的，只有她，周围的人自动打上了马赛克，这就是喜欢吧，心跳砰砰砰，还好现在不会脸红了，嘿嘿。2018一起去了蜡像馆、小猪演唱会、迪士尼、外滩…，希望2019能跟她继续前行，此生~唯一！</p><h3 id="2019计划"><a href="#2019计划" class="headerlink" title="2019计划"></a>2019计划</h3><p>后天去阅文，重新开始，这次不再颓废，不再迷茫，以前总感觉是小孩只有自己，现在不仅有自己还有她，还有老爸老妈，以后有什么事我来扛下。</p><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><ul><li>iOS底层原理博客分析笔记</li><li>oc之外的语言学习</li><li>看完8本书(随时做笔记)</li><li>继续电子琴</li><li>跟她学画画(\(\^o\^)/~)</li></ul><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><ul><li>800公里 (去年的1000一点没跑，今年理性800，按一天5公里计算，留出偷懒时间)</li><li>两次半程马拉松（有机会完成线上的赛程）</li><li>带上她锻炼锻炼（爬山、跑步、逛公园）</li></ul><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>努力努力再努力</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>跟她出去旅游几次</li><li>催老爸老妈各种锻炼</li><li>了解一些教育相关的知识（将来开学校是要跟老板娘混的，嘿嘿，先做好功课）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2018总结&quot;&gt;&lt;a href=&quot;#2018总结&quot; class=&quot;headerlink&quot; title=&quot;2018总结&quot;&gt;&lt;/a&gt;2018总结&lt;/h3&gt;&lt;p&gt;不平凡的2018，很无奈的换了四份工作，最近也在想原因，总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术不够硬&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block原理然就-3</title>
    <link href="http://yoursite.com/2019/01/14/block%E5%8E%9F%E7%90%86%E7%84%B6%E5%B0%B1-3/"/>
    <id>http://yoursite.com/2019/01/14/block原理然就-3/</id>
    <published>2019-01-14T11:49:18.000Z</published>
    <updated>2020-08-15T14:27:37.901Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>测试</p><h3 id="block-底层数据结构"><a href="#block-底层数据结构" class="headerlink" title="block 底层数据结构"></a>block 底层数据结构</h3><p>测试代码:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"block1234"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;h3 id=&quot;block-底层数据结构&quot;&gt;&lt;a href=&quot;#block-底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;block 底层数据结构&quot;&gt;&lt;/a&gt;block 底层数据结构&lt;/h3&gt;&lt;p&gt;测试
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block原理探究-2</title>
    <link href="http://yoursite.com/2019/01/14/block%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-2/"/>
    <id>http://yoursite.com/2019/01/14/block原理探究-2/</id>
    <published>2019-01-14T11:25:32.000Z</published>
    <updated>2020-08-15T14:27:46.075Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h3><p>先来看一下测试:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"block1--- %d  %d  %d"</span>, age, height, weight);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@  %@  %@  %@"</span>, [block1 <span class="keyword">class</span>], [[block1 <span class="keyword">class</span>] superclass], [[[block1 <span class="keyword">class</span>] superclass] superclass], [[[[block1 <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br><span class="line"></span><br><span class="line">打印结果:</span><br><span class="line">__NSMallocBlock__  __NSMallocBlock  <span class="built_in">NSBlock</span>  <span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure><p>block确实是对象,继承关系:</p><blockquote><p>__NSMallocBlock__ : __NSMallocBlock : NSBlock : NSObject</p></blockquote><p>应用程序的内存分配关系为：</p><p><code>程序区</code> –&gt; <code>数据区</code>     –&gt; <code>堆区</code> –&gt; <code>栈区</code><br>———————————————————-&gt;</p><p>block类型分为三种:</p><blockquote><p>__NSGlobalBlock__     (没有访问 auto 变量 – <code>数据区</code> – copy:无操作)<br>__NSStackBlock__  (访问了 auto 变量 – <code>栈区</code> – copy:由栈复制到堆)<br>__NSMallocBlock__     (<strong>NSStackBlock</strong>调用了copy – <code>堆区</code> – copy:引用计数增加)</p></blockquote><h3 id="总结下block的copy"><a href="#总结下block的copy" class="headerlink" title="总结下block的copy"></a>总结下block的copy</h3><h4 id="1、ARC环境下"><a href="#1、ARC环境下" class="headerlink" title="1、ARC环境下"></a>1、ARC环境下</h4><p>在ARC环境下编译器会根据情况自动将栈上的block复制到堆上：</p><ul><li>block作为函数返回值</li><li>将block赋值给__strong指针</li><li>block作为Cocoa API中的方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时 </li></ul><h4 id="2、block作为属性的写法-修饰"><a href="#2、block作为属性的写法-修饰" class="headerlink" title="2、block作为属性的写法 (修饰)"></a>2、block作为属性的写法 (修饰)</h4><ul><li>ARC ：strong/copy</li><li>MRC ：copy</li></ul><h3 id="补充：对象类型的AUTO变量"><a href="#补充：对象类型的AUTO变量" class="headerlink" title="补充：对象类型的AUTO变量"></a>补充：对象类型的AUTO变量</h3><p>当block内部访问了对象类型的auto变量时：</p><p>1、 如果block在栈上，不会对auto变量产生强引用<br>2、 如果block被拷贝到堆上会调用block的copy函数</p><ul><li>copy函数调用_Block_object_assign</li><li>_Block_object_assign函数会根据auto变量的修饰符 (__strong、<strong>weak、</strong>unsafe_unretained)做出相应的操作，形成强引用或弱引用</li></ul><p>3、如果block从堆上移除会调用dispose函数</p><ul><li>dispose函数会调用_Block_object_dispose函数</li><li>_Block_object_dispose会自动释放引用的auto变量(release)</li></ul><h4 id="clang命令无法支持-weak的问题"><a href="#clang命令无法支持-weak的问题" class="headerlink" title="clang命令无法支持__weak的问题"></a>clang命令无法支持__weak的问题</h4><p>在使用clang转换OC为C++时，遇到以下问题：<br>cannot create __weak refrence in file using manual refrence</p><p>解决：支持ARC、指定运行时系统版本：<br>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</p><p>测试代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Block block;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">            __<span class="keyword">weak</span> <span class="keyword">typeof</span>(obj) weakObj = obj;</span><br><span class="line">            </span><br><span class="line">            block = [^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"---- %@"</span>, weakObj);</span><br><span class="line">            &#125; <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换C++：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  NSObject *__weak weakObj;<span class="comment">// 为捕获到的对象auto变量</span></span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, NSObject *__weak _weakObj, int flags=<span class="number">0</span>) : weakObj(_weakObj) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">  NSObject *__weak weakObj = __cself-&gt;weakObj; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_lw_6z_mkyd178q8n6w9m1vqbk9w0000gn_T_main_5e91db_mi_0, weakObj);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">static</span> void __main_block_copy_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*dst, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*src) &#123;</span><br><span class="line">    </span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;weakObj, (void*)src-&gt;weakObj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_dispose_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*src) &#123;</span><br><span class="line">    </span><br><span class="line">    _Block_object_dispose((void*)src-&gt;weakObj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 多出以下两个函数  copy、dispose</span></span><br><span class="line">  void (*copy)(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*);</span><br><span class="line">  void (*dispose)(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;block的类型&quot;&gt;&lt;a href=&quot;#block的类型&quot; class=&quot;headerlink&quot; title=&quot;block的类型&quot;&gt;&lt;/a&gt;block的类型&lt;/h3&gt;&lt;p&gt;先来看一下测试:&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block原理探究-1</title>
    <link href="http://yoursite.com/2018/07/25/block%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-1/"/>
    <id>http://yoursite.com/2018/07/25/block原理探究-1/</id>
    <published>2018-07-25T05:26:21.000Z</published>
    <updated>2020-08-15T14:27:42.132Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="block-底层数据结构"><a href="#block-底层数据结构" class="headerlink" title="block 底层数据结构"></a>block 底层数据结构</h3><p>测试代码:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"block1234"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>clang</code> 编译查看 .cpp 文件, 看block被编译成了什么:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="name">*block</span>)(<span class="name">void</span>) = ((<span class="name">void</span> (<span class="name">*</span>)())<span class="symbol">&amp;__main_block_impl_0</span>((<span class="name">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">((void (*)(<span class="name">__block_impl</span> *))((__block_impl *)block)-&gt;FuncPtr)((<span class="name">__block_impl</span> *)block);</span><br><span class="line"></span><br><span class="line">去掉上面的强制类型转换如下:</span><br><span class="line">void (*block)(<span class="name">void</span>) = <span class="symbol">&amp;__main_block_impl_0</span>(<span class="name">__main_block_func_0</span>, <span class="symbol">&amp;__main_block_desc_0_DATA</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">block-&gt;FuncPtr(<span class="name">block</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>可以看到最终block的调用就是 <code>block-&gt;FuncPtr(block);</code> , 就是调用函数</p><p>看一下block的 <code>__main_block_impl_0</code> 的结构:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line"></span><br><span class="line">           NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_y5_bv8t9pxx6jg830_kh4l6p_800000gn_T_main_fc5269_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><p>可以看到block其实就是一个结构体,再仔细看一下还有isa指针,是不是跟我们前面讲到的对象一样,所以block也是OC的对象,里面有 <code>struct __block_impl impl;</code> 和 <code>struct __main_block_desc_0* Desc;</code> 结构, 而 <code>__block_impl</code> 里面有isa指针和 <code>void *FuncPtr;</code> ,不过结构体里面有构造函数 <code>__main_block_impl_0</code> .</p><p>可以分析block在编译的时候是这样的: 根据block里面的实现先生成一个函数 <code>__main_block_func_0</code> ,然后接着生成一个 <code>__main_block_impl_0</code> 类型的结构体,将生成的函数指针和 <code>__main_block_desc_0</code> 传入并调用构造函数初始化block,这样block的结构就生成了.<br>当我们调用block时其实就是根据 <code>__block_impl</code> 查找函数指针 <code>void *FuncPtr</code> ,然后调用对应的函数的过程.</p><h3 id="block-变量的捕获"><a href="#block-变量的捕获" class="headerlink" title="block 变量的捕获"></a>block 变量的捕获</h3><p>我们来针对三种方式来测试:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.全局变量 --&gt;</span></span><br><span class="line">int weight = 10;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">&lt;!-- 2.局部变量 auto修饰(默认值) --&gt;</span></span><br><span class="line">        auto int age = 10;</span><br><span class="line">        <span class="comment">&lt;!-- 3.局部变量 static修饰 --&gt;</span></span><br><span class="line">        static int height = 10;</span><br><span class="line">        </span><br><span class="line">        void (^block1)(void) = ^&#123;</span><br><span class="line">            NSLog(@"block1--- %d  %d  %d", age, height, weight);</span><br><span class="line">        &#125;;</span><br><span class="line">        age = 20;</span><br><span class="line">        height = 20;</span><br><span class="line">        weight = 20;</span><br><span class="line">        </span><br><span class="line">        block1();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新用clang编译查看结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> weight = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> *height;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> *_height, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age), height(_height) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> *height = __cself-&gt;height; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_k8_chp8jt5d231d16l0s6w3c_gh0000gn_T_main_53994b_mi_0, age, (*height), weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> height = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height));</span><br><span class="line"></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        height = <span class="number">20</span>;</span><br><span class="line">        weight = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到block里面只捕捉到了局部变量,而且捕捉到的局部变量的类型不一样, <code>auto</code> 类型的为值传递,而 <code>static</code> 类型的为指针传递.全局变量类型的为直接访问.</p><blockquote><p>block能捕获到局部变量,不能捕获到全局变量.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;block-底层数据结构&quot;&gt;&lt;a href=&quot;#block-底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;block 底层数据结构&quot;&gt;&lt;/a&gt;block 底层数据结构&lt;/h3&gt;&lt;p&gt;测试代码:&lt;/p&gt;
&lt;f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>category原理探究-3</title>
    <link href="http://yoursite.com/2018/07/22/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-3/"/>
    <id>http://yoursite.com/2018/07/22/category原理探究-3/</id>
    <published>2018-07-22T10:40:53.000Z</published>
    <updated>2020-08-15T14:28:27.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h3><a id="more"></a><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> Animal (Eat)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString * name;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Animal (Eat)</span><br><span class="line">- (void)<span class="attribute">setName</span>:(NSString *)name &#123;</span><br><span class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">name</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">objc_getAssociatedObject</span>(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p><code>key值几种使用方法</code></p><blockquote><p>1.static void *AnimalKey = &AnimalKey;<br>2.static char AnimalKey;<br>3.使用属性名作为key;<br>4.使用get方法的@selector作为key;</p></blockquote><h3 id="关联对象的源码解读"><a href="#关联对象的源码解读" class="headerlink" title="关联对象的源码解读"></a>关联对象的源码解读</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(<span class="name">id</span> object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * retain the new value (<span class="name">if</span> any) outside the lock.</span><br><span class="line">    * 用来记录原有关联值的变量</span><br><span class="line">    */ </span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>)<span class="comment">;</span></span><br><span class="line">    id new_value = value ? acquireValue(<span class="name">value</span>, policy) : <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">    &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 全局的manager</span><br><span class="line">        */    </span><br><span class="line">        AssociationsManager manager<span class="comment">;</span></span><br><span class="line">        /**</span><br><span class="line">        * 获取 AssociationsHashMap</span><br><span class="line">        */</span><br><span class="line">        AssociationsHashMap <span class="symbol">&amp;associations</span>(<span class="name">manager</span>.associations())<span class="comment">;</span></span><br><span class="line">        /**</span><br><span class="line">        * 根据 object 获取disguised_ptr_t</span><br><span class="line">        */</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">        if (<span class="name">new_value</span>) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * break any existing association.</span><br><span class="line">            * 根据 disguised_ptr_t 找到对应的AssociationsHashMap</span><br><span class="line">            */ </span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            /**</span><br><span class="line">            * 如果找到了AssociationsHashMap 则取出里面对应的 ObjectAssociationMaps</span><br><span class="line">            * 根据 key 取出ObjectAssociationMaps 里面的ObjectAssociationMap</span><br><span class="line">            */</span><br><span class="line">            if (<span class="name">i</span> != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                /**</span><br><span class="line">                * 如果存在key对应的ObjectAssociationMap,则取出里面的数据:</span><br><span class="line">                * ObjcAssociation, 否则新建ObjcAssociation 并将ObjcAssociation以key为键存入ObjectAssociationMap中.</span><br><span class="line">                */</span><br><span class="line">                if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second<span class="comment">;</span></span><br><span class="line">                    j-&gt;second = ObjcAssociation(<span class="name">policy</span>, new_value)<span class="comment">;</span></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (<span class="name">*refs</span>)[key] = ObjcAssociation(<span class="name">policy</span>, new_value)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /**</span><br><span class="line">                * create the new association (first time).</span><br><span class="line">                * 没有找到disguised_object对应的AssociationsHashMap,则创建一个并存入</span><br><span class="line">                */</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap<span class="comment">;</span></span><br><span class="line">                associations[disguised_object] = refs<span class="comment">;</span></span><br><span class="line">                (<span class="name">*refs</span>)[key] = ObjcAssociation(<span class="name">policy</span>, new_value)<span class="comment">;</span></span><br><span class="line">                object-&gt;setHasAssociatedObjects()<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /**</span><br><span class="line">            * setting the association to nil breaks the association.</span><br><span class="line">            * 当要存入的 new_value为空时,查找对应的数据空间,如果找到用old_association记录存值的内存,并将ObjectAssociationMap里面的数据擦除</span><br><span class="line">            */ </span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">                ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">                if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second<span class="comment">;</span></span><br><span class="line">                    refs-&gt;erase(<span class="name">j</span>)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * release the old value (outside of the lock).</span><br><span class="line">    * 如果old_association.hasValue的值不为空的话则释放这块内存的数据</span><br><span class="line">    */ </span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是关联对象时数据的结构.</p><p>看一下AssociationsManager的数据结构:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AssociationsManager --&gt;</span></span><br><span class="line">class AssociationsManager &#123;</span><br><span class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- AssociationsHashMap --&gt;</span></span><br><span class="line">class AssociationsHashMap : public unordered_map<span class="tag">&lt;<span class="name">disguised_ptr_t,</span> <span class="attr">ObjectAssociationMap</span> *, <span class="attr">DisguisedPointerHash</span>, <span class="attr">DisguisedPointerEqual</span>, <span class="attr">AssociationsHashMapAllocator</span>&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ObjectAssociationMap --&gt;</span></span><br><span class="line">class ObjectAssociationMap : public std::map<span class="tag">&lt;<span class="name">void</span> *, <span class="attr">ObjcAssociation</span>, <span class="attr">ObjectPointerLess</span>, <span class="attr">ObjectAssociationMapAllocator</span>&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ObjcAssociation --&gt;</span></span><br><span class="line">class ObjcAssociation &#123;</span><br><span class="line">uintptr_t _policy;</span><br><span class="line">id _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 ObjcAssociation 里面存储的就是我们存贮相关的策略和值: _policy : _value.</p><p>void objc_setAssociateObject(id object, const void *key, id value, Objc_AssociationPolicy policy);</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>关联对象并不是存储在被关联对象本身内存中<br>关联对象存储在全局的统一的一个AssociatesManager中<br>设置关联对象为nil,就相当于是移除关联对象</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关联对象的使用&quot;&gt;&lt;a href=&quot;#关联对象的使用&quot; class=&quot;headerlink&quot; title=&quot;关联对象的使用&quot;&gt;&lt;/a&gt;关联对象的使用&lt;/h3&gt;
    
    </summary>
    
    
      <category term="category 原理" scheme="http://yoursite.com/tags/category-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>category原理探究-2</title>
    <link href="http://yoursite.com/2018/07/22/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-2/"/>
    <id>http://yoursite.com/2018/07/22/category原理探究-2/</id>
    <published>2018-07-22T04:55:46.000Z</published>
    <updated>2020-08-15T14:28:22.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="load-方法解析"><a href="#load-方法解析" class="headerlink" title="+load 方法解析"></a>+load 方法解析</h3><a id="more"></a><p>分析load方法前先来做一个小测验：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Animal -- load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 类 (-&gt;superclass animal)</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Dog -- load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat 类 (-&gt;superclass animal)</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> : <span class="title">Animal</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Cat -- load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> (<span class="title">Eat</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Eat</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Animal (Eat) -- load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> (<span class="title">Eat</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span> (<span class="title">Eat</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Dog (Eat) -- load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> (<span class="title">Eat</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span> (<span class="title">Eat</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Cat (Eat) -- load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们来运行一下程序，发现没有调用这些类但是load方法都加载了，加载的结果如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">15</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:46.369503+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[11354:638134]</span> <span class="selector-tag">Animal</span> <span class="selector-tag">--</span> <span class="selector-tag">load</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">15</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:46.369954+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[11354:638134]</span> <span class="selector-tag">Cat</span> <span class="selector-tag">--</span> <span class="selector-tag">load</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">15</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:46.369965+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[11354:638134]</span> <span class="selector-tag">Dog</span> <span class="selector-tag">--</span> <span class="selector-tag">load</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">15</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:46.369981+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[11354:638134]</span> <span class="selector-tag">Cat</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">load</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">15</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:46.369996+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[11354:638134]</span> <span class="selector-tag">Dog</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">load</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">15</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:46.370009+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[11354:638134]</span> <span class="selector-tag">Animal</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">load</span></span><br></pre></td></tr></table></figure><p><a href="https://jueying-xiangfeng.github.io/2018/07/21/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-1/" target="_blank" rel="noopener">上一篇</a>中我们讲到了category的原理，猜想这里的结果应该是只会调用分类的方法，可是为什么这里都调用了呢？还有看一下 <code>PROJECT-&gt;TARGETS-&gt;Build Phases-&gt;Compole Source</code> 的编译顺序，分类的编译顺序和调用顺序能对上，但是cat和dog都在animal的前面，为什么会是先调用的animal的load方法呢?</p><p>我们来分析一下load方法在runtime的源码，老规矩，先下载runtime源码，找到入口 <code>_objc_init</code> 的 <code>load_images</code> 方法，看一下上面的官方注解：<code>Process +load in the given images which are being mapped in by dyld.</code> ，可以发现load方法就是在这里面加载的，看源码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">load_images(<span class="keyword">const</span> <span class="built_in">char</span> *path __unused, <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span></span> *mh) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 准备 load methods</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用 load methods</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法我们拿出来单独看一下：</p><p><strong>a&gt;</strong> <code>prepare_load_methods</code>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(<span class="name">const</span> headerType *mhdr) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 加载所有类</span><br><span class="line">    */</span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(<span class="name">mhdr</span>, <span class="symbol">&amp;count</span>)<span class="comment">;</span></span><br><span class="line">    for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt; count; i++) &#123;</span></span><br><span class="line">        /**</span><br><span class="line">        * 调用 class 的 load 方法</span><br><span class="line">        */    </span><br><span class="line">        schedule_class_load(<span class="name">remapClass</span>(<span class="name">classlist</span>[i]))<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 加载所有分类</span><br><span class="line">    */</span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(<span class="name">mhdr</span>, <span class="symbol">&amp;count</span>)<span class="comment">;</span></span><br><span class="line">    for (<span class="name">i</span> = <span class="number">0</span>； i &lt; count；i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i]；</span><br><span class="line">        /**</span><br><span class="line">        * 将category中的load方法加载到loadable的列表中</span><br><span class="line">        */</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里永远都是先加载类的load方法然后在加载分类的load方法，正好解释我们上面的小测试的结果，类的load方法会先与分类被调用。再把 <code>schedule_class_load</code> 方法拿出来看一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void schedule_class_load(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断如果已经加载过load方法则直接返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensure superclass-first ordering</span></span><br><span class="line"><span class="comment">    * 这里是递归调用，优先加载 class的superclass的load方法，直到superclass为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将类的load方法加载到loadable的类表中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置此类的load方法标志位，表示已经加载过load方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用非常巧妙，用递归调用优先加载superclass的load方法，这里就明白了原来在加载类的load方法时会优先加载superclass的load方法，到这里明白了上面的小测验为什么先回调 animal 的load方法了吗？<br>再看一下 <code>add_class_to_loadable_list</code> 方法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void add_class_to_loadable_list(Class cls) &#123;</span><br><span class="line">    IMP <span class="built_in">method</span>;</span><br><span class="line">    <span class="built_in">method</span> = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">method</span>) <span class="built_in">return</span>;  // Don't bother <span class="keyword">if</span> cls has no +<span class="built_in">load</span> <span class="built_in">method</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里是将cls的method方法存放到 loadable_classes 数组中，</span></span><br><span class="line"><span class="comment">    * loadable_classes_used++ 可以看出这里是按编译时的顺序加载的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].<span class="built_in">method</span> = <span class="built_in">method</span>;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面获取 method 的时候是获取的load method 的 <code>IMP</code> 。</p><p><code>prepare_load_methods</code> 的分类加载的时候调用的就是 <code>add_class_to_loadable_list</code> 方法，所以分类的加载顺序就是按编译的顺序加载的。</p><p>到这里所有的类和分类的数据load完毕，并且加载顺序也已经确定。</p><p><strong>b&gt;</strong> <code>call_load_methods</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* call_class_loads 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * loadable_classes 就是我们上面 prepare 的加载完成的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * i ++  可以看到这里是按着顺序加载我们在 prepare 时准备的数据的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 调用 load 方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的call_load_methods方法，先加载类在加载分类，在加载类的方法 <code>call_class_loads</code> 中是按着我们在 <code>prepare_load_methods</code> 方法中准备好的数据顺序执行的，所有prepare时加载的顺序就是load调用的顺序，可以查看分类的 <code>call_category_loads</code> 方法，跟加载类的方式是一样的。</p><p>到这里类和分类的所有load方法调用完毕。</p><p><code>关于load方法总结</code>：</p><blockquote><ol><li>调用方式：根据函数的 IMP 直接调用。</li><li>调用时机：在runtime加载类、分类时调用（只调用一次）</li><li>调用顺序：”1、a&gt; 先调用类的load(优先编译的优先调用)”  “b&gt; 调用子类的load方法之前会先调用父类的load方法”  “1、a&gt; 再调用分类的load方法(优先编译的分类优先调用)”</li></ol></blockquote><h3 id="initialize-方法"><a href="#initialize-方法" class="headerlink" title="initialize 方法"></a>initialize 方法</h3><p><code>我们知道 + initialize 方法会在类的第一次接收消息时调用。</code></p><p>将上面的小测试的所有load替换为initialize，然后分别调用如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">第一次调用：</span><br><span class="line"><span class="selector-attr">[Animal class]</span>;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">16</span><span class="selector-pseudo">:52</span><span class="selector-pseudo">:15.039883+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12499:710327]</span> <span class="selector-tag">Animal</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br><span class="line"></span><br><span class="line">第二次调用：</span><br><span class="line"><span class="selector-attr">[Dog class]</span>;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">16</span><span class="selector-pseudo">:53</span><span class="selector-pseudo">:35.175441+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12534:711843]</span> <span class="selector-tag">Animal</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">16</span><span class="selector-pseudo">:53</span><span class="selector-pseudo">:35.175637+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12534:711843]</span> <span class="selector-tag">Dog</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br><span class="line"></span><br><span class="line">第三次调用：</span><br><span class="line"><span class="selector-attr">[Animal class]</span>;</span><br><span class="line"><span class="selector-attr">[Dog class]</span>;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">16</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:04.664353+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12553:712521]</span> <span class="selector-tag">Animal</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">16</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:04.664578+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12553:712521]</span> <span class="selector-tag">Dog</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br></pre></td></tr></table></figure><p>看到三次的打印结果可以推测 <code>initialize</code> 的方法的调用符合我们上一篇文章中讲解，最后加载的分类会优先类调用，并且类的方法不会再调用，第二次的调用可以推测在调用 <code>initialize</code> 时会先调用父类的 <code>initialize</code> 方法。</p><p>下面我们来把子类Dog和dog分类的 <code>initialize</code> 方式删除，再来打印看看结果：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用：</span><br><span class="line"><span class="selector-attr">[Dog class]</span>;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">17</span><span class="selector-pseudo">:08</span><span class="selector-pseudo">:29.497283+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12830:725499]</span> <span class="selector-tag">Animal</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br><span class="line"><span class="selector-tag">2018-07-22</span> <span class="selector-tag">17</span><span class="selector-pseudo">:08</span><span class="selector-pseudo">:29.497558+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[12830:725499]</span> <span class="selector-tag">Animal</span> (Eat) <span class="selector-tag">--</span> <span class="selector-tag">initialize</span></span><br></pre></td></tr></table></figure><p>为什么 Animnal 的 <code>initialize</code> 会出现两次的调用呢？ <code>initialize</code> 不是只在第一次接收消息时调用吗？</p><p>initialize 是在发送消息时调用的，所以我们找到 <code>objc_msgSend</code> 方法，最终找到 <code>class_getInstanceMethod</code> 方法，根据调用：<code>-&gt;class_getInstanceMethod -&gt; lookUpImpOrNil -&gt;lookUpImpOrForward</code> 下面我们来分析一下runtime的源码：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class <span class="keyword">cls</span>, SEL sel, id inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果cls还没有 Initialized 调用 _class_initialize</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !<span class="keyword">cls</span>-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(<span class="keyword">cls</span>, inst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _class_initialize(Class <span class="keyword">cls</span>) &#123;</span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 递归调用 cls父类的 callInitialize</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    supercls = <span class="keyword">cls</span>-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 没有 initialize 时设置 reallyInitialize为true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>-&gt;isInitialized() &amp;&amp; !<span class="keyword">cls</span>-&gt;isInitializing()) &#123;</span><br><span class="line">        <span class="keyword">cls</span>-&gt;setInitializing();</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 调用返送 SEL_initialize 消息方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        callInitialize(<span class="keyword">cls</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送 SEL_initialize 消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">void callInitialize(Class <span class="keyword">cls</span>) &#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(<span class="keyword">cls</span>, SEL_initialize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码可以看到，<code>initialize</code> 方法会先去查找父类，如果父类 <code>initialize</code> 没有调用过，会先向父类发送 <code>SEL_initialize</code> 消息，这里可以解释一下我们上面的小测试为什么 animal 的方法调用了两次，因为在 <code>_class_initialize</code> 方法中第一次由父类 animal 发送 <code>SEL_initialize</code> 消息，第二次由 dog 类发送 <code>SEL_initialize</code> 消息，而由于 dog 类没有 <code>initialize</code> 方法，所以会去调用父类 animal 的方法。</p><p><code>关于initialize方法总结</code>：</p><blockquote><ol><li>调用方式：initialize是通过objc_msgSend调用。</li><li>调用时机：initialize时类在第一次接收到消息时调用，每个类只会initialize一次（父类的initialize方法可能会被多次调用）。</li><li>调用顺序：先初始化父类 再初始化子类（可能最终调用的是父类的initialize方法）</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;load-方法解析&quot;&gt;&lt;a href=&quot;#load-方法解析&quot; class=&quot;headerlink&quot; title=&quot;+load 方法解析&quot;&gt;&lt;/a&gt;+load 方法解析&lt;/h3&gt;
    
    </summary>
    
    
      <category term="category 原理" scheme="http://yoursite.com/tags/category-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>category原理探究-1</title>
    <link href="http://yoursite.com/2018/07/21/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-1/"/>
    <id>http://yoursite.com/2018/07/21/category原理探究-1/</id>
    <published>2018-07-21T06:40:13.000Z</published>
    <updated>2020-08-15T14:28:13.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="category探究准备"><a href="#category探究准备" class="headerlink" title="category探究准备"></a>category探究准备</h3><p>先来创建我们测试需要的类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Animal类 --&gt;</span></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">- (void)animal;</span><br><span class="line">@end</span><br><span class="line"><span class="comment">&lt;!-- Animal+Eat分类 --&gt;</span></span><br><span class="line">@interface Animal (Eat) <span class="tag">&lt;<span class="name">NSCopying,</span> <span class="attr">NSCoding</span>&gt;</span></span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">- (void)eat;</span><br><span class="line">@end</span><br><span class="line"><span class="comment">&lt;!-- Animal+Play分类 --&gt;</span></span><br><span class="line">@interface Animal (Play)</span><br><span class="line">- (void)play;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>以Eat分类为例，请出 <code>clang</code> 命令：<code>clang -rewrite-objc Animal+Eat.m</code> ，生成.cpp文件。</p><a id="more"></a><h3 id="category的真面目"><a href="#category的真面目" class="headerlink" title="category的真面目"></a>category的真面目</h3><p>在.cpp文件最下面可以找到category被编译后的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 这里的name表示的是 <code>类名</code> 而不是category的名字。</li><li><code>cls</code> 要扩展的类对象，编译期间值为空，在被runtime加载时根据name对应到类对象。</li><li><code>instance_methods</code> category所有的实例方法。</li><li><code>class_methods</code> category所有的类方法。</li><li><code>protocols</code> category实现的所有协议。</li><li><code>properties</code> category的所有属性。</li></ul><p>再来看看我们的Animal+Eat被编译成了什么：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct <span class="variable">_category_t</span> <span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_Animal_</span>$<span class="variable">_Eat</span> <span class="variable">__attribute__</span> ((used, section (<span class="string">"__DATA,__objc_const"</span>))) =  &#123;</span><br><span class="line"><span class="string">"Animal"</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Animal,</span></span><br><span class="line">(const struct <span class="variable">_method_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_INSTANCE_METHODS_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(const struct <span class="variable">_protocol_list_t</span> *)&amp;<span class="variable">_OBJC_CATEGORY_PROTOCOLS_</span>$<span class="variable">_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">(const struct <span class="variable">_prop_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_PROP_LIST_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看一下结构体的名称：<code>_OBJC_$_CATEGORY_Animal_$_Eat</code>，最后面的Eat就是我们分类的名称，前面有表示CATEGORY和类名Animal，这也就是为什么同一个类的category不能重名的原因了。<br>再对应一下其他的结构，例如instance_methods：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Eat __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">"eat"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_Eat_eat&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们里面只有一个 <code>eat</code> 方法，被编译后为 <code>_I_Animal_Eat_eat</code>。</p><p>最后可以看到所有的category被放到了一个数组中，存在了 <code>__DATA</code> 段下的 <code>__objc_catlist section</code> 里了：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct <span class="variable">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class="number">1</span>] <span class="variable">__attribute__</span>((used, section (<span class="string">"__DATA, __objc_catlist,regular,no_dead_strip"</span>)))= &#123;</span><br><span class="line">&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里编译期间的工作就做完了，接下来进入runtime。</p><h3 id="runtime加载category"><a href="#runtime加载category" class="headerlink" title="runtime加载category"></a>runtime加载category</h3><p>先下载一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。</p><p>大致加载的流程如下：</p><ul><li>找到runtime的入口：<code>objc-os.mm</code> 的 <code>_objc_init</code> 方法，在library加载前由libSystem dyld调用，进行初始化操作。</li><li>调用map_images方法将文件中的image map到内存。</li><li>调用_read_images方法初始化map后的image。</li><li>找到 <code>Discover categories</code> 可以看到 <code>category_t</code> 是通过 <code>_getObjc2CategoryList</code> 方法初始化的，这个方法拿出来看看：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">   <span class="built_in"> type </span>*name(const headerType *mhdr, size_t *outCount) &#123;              \</span><br><span class="line">        return getDataSection&lt;type&gt;(mhdr, sectname, <span class="literal">nil</span>, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">   <span class="built_in"> type </span>*name(const header_info *hi, size_t *outCount) &#123;               \</span><br><span class="line">        return getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, <span class="literal">nil</span>, outCount); \</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GETSECT(_getObjc2CategoryList, category_t *, <span class="string">"__objc_catlist"</span>);</span><br></pre></td></tr></table></figure><p>看到这里有没有很熟悉，在这里加载的 <code>__objc_catlist</code> 就是在编译期间存放的数据。</p><p>来看一下加载的源码：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取出 category 数据 此处为数组代表一个类所有的分类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 按顺序取出 category_t </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  category_t *cat = catlist[i];</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * remapClass：加载category_t的class指针</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  C<span class="function"><span class="title">lass</span> cls = remapClass(cat-&gt;</span>cls);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span><span class="function"><span class="title">protocols</span>  ||  cat-&gt;</span>instanceProperties) </span><br><span class="line">  &#123;</span><br><span class="line">      addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">      <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">      remethodizeClass(cls);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span><span class="function"><span class="title">protocols</span> ||  (hasClassProperties &amp;&amp; cat-&gt;</span>_classProperties)) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>ISA(), hi);</span><br><span class="line">      <span class="function"><span class="title">if</span> (cls-&gt;</span>ISA()-&gt;isRealized()) &#123;</span><br><span class="line">      <span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>ISA());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次循环中 <code>category_t</code> 的加载 <code>addUnattachedCategoryForClass</code> 方法有两个调用，对比一下参数可以发现第二个参数不同 cls 和 cls-&gt;ISA()，再结合判断条件的 cat-&gt;instanceMethods 和 cat-&gt;classMethods，这两次的加载是将category中的信息分别加载到类和元类中，然后再调用 <code>remethodizeClass</code> 重新组织结构。接下来调用附加信息的方法 <code>attachCategories</code> ，将分类的信息附加到类中：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为元类</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="title">bool</span> isMeta = cls-&gt;</span>isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **) </span><br><span class="line">        <span class="function"><span class="title">malloc</span>(cats-&gt;</span>count * sizeof(*mlists));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 属性数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        <span class="function"><span class="title">malloc</span>(cats-&gt;</span>count * sizeof(*proplists));</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 协议数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        <span class="function"><span class="title">malloc</span>(cats-&gt;</span>count * sizeof(*protolists));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ********** 注意 ：这里是倒序循环 **********</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">auto</span>&amp; entry = cats-&gt;</span>list[i];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类的方法列表 (根据 isMeta 来判断取实例方法还是类方法)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">method_list_t</span> *mlist = entry.cat-&gt;</span>methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 将分类方法列表正序添加到 mlists</span></span><br><span class="line"><span class="comment">            */</span>        </span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类的属性列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            <span class="function"><span class="title">entry</span>.cat-&gt;</span>propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 将分类属性列表正序添加到 proplists</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类的协议列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">protocol_list_t</span> *protolist = entry.cat-&gt;</span>protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 将分类协议列表正序添加到 protolists</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 取出类的信息数据  class_rw_t</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">auto</span> rw = cls-&gt;</span><span class="keyword">data</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化方法的一些信息，比如有没有实现retain、release、allocWithZone等方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将所有分类的方法、属性、协议列表附加到类的方法、属性、协议列表中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>protocols.attachLists(protolists, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的while循环可以看到加载方法、协议、属性的时候是 <code>倒序</code> 加载的，是不是想到了什么？如果Animal类和两个分类都有一个 <code>-(void)run</code> 方法，那么最终会调用哪个里面的run方法呢？答案当然是最后加载的那个run方法，不过没有被调用的run方法并没有被 <code>覆盖</code> ，方法还在那里只是按顺序没有被调用。</p><p>最后看一下 <code>methods.attachLists</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将分类的 方法、协议、属性等信息附加到类中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line"><span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重新分配内存（大小为： oldCount addedCount 原有count和要添加的count总和）</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line"><span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重新布局</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists,</span><br><span class="line"> oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists,</span><br><span class="line"> addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新布局的时候有两个方法：</p><ul><li><code>memmove</code>：<code>void *memmove(void *__dst, const void *__src, size_t __len);</code> 可以看到是将src变量的数据移动到dst，所以最终是将 array()-&gt;lists 的数据移动到了 array()-&gt;lists + addedCount 的位置。</li><li><code>memcpy</code>：<code>void    *memcpy(void *__dst, const void *__src, size_t __n);</code> 可以看到是将src变量的数据copy到dst，所以最终是将分类中的信息 <code>addedLists</code> copy 到 array()-&gt;lists 的位置。</li></ul><p>正如我们上面说的run方法，Animal类中的run方法是被最后加载的，因为Animal类中的方法列表被移动到了分类的后面，加载的时候会先调用分类中的方法，而且可以看到Animal中的run方法确实没有被覆盖，只是调用的时候发现分类中有不会再调用Animal的run方法而已。</p><h3 id="class-extention与category"><a href="#class-extention与category" class="headerlink" title="class extention与category"></a>class extention与category</h3><p>上面知道了category，我们再来看看class extention，class extention算是一种特殊的分类（匿名分类），那么我们可以思考平时在 .m 文件的匿名分类中写的私有属性、方法等在加载的时候会不会和分类一样呢？我们来验证一下，在Animal的 .m 文件里添加属性 height 和方法 test：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> Animal ()</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) int height;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">test</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">Animal</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animal</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">test</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>用clang命令来编译 Animal：<code>clang -rewrite-objc Animal.m</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 元类结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">_class_ro_t</span></span> _OBJC_METACLASS_RO_$_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">_class_t</span></span>), <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">_class_t</span></span>), </span><br><span class="line">(unsigned int)<span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="string">"Animal"</span>,</span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">_class_ro_t</span></span> _OBJC_CLASS_RO_$_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="number">0</span>, __OFFSETOFIVAR__(<span class="class"><span class="keyword">struct</span> <span class="title">Animal</span></span>, _height), <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">Animal_IMPL</span></span>), </span><br><span class="line">(unsigned int)<span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="string">"Animal"</span>,</span><br><span class="line">(<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">_method_list_t</span></span> *)&amp;_OBJC_$_INSTANCE_METHODS_Animal,</span><br><span class="line"><span class="number">0</span>, </span><br><span class="line">(<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">_ivar_list_t</span></span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_Animal,</span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/***************************************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以看到类中方法列表 ‘_INSTANCE_METHODS_Animal’对应下面的结构</span></span><br><span class="line"><span class="comment">* animal、test、height、setHeight 方法都在类结构中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*<span class="title">_method_list_t</span></span>*/ &#123;</span><br><span class="line">unsigned int entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">unsigned int method_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_objc_method</span></span> method_list[<span class="number">4</span>];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line"><span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line"><span class="number">4</span>,</span><br><span class="line">&#123;&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"animal"</span>, <span class="string">"v16@0:8"</span>, (void *)_I_Animal_animal&#125;,</span><br><span class="line">&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"test"</span>, <span class="string">"v16@0:8"</span>, (void *)_I_Animal_test&#125;,</span><br><span class="line">&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"height"</span>, <span class="string">"i16@0:8"</span>, (void *)_I_Animal_height&#125;,</span><br><span class="line">&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"setHeight:"</span>, <span class="string">"v20@0:8i16"</span>, (void *)_I_Animal_setHeight_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译的结果如上，可以看到匿名类别的编译结果并不是 <code>category_t</code> 的类型在 runtime 时加载的，而是直接在编译期间将相关的属性方法等加载到了类中，匿名分类声明的属性方法相当于在类的 .h 文件的声明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;category探究准备&quot;&gt;&lt;a href=&quot;#category探究准备&quot; class=&quot;headerlink&quot; title=&quot;category探究准备&quot;&gt;&lt;/a&gt;category探究准备&lt;/h3&gt;&lt;p&gt;先来创建我们测试需要的类：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- Animal类 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Animal : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)animal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- Animal+Eat分类 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Animal (Eat) &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;NSCopying,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;NSCoding&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign) int age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)eat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- Animal+Play分类 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Animal (Play)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)play;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以Eat分类为例，请出 &lt;code&gt;clang&lt;/code&gt; 命令：&lt;code&gt;clang -rewrite-objc Animal+Eat.m&lt;/code&gt; ，生成.cpp文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="category 原理" scheme="http://yoursite.com/tags/category-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>KVO-KVC的原理探究 - KVC篇</title>
    <link href="http://yoursite.com/2018/07/19/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVC%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/19/KVO-KVC的原理探究-KVC篇/</id>
    <published>2018-07-19T07:12:40.000Z</published>
    <updated>2020-08-15T14:28:41.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于KVC的探究"><a href="#关于KVC的探究" class="headerlink" title="关于KVC的探究"></a>关于KVC的探究</h3><h4 id="基本介绍和使用"><a href="#基本介绍和使用" class="headerlink" title="基本介绍和使用"></a>基本介绍和使用</h4><a id="more"></a><p>KVC全称Key-Value Coding 键值编码，可以通过Key来访问某个属性，常见的API：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure></p><p>创建Person类、Animal类，添加属性如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Animal </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) NSInteger height;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) NSInteger age;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) Animal * dog;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>如上，使用KVC赋值的方式为：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> * dog = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">Person</span> * <span class="keyword">person</span> = <span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.dog = dog;</span><br><span class="line">// Key        </span><br><span class="line"><span class="comment">[person setValue:@11 forKey:@"age"]</span>;</span><br><span class="line">// KeyPath</span><br><span class="line"><span class="comment">[person setValue:@123 forKeyPath:@"dog.height"]</span>;</span><br><span class="line">        </span><br><span class="line">NSLog(@<span class="string">"---- %@ -- %@"</span>, @(<span class="keyword">person</span>.age), @(<span class="keyword">person</span>.dog.height));</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-19 23:00:48.546719+0800 KVC<span class="comment">[53839:3059207]</span> ---- 11 -- 123</span><br></pre></td></tr></table></figure></p><p>可以看到直接赋值的话两中方式都可以，但是类似上面的dog.height嵌套的方式必须通过KeyPath的方式赋值。</p><h4 id="KVC原理"><a href="#KVC原理" class="headerlink" title="KVC原理"></a>KVC原理</h4><p>进入Foundation里面查看 <code>- (void)setValue:(nullable id)value forKey:(NSString *)key;</code> 方法的注解可以了解到，<strong><code>KVC的赋值步骤</code></strong> 如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 调用setValue：forKey</span><br><span class="line">e_findSucceed=&gt;end: 传递参数，调用方法</span><br><span class="line">op1=&gt;operation: Operation1</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond_findMethod=&gt;condition: 按照 setKey：</span><br><span class="line">_setKey：</span><br><span class="line">顺序查找方法</span><br><span class="line">cond_instanceVariables=&gt;condition: 查看</span><br><span class="line">accessInstance</span><br><span class="line">VariablesDirectly</span><br><span class="line">（默认返回YES）</span><br><span class="line">方法的返回值</span><br><span class="line">cond_findIvar=&gt;condition: 按照</span><br><span class="line">_key、_isKey</span><br><span class="line">key、isKey</span><br><span class="line">顺序查找</span><br><span class="line">成员变量</span><br><span class="line">e_findIvar=&gt;end: 直接赋值</span><br><span class="line">e_exception=&gt;end: 调用</span><br><span class="line">setValue：forUndefinedKey：</span><br><span class="line">并且抛出</span><br><span class="line">NSUnKnownKeyException</span><br><span class="line"></span><br><span class="line">st-&gt;cond_findMethod</span><br><span class="line">cond_findMethod(yes, bottom)-&gt;e_findSucceed</span><br><span class="line">cond_findMethod(no, right)-&gt;cond_instanceVariables</span><br><span class="line">cond_instanceVariables(yes, bottom)-&gt;cond_findIvar</span><br><span class="line">cond_findIvar(yes, bottom)-&gt;e_findIvar</span><br><span class="line">cond_instanceVariables(no, right)-&gt;e_exception</span><br><span class="line">cond_findIvar(no, right)-&gt;e_exception</span><br></pre></td></tr></table></figure><p>以上为markdown语法，用的 MWebLite编写的，奈何blog不支持，所以直接将结果导图截图贴在下面：<br><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ftgaf779vdj315m10a7c9.jpg" alt=""></p><p>进入Foundation里面查看 <code>- (nullable id)valueForKey:(NSString *)key;</code> 方法的注解可以了解到，<strong><code>KVC的取值步骤</code></strong> 如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 调用valueForKey：</span><br><span class="line">e_findSucceed=&gt;end: 调用方法</span><br><span class="line">op1=&gt;operation: Operation1</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond_findMethod=&gt;condition: 按照 getKey</span><br><span class="line">key、isKey、</span><br><span class="line">_key、_getKey</span><br><span class="line">顺序查找方法</span><br><span class="line">cond_instanceVariables=&gt;condition: 查看</span><br><span class="line">accessInstance</span><br><span class="line">VariablesDirectly</span><br><span class="line">（默认返回YES）</span><br><span class="line">方法的返回值</span><br><span class="line">cond_findIvar=&gt;condition: 按照</span><br><span class="line">_key、_isKey</span><br><span class="line">key、isKey</span><br><span class="line">顺序查找</span><br><span class="line">成员变量</span><br><span class="line">e_findIvar=&gt;end: 直接取值</span><br><span class="line">e_exception=&gt;end: 调用</span><br><span class="line">valueForUndefinedKey：</span><br><span class="line">并且抛出</span><br><span class="line">NSUnKnownKeyException</span><br><span class="line"></span><br><span class="line">st-&gt;cond_findMethod</span><br><span class="line">cond_findMethod(yes, bottom)-&gt;e_findSucceed</span><br><span class="line">cond_findMethod(no, right)-&gt;cond_instanceVariables</span><br><span class="line">cond_instanceVariables(yes, bottom)-&gt;cond_findIvar</span><br><span class="line">cond_findIvar(yes, bottom)-&gt;e_findIvar</span><br><span class="line">cond_instanceVariables(no, right)-&gt;e_exception</span><br><span class="line">cond_findIvar(no, right)-&gt;e_exception</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ftgcd9stvjj30lx0i7mzu.jpg" alt=""></p><h4 id="接下来我们来验证一下："><a href="#接下来我们来验证一下：" class="headerlink" title="接下来我们来验证一下："></a>接下来我们来验证一下：</h4><p><strong>setValue：forKey：赋值</strong><br>使用上面的Person类，将属性全部删除，添加以下成员变量，重写两个set方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">int</span> _isAge;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> isAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--- setAge"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_setAge:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--- _setAge"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后调用KVC给age赋值，可以看打印结果：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="bullet">-07</span><span class="bullet">-20</span> <span class="number">14</span><span class="string">:41:18.679275+0800</span> <span class="string">KVC[65810:3455316]</span> <span class="meta">---</span> <span class="string">setAge</span></span><br></pre></td></tr></table></figure></p><p>此时调用的是 <code>setAge:</code> 方法，注释掉 <code>setAge:</code> 方法再次运行：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="bullet">-07</span><span class="bullet">-20</span> <span class="number">14</span><span class="string">:41:43.561291+0800</span> <span class="string">KVC[65834:3456053]</span> <span class="meta">---</span> <span class="string">_setAge</span></span><br></pre></td></tr></table></figure></p><p>当这两个方法都没有实现的时候就会调用 <code>accessInstanceVariablesDirectly</code> 方法，若返回YES，则直接给成员变量赋值，如没有或返回值为NO则会调用 <code>setValue：forUndefinedKey：</code> 并且抛出NSUnKnownKeyException异常。<br><strong>valueForKey：取值</strong><br>重写流程图中的get方法：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)getAge &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)isAge &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)_age &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)_getAge &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">NSLog(@<span class="string">"---- %@"</span>, [person <span class="string">valueForKey:</span>@<span class="string">"age"</span>]);</span><br></pre></td></tr></table></figure></p><p>如上我们可以查看当调用过的方法后就注释，直到执行完成所有的方法。我们可以控制 <code>accessInstanceVariablesDirectly</code> 方法的返回值来证明我们想要的结果。</p><h4 id="思考一下KVC能触发KVO吗？"><a href="#思考一下KVC能触发KVO吗？" class="headerlink" title="思考一下KVC能触发KVO吗？"></a>思考一下KVC能触发KVO吗？</h4><p>我们来测试一下，添加Observer类来监听并输出Log：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@implementation</span> Observer</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change <span class="string">context:</span>(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    NSLog(@<span class="string">"observeValueForKeyPath - %@"</span>, change);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line">测试代码：</span><br><span class="line">Observer * ob = [Observer <span class="keyword">new</span>];</span><br><span class="line">Person * person = [[Person alloc] init];</span><br><span class="line">[person <span class="string">addObserver:</span>ob <span class="string">forKeyPath:</span>@<span class="string">"age"</span> <span class="string">options:</span>NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew <span class="string">context:</span>nil];</span><br><span class="line">        </span><br><span class="line">[person <span class="string">setValue:</span>@<span class="number">1</span> <span class="string">forKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">[person <span class="string">removeObserver:</span>ob <span class="string">forKeyPath:</span>@<span class="string">"age"</span>];</span><br><span class="line"></span><br><span class="line">打印结果为：</span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-20</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">30.526730</span>+<span class="number">0800</span> KVC[<span class="number">67145</span>:<span class="number">3507833</span>] observeValueForKeyPath - &#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">new</span> = <span class="number">1</span>;</span><br><span class="line">    old = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到KVC确实调用了KVO，<a href="https://jueying-xiangfeng.github.io/2018/07/17/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVO%E7%AF%87/" target="_blank" rel="noopener">上一篇文章</a>中我们了解到了KVO的实现，接下来可以大概验证一下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在Person类中实现如下方法：</span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@<span class="string">"willChangeValueForKey"</span>)<span class="comment">;</span></span><br><span class="line">    [super willChangeValueForKey:key]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)<span class="keyword">didChangeValueForKey:(NSString </span>*)key &#123;</span><br><span class="line">    NSLog(@<span class="string">"didChangeValueForKey-- begin"</span>)<span class="comment">;</span></span><br><span class="line">    [super <span class="keyword">didChangeValueForKey:key];</span></span><br><span class="line"><span class="keyword"> </span>   NSLog(@<span class="string">"didChangeValueForKey-- end"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="number">2018</span>-07-20 <span class="number">15</span>:<span class="number">23</span>:<span class="number">34</span>.<span class="number">761496</span>+<span class="number">0800</span> KVC[<span class="number">67256</span>:<span class="number">3513685</span>] willChangeValueForKey</span><br><span class="line"><span class="number">2018</span>-07-20 <span class="number">15</span>:<span class="number">23</span>:<span class="number">34</span>.<span class="number">761836</span>+<span class="number">0800</span> KVC[<span class="number">67256</span>:<span class="number">3513685</span>] <span class="keyword">didChangeValueForKey-- </span><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">2018-07-20 </span><span class="number">15</span>:<span class="number">23</span>:<span class="number">34</span>.<span class="number">762151</span>+<span class="number">0800</span> KVC[<span class="number">67256</span>:<span class="number">3513685</span>] observeValueForKeyPath - &#123;</span><br><span class="line">    kind = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    new = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    old = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span>-07-20 <span class="number">15</span>:<span class="number">23</span>:<span class="number">34</span>.<span class="number">762202</span>+<span class="number">0800</span> KVC[<span class="number">67256</span>:<span class="number">3513685</span>] <span class="keyword">didChangeValueForKey-- </span>end</span><br></pre></td></tr></table></figure></p><p>可以看到打印结果跟KVO是一样的，这里可以猜测苹果大大在KVC内部的实现：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">person willChangeValueForKey:@<span class="meta-string">"age"</span></span>];</span><br><span class="line">person-&gt;_age = <span class="number">1</span>;</span><br><span class="line">[<span class="meta">person didChangeValueForKey:@<span class="meta-string">"age"</span></span>];</span><br></pre></td></tr></table></figure></p><p>KVC相当于手动调用了KVO。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于KVC的探究&quot;&gt;&lt;a href=&quot;#关于KVC的探究&quot; class=&quot;headerlink&quot; title=&quot;关于KVC的探究&quot;&gt;&lt;/a&gt;关于KVC的探究&lt;/h3&gt;&lt;h4 id=&quot;基本介绍和使用&quot;&gt;&lt;a href=&quot;#基本介绍和使用&quot; class=&quot;headerlink&quot; title=&quot;基本介绍和使用&quot;&gt;&lt;/a&gt;基本介绍和使用&lt;/h4&gt;
    
    </summary>
    
    
      <category term="KVC" scheme="http://yoursite.com/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>KVO-KVC的原理探究 - KVO篇</title>
    <link href="http://yoursite.com/2018/07/17/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVO%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/17/KVO-KVC的原理探究-KVO篇/</id>
    <published>2018-07-17T03:38:17.000Z</published>
    <updated>2020-08-15T14:28:52.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于KVO的探究"><a href="#关于KVO的探究" class="headerlink" title="关于KVO的探究"></a>关于KVO的探究</h3><h4 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h4><a id="more"></a><p>创建Person类，添加属性age：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) NSInteger age;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>在ViewController中添加属性<code>@property (nonatomic, strong) Person * person1;</code><br>实例化并添加KVO观察age属性：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.person1 = [[Person alloc] init];    </span><br><span class="line"><span class="keyword">self</span>.person1.age = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p><p>添加观察监听回调并打印：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"被监听的 %@ 的值 %@ 改变为 %@"</span>, object, keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时准备工作完成，当点击view时就会修改age的值，并且回调打印出监听的结果，这里在ViewController的touchedBegan中修改值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.age = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记得在最后移除键值观察<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [self.person1 <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"age"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上为KVO的基本使用。</p><h4 id="关于KVO的疑问和分析"><a href="#关于KVO的疑问和分析" class="headerlink" title="关于KVO的疑问和分析"></a>关于KVO的疑问和分析</h4><p>再次添加属性 <code>@property (nonatomic, strong) Person * person2;</code><br>实例化person2，在touchedBegan方法中修改值但是不添加KVO：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.person2 = [[Person alloc] init];</span><br><span class="line"><span class="keyword">self</span>.person2.age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.age = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击view可以看到打印台的日志为：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-07-17</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">26.944619</span>+<span class="number">0800</span> KVO-KVC[<span class="number">36344</span>:<span class="number">935709</span>] 被监听的 &lt;Person: <span class="number">0</span>x6<span class="number">040000106d0</span>&gt; 的值 age 改变为 &#123;</span><br><span class="line">    kind = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    new = <span class="number">11</span><span class="comment">;</span></span><br><span class="line">    old = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就可以思考都是修改age属性值，为什么person1会有回调而person2没有，修改的本质都是调用age的set方法。猜想person1和person2的set方法实现可能不一样，但是实例方法都是存放在class中的，set方法应该是一样的才对，在<code>touchesBegan处打断点</code>，然后直接查看person1和person2的isa指针，看看person1和person2的class是否一样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="selector-tag">p</span> self<span class="selector-class">.person1</span><span class="selector-class">.isa</span></span><br><span class="line">(Class) $<span class="number">0</span> = NSKVONotifying_Person</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    self.person1-&gt;isa</span><br><span class="line">(lldb) <span class="selector-tag">p</span> self<span class="selector-class">.person2</span><span class="selector-class">.isa</span></span><br><span class="line">(Class) $<span class="number">1</span> = Person</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    self.person2-&gt;isa</span><br></pre></td></tr></table></figure><p>可以看到person1的class为 <code>NSKVONotifying_Person</code> person2的class为 <code>Person</code> ，isa指针指向的就是instance的class，但是为什么person1和person2会不一样呢？我们在添加键值观察之前和之后分别打印person的类型：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加前 person1 : %@    person2 : %@"</span>, object_getClass(<span class="keyword">self</span>.person1), object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加后 person1 : %@    person2 : %@"</span>, object_getClass(<span class="keyword">self</span>.person1), object_getClass(<span class="keyword">self</span>.person2));</span><br></pre></td></tr></table></figure></p><p>打印的结果为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-07-17</span> 14<span class="selector-pseudo">:40</span><span class="selector-pseudo">:59.918227+0800</span> <span class="selector-tag">KVO-KVC</span><span class="selector-attr">[37038:970983]</span> 添加前 <span class="selector-tag">person1</span> : <span class="selector-tag">Person</span>    <span class="selector-tag">person2</span> : <span class="selector-tag">Person</span></span><br><span class="line">2018<span class="selector-tag">-07-17</span> 14<span class="selector-pseudo">:40</span><span class="selector-pseudo">:59.918636+0800</span> <span class="selector-tag">KVO-KVC</span><span class="selector-attr">[37038:970983]</span> 添加后 <span class="selector-tag">person1</span> : <span class="selector-tag">NSKVONotifying_Person</span>    <span class="selector-tag">person2</span> : <span class="selector-tag">Person</span></span><br></pre></td></tr></table></figure><p>可以看到添加键值观察之后person1的isa指针指向确实被修改了，指向了 <code>NSKVONotifying_Person</code> 类，结合上面的猜想，会不会是 <code>NSKVONotifying_Person</code> 这个类重新实现了person1的 <code>setAge:</code> ，否则怎么会和person2不一样呢？<br>我们来验证一下，通过 <code>methodForSelector:</code> 来获取 <code>setAge:</code> 的实现：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"添加前 person1 : %p    person2 : %p"</span>,</span><br><span class="line">          [self.person1 <span class="attribute">methodForSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setAge</span>:)],</span><br><span class="line">          [self.person2 <span class="attribute">methodForSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setAge</span>:)]);</span><br><span class="line">          </span><br><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"添加后 person1 : %p    person2 : %p"</span>,</span><br><span class="line">          [self.person1 <span class="attribute">methodForSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setAge</span>:)],</span><br><span class="line">          [self.person2 <span class="attribute">methodForSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setAge</span>:)]);</span><br></pre></td></tr></table></figure></p><p>打印的结果为</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-07-17</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">56.489956</span>+<span class="number">0800</span> KVO-KVC[<span class="number">37183</span>:<span class="number">978368</span>] 添加前 person1 : <span class="number">0x102493570</span>    person2 : <span class="number">0x102493570</span></span><br><span class="line"><span class="number">2018-07-17</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">56.490699</span>+<span class="number">0800</span> KVO-KVC[<span class="number">37183</span>:<span class="number">978368</span>] 添加后 person1 : <span class="number">0</span>x1027d9bf4    person2 : <span class="number">0x102493570</span></span><br></pre></td></tr></table></figure><p>我们知道instance的方法、属性、协议等信息都存在与class中，所以当person1和person2调用 <code>setAge:</code> 时得到的地址应该是一样的，但是在添加键值观察之后person1的调用方法地址改变了，为什么会改变呢？让我们来看看这两个地址的IMP，在添加键值观察之后断点，直接查看两个地址的IMP：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(lldb)</span> p <span class="comment">(IMP)</span><span class="number">0</span>x<span class="number">100</span>a<span class="number">43570</span></span><br><span class="line"><span class="comment">(IMP)</span> $<span class="number">0</span> = <span class="number">0</span>x<span class="number">0000000100</span>a<span class="number">43570</span> <span class="comment">(KVO-KVC -[Person setAge:] at Person.m:13)</span></span><br><span class="line"><span class="comment">(lldb)</span> p <span class="comment">(IMP)</span><span class="number">0</span>x<span class="number">100</span>d<span class="number">89</span>bf<span class="number">4</span></span><br><span class="line"><span class="comment">(IMP)</span> $<span class="number">1</span> = <span class="number">0</span>x<span class="number">0000000100</span>d<span class="number">89</span>bf<span class="number">4</span> <span class="comment">(Foundation _NSSetLongLongValueAndNotify)</span></span><br></pre></td></tr></table></figure><p>可以看到添加键值观察之后调用 <code>setAge:</code> 方法其实就是调用了 <code>Foundation _NSSetLongLongValueAndNotify</code> </p><p>由此可以猜测在添加键值观察之后person1的isa指向了新生成的类 <code>NSKVONotifying_Person</code> ，<code>NSKVONotifying_Person</code> 可能继承自 <code>Person</code> 类，并且重写了 <code>setAge:</code> 方法，伪代码如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">setAge:</span>(NSInteger)age &#123;</span><br><span class="line">    _NSSetLongLongValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _NSSetLongLongValueAndNotify() &#123;</span><br><span class="line">    [self <span class="string">willChangeValueForKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">    [<span class="keyword">super</span> <span class="string">setAge:</span>age];</span><br><span class="line">    [self <span class="string">didChangeValueForKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">didChangeValueForKey:</span>(NSString *)key &#123;</span><br><span class="line">    [observer <span class="string">observeValueForKeyPath:</span>key <span class="string">ofObject:</span>self <span class="string">change:</span>opetions <span class="string">context:</span>nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>综上我们的猜想KVO的实现：instance添加键值观察之后isa指针会被修改为指向 <code>NSKVONotifying_Person</code> ，<code>NSKVONotifying_Person</code> 继承自 <code>Person</code> 并且重写了 <code>setAge:</code> 方法，方法实现如上。</strong><br>在这里就有了那道最经典的面试题：<strong>如何手动实现KVO</strong>，我们只需要在修改值的时候替换 <code>_NSSetLongLongValueAndNotify</code> 方法里面的 <code>[super setAge:age];</code> 就好了。</p><h4 id="KVO内部实现窥探"><a href="#KVO内部实现窥探" class="headerlink" title="KVO内部实现窥探"></a>KVO内部实现窥探</h4><p>由上我们猜测出了KVO的实现原理，下面我们来继续探索一下KVO内部的实现。<br>我们分别在添加KVO前后打印person1和person2的class，这次我们用两种方式：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加前 person1 : %@ -- %@   person2 : %@ -- %@"</span>, [<span class="keyword">self</span>.person1 <span class="keyword">class</span>], object_getClass(<span class="keyword">self</span>.person1), [<span class="keyword">self</span>.person2 <span class="keyword">class</span>], object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加后 person1 : %@ -- %@   person2 : %@ -- %@"</span>, [<span class="keyword">self</span>.person1 <span class="keyword">class</span>], object_getClass(<span class="keyword">self</span>.person1), [<span class="keyword">self</span>.person2 <span class="keyword">class</span>], object_getClass(<span class="keyword">self</span>.person2));</span><br></pre></td></tr></table></figure></p><p>打印出的结果为：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-19 11:05:50.553735+0800 KVO-KVC<span class="comment">[40616:2560144]</span> 添加前 person1 : <span class="keyword">Person</span> -- <span class="keyword">Person</span>   person2 : <span class="keyword">Person</span> -- <span class="keyword">Person</span></span><br><span class="line">2018-07-19 11:05:52.772905+0800 KVO-KVC<span class="comment">[40616:2560144]</span> 添加后 person1 : <span class="keyword">Person</span> -- NSKVONotifying_Person   person2 : <span class="keyword">Person</span> -- <span class="keyword">Person</span></span><br></pre></td></tr></table></figure></p><p>可以看到我们通常用来获取class的方法在添加前后结果都是 <code>Person</code> ，通过runtime API获取到的class不相同，怎么回事呢？我们先来看一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。<br>我们来分析一下源码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>方法：</span></span><br><span class="line"></span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime object_getClass方法：</span><br><span class="line"></span><br><span class="line">Class object_getClass(id obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>class</code> 的类方法或者实例方法最终返回的都是class的self，而 <code>object_getClass</code> 方法返回的是obj的isa指针，所以通过 <code>object_getClass</code> 获取的才是当前obj的真正class，所以在添加KVO之后person1的isa指针确确实实是被修改了。<br>我们再来看一下捕捉到的 <code>NSKVONotifying_Person</code> 到底是个什么鬼？<br>先来看一下 <code>NSKVONotifying_Person</code> 的meta-class：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"元类对象 person : %@    person1 : %@"</span>,</span><br><span class="line">          <span class="keyword">object</span><span class="number">_</span>getClass(<span class="keyword">object</span><span class="number">_</span>getClass(self.person<span class="number">1</span>)),</span><br><span class="line">          <span class="keyword">object</span><span class="number">_</span>getClass(<span class="keyword">object</span><span class="number">_</span>getClass(self.person<span class="number">2</span>)));</span><br><span class="line">打印结果：</span><br><span class="line"><span class="number">2018</span>-<span class="number">07</span>-<span class="number">19</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">30.2</span><span class="number">10378</span>+<span class="number">0800</span> KVO-KVC[<span class="number">41164</span>:<span class="number">2599225</span>] 元类对象 person : NSKVONotifying<span class="number">_P</span>erson    person<span class="number">1</span> : Person</span><br></pre></td></tr></table></figure></p><p><code>NSKVONotifying_Person</code> 的meta-class为 <code>NSKVONotifying_Person</code>。</p><p>在添加KVO之后打住断点，借用 <strong><a href="https://github.com/delebedev/DLIntrospection" target="_blank" rel="noopener">DLIntrospection</a></strong> 再来查看一下此时class里面方法都有什么：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[self.person1 class] instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x60400023daa0&gt;(</span><br><span class="line">-<span class="ruby"> (void)<span class="symbol">setAge:</span>(q)arg<span class="number">0</span> ,</span></span><br><span class="line"><span class="ruby">- (q)age</span></span><br><span class="line"><span class="ruby">)</span></span><br><span class="line"><span class="ruby">(lldb) po [object_getClass(<span class="keyword">self</span>.person1) instanceMethods]</span></span><br><span class="line"><span class="ruby">&lt;__NSArrayI <span class="number">0x60400025fb30</span>&gt;(</span></span><br><span class="line"><span class="ruby">- (void)<span class="symbol">setAge:</span>(q)arg<span class="number">0</span> ,</span></span><br><span class="line"><span class="ruby">- (<span class="class"><span class="keyword">class</span>)<span class="title">class</span>,</span></span></span><br><span class="line"><span class="ruby">- (void)dealloc,</span></span><br><span class="line"><span class="ruby">- (BOOL)_isKVOA</span></span><br><span class="line"><span class="ruby">)</span></span><br></pre></td></tr></table></figure></p><p>结果可以看到 <code>NSKVONotifying_Person</code> 重写了 <code>setAge:</code> 方法，并且还有其他的三个方法，可证上面的猜想确实没错，<code>NSKVONotifying_Person</code>重写了 <code>setAge:</code> 方法，但是还有一个上面的猜想没有验证，那就是 <code>NSKVONotifying_Person</code> 的superClass到底是谁？<br>类似isa指针的方式，我们断点直接打印：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self<span class="selector-class">.person1</span><span class="selector-class">.superclass</span></span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">(lldb) po self<span class="selector-class">.person2</span><span class="selector-class">.superclass</span></span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure></p><p>咦~~~ 等等，这跟我们猜测的不一样啊，怎么superclass都是NSObject呢？那我们的猜测是不是都错了？<br>为了看看superClass里面到底是什么下面我们请出 <code>clang</code> 大神：<br><code>clang -rewrite-objc Person.m</code><br>可以看出编译完成后Person类被编译成了这样：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person_IMPL</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> NSObject_IVARS;</span></span><br><span class="line"><span class="class">    NSInteger _age;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure></p><p>结合runtime源码分析，Class为 <code>typedef struct objc_class *Class;</code> 类型的结构体，再看下结构体里面的结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;</span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面确实有superclass，仿照runtime的结构我们自己来创建一个类似的结构体：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct XFPerson_IMPL &#123;</span><br><span class="line">    Class isa<span class="comment">;</span></span><br><span class="line">    Class super_Class<span class="comment">;</span></span><br><span class="line">    NSInteger _age<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>用我们自己创建的结构体来接收 <code>NSKVONotifying_Person</code> ，看看他的superclass到底是什么类型：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XFPerson_IMPL</span></span> * xfPerson1 = (__bridge <span class="class"><span class="keyword">struct</span> <span class="title">XFPerson_IMPL</span></span> *)(object_getClass(<span class="keyword">self</span>.person1));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XFPerson_IMPL</span></span> * xfPerson2 = (__bridge <span class="class"><span class="keyword">struct</span> <span class="title">XFPerson_IMPL</span></span> *)(object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">"person1--- %@"</span>, xfPerson1-&gt;super_Class);</span><br><span class="line">NSLog(@<span class="string">"person2--- %@"</span>, xfPerson2-&gt;super_Class);</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="number">2018</span>-<span class="number">07</span>-<span class="number">19</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">38.855549</span>+<span class="number">0800</span> KVO-KVC[<span class="number">43578</span>:<span class="number">2717734</span>] person1--- Person</span><br><span class="line"><span class="number">2018</span>-<span class="number">07</span>-<span class="number">19</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">38.855658</span>+<span class="number">0800</span> KVO-KVC[<span class="number">43578</span>:<span class="number">2717734</span>] person2--- NSObject</span><br></pre></td></tr></table></figure></p><p>结果可见是符合我们的猜想的，<code>NSKVONotifying_Person</code> 确实是Person的子类，但是为什么上面直接打印instance的superclass却都是NSObject呢？<br>回过头来看一下上面我们找到的 <code>NSKVONotifying_Person</code> 除了 <code>setAge:</code> 还有三个方法，其中就有class方法，我们已经知道runtime的class的实现，class返回的就是self，而通过 <code>[self.person1 class]</code> 得到的是 <code>Person</code> ，这就证明了 <code>NSKVONotifying_Person</code> 重写了class方法，并且返回的是 <code>Person</code> 类，通过源码查看runtime的superclass方法的实现：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="class"><span class="keyword">Class</span>)<span class="title">superclass</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="class"><span class="keyword">Class</span>)<span class="title">superclass</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">self</span> <span class="class"><span class="keyword">class</span>]-&gt;<span class="title">superclass</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是先通过class方法找到class，然后在根据class找到superclass，所以前面直接通过 <code>self.person1.superclass</code> 找到的是 <code>Person</code>，因为此时的class方法返回已经被修改了。</p><p>苹果大大可能是因为整个事件中 <code>NSKVONotifying_Person</code> 是个人畜无害的东西，对于开发者使用KVO是可以不用知道的，所以用这种方式来骗骗开发者，真不容易，还好最近看 <strong>白夜追凶</strong> 看的整个人都比较有耐心了就是要找到真相，哈(不)哈(要)哈(脸)😁。<br>再看看看其他的两个方法，<code>dealloc</code> 方法可能就是做一些销毁现场的事情，毕竟中间动态创建了 <code>NSKVONotifying_Person</code> ，不用了一定要销毁，而   <code>_isKVOA</code> 返回的一定是 YES ，表示当前确实是在用KVO，到此关于KVO的黑科技已经探究明白了，好了，打完收工，接着去看两集 <strong>白夜追凶</strong>， 哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于KVO的探究&quot;&gt;&lt;a href=&quot;#关于KVO的探究&quot; class=&quot;headerlink&quot; title=&quot;关于KVO的探究&quot;&gt;&lt;/a&gt;关于KVO的探究&lt;/h3&gt;&lt;h4 id=&quot;KVO的基本使用&quot;&gt;&lt;a href=&quot;#KVO的基本使用&quot; class=&quot;headerlink&quot; title=&quot;KVO的基本使用&quot;&gt;&lt;/a&gt;KVO的基本使用&lt;/h4&gt;
    
    </summary>
    
    
      <category term="KVO" scheme="http://yoursite.com/tags/KVO/"/>
    
  </entry>
  
</feed>
