<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北漂猿的入门到放弃</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-19T07:12:56.924Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Key</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KVO-KVC的原理探究 - KVC篇</title>
    <link href="http://yoursite.com/2018/07/19/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVC%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/19/KVO-KVC的原理探究-KVC篇/</id>
    <published>2018-07-19T07:12:40.000Z</published>
    <updated>2018-07-19T07:12:56.924Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO-KVC的原理探究 - KVO篇</title>
    <link href="http://yoursite.com/2018/07/17/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVO%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/17/KVO-KVC的原理探究-KVO篇/</id>
    <published>2018-07-17T03:38:17.000Z</published>
    <updated>2018-07-19T07:27:14.800Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="关于KVO的探究"><a href="#关于KVO的探究" class="headerlink" title="关于KVO的探究"></a>关于KVO的探究</h3><h4 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h4><p>创建Person类，添加属性age：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在ViewController中添加属性<code>@property (nonatomic, strong) Person * person1;</code><br>实例化并添加KVO观察age属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.person1 = [[Person alloc] init];    </span><br><span class="line">self.person1.age = 1;</span><br><span class="line"></span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br></pre></td></tr></table></figure></p><p>添加观察监听回调并打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;被监听的 %@ 的值 %@ 改变为 %@&quot;, object, keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时准备工作完成，当点击view时就会修改age的值，并且回调打印出监听的结果，这里在ViewController的touchedBegan中修改值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.person.age = 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记得在最后移除键值观察<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上为KVO的基本使用。</p><h4 id="关于KVO的疑问和分析"><a href="#关于KVO的疑问和分析" class="headerlink" title="关于KVO的疑问和分析"></a>关于KVO的疑问和分析</h4><p>再次添加属性 <code>@property (nonatomic, strong) Person * person2;</code><br>实例化person2，在touchedBegan方法中修改值但是不添加KVO：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.person2 = [[Person alloc] init];</span><br><span class="line">self.person2.age = 2;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.person.age = 11;</span><br><span class="line">    self.person1.age = 22;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击view可以看到打印台的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-07-17 14:09:26.944619+0800 KVO-KVC[36344:935709] 被监听的 &lt;Person: 0x6040000106d0&gt; 的值 age 改变为 &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 11;</span><br><span class="line">    old = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就可以思考都是修改age属性值，为什么person1会有回调而person2没有，修改的本质都是调用age的set方法。猜想person1和person2的set方法实现可能不一样，但是实例方法都是存放在class中的，set方法应该是一样的才对，在<code>touchesBegan处打断点</code>，然后直接查看person1和person2的isa指针，看看person1和person2的class是否一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p self.person1.isa</span><br><span class="line">(Class) $0 = NSKVONotifying_Person</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    self.person1-&gt;isa</span><br><span class="line">(lldb) p self.person2.isa</span><br><span class="line">(Class) $1 = Person</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    self.person2-&gt;isa</span><br></pre></td></tr></table></figure><p>可以看到person1的class为 <code>NSKVONotifying_Person</code> person2的class为 <code>Person</code> ，isa指针指向的就是instance的class，但是为什么person1和person2会不一样呢？我们在添加键值观察之前和之后分别打印person的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;添加前 person1 : %@    person2 : %@&quot;, object_getClass(self.person1), object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;添加后 person1 : %@    person2 : %@&quot;, object_getClass(self.person1), object_getClass(self.person2));</span><br></pre></td></tr></table></figure></p><p>打印的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-17 14:40:59.918227+0800 KVO-KVC[37038:970983] 添加前 person1 : Person    person2 : Person</span><br><span class="line">2018-07-17 14:40:59.918636+0800 KVO-KVC[37038:970983] 添加后 person1 : NSKVONotifying_Person    person2 : Person</span><br></pre></td></tr></table></figure><p>可以看到添加键值观察之后person1的isa指针指向确实被修改了，指向了 <code>NSKVONotifying_Person</code> 类，结合上面的猜想，会不会是 <code>NSKVONotifying_Person</code> 这个类重新实现了person1的 <code>setAge:</code> ，否则怎么会和person2不一样呢？<br>我们来验证一下，通过 <code>methodForSelector:</code> 来获取 <code>setAge:</code> 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;添加前 person1 : %p    person2 : %p&quot;,</span><br><span class="line">          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">          [self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">          </span><br><span class="line">NSLog(@&quot;添加后 person1 : %p    person2 : %p&quot;,</span><br><span class="line">          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">          [self.person2 methodForSelector:@selector(setAge:)]);</span><br></pre></td></tr></table></figure></p><p>打印的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-17 14:46:56.489956+0800 KVO-KVC[37183:978368] 添加前 person1 : 0x102493570    person2 : 0x102493570</span><br><span class="line">2018-07-17 14:46:56.490699+0800 KVO-KVC[37183:978368] 添加后 person1 : 0x1027d9bf4    person2 : 0x102493570</span><br></pre></td></tr></table></figure><p>我们知道instance的方法、属性、协议等信息都存在与class中，所以当person1和person2调用 <code>setAge:</code> 时得到的地址应该是一样的，但是在添加键值观察之后person1的调用方法地址改变了，为什么会改变呢？让我们来看看这两个地址的IMP，在添加键值观察之后断点，直接查看两个地址的IMP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (IMP)0x100a43570</span><br><span class="line">(IMP) $0 = 0x0000000100a43570 (KVO-KVC -[Person setAge:] at Person.m:13)</span><br><span class="line">(lldb) p (IMP)0x100d89bf4</span><br><span class="line">(IMP) $1 = 0x0000000100d89bf4 (Foundation _NSSetLongLongValueAndNotify)</span><br></pre></td></tr></table></figure><p>可以看到添加键值观察之后调用 <code>setAge:</code> 方法其实就是调用了 <code>Foundation _NSSetLongLongValueAndNotify</code> </p><p>由此可以猜测在添加键值观察之后person1的isa指向了新生成的类 <code>NSKVONotifying_Person</code> ，<code>NSKVONotifying_Person</code> 可能继承自 <code>Person</code> 类，并且重写了 <code>setAge:</code> 方法，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age &#123;</span><br><span class="line">    _NSSetLongLongValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetLongLongValueAndNotify() &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    [super setAge:age];</span><br><span class="line">    [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    [observer observeValueForKeyPath:key ofObject:self change:opetions context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>综上我们的猜想KVO的实现：instance添加键值观察之后isa指针会被修改为指向 <code>NSKVONotifying_Person</code> ，<code>NSKVONotifying_Person</code> 继承自 <code>Person</code> 并且重写了 <code>setAge:</code> 方法，方法实现如上。</strong><br>在这里就有了那道最经典的面试题：<strong>如何手动实现KVO</strong>，我们只需要在修改值的时候替换 <code>_NSSetLongLongValueAndNotify</code> 方法里面的 <code>[super setAge:age];</code> 就好了。</p><h4 id="KVO内部实现窥探"><a href="#KVO内部实现窥探" class="headerlink" title="KVO内部实现窥探"></a>KVO内部实现窥探</h4><p>由上我们猜测出了KVO的实现原理，下面我们来继续探索一下KVO内部的实现。<br>我们分别在添加KVO前后打印person1和person2的class，这次我们用两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;添加前 person1 : %@ -- %@   person2 : %@ -- %@&quot;, [self.person1 class], object_getClass(self.person1), [self.person2 class], object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;添加后 person1 : %@ -- %@   person2 : %@ -- %@&quot;, [self.person1 class], object_getClass(self.person1), [self.person2 class], object_getClass(self.person2));</span><br></pre></td></tr></table></figure></p><p>打印出的结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-19 11:05:50.553735+0800 KVO-KVC[40616:2560144] 添加前 person1 : Person -- Person   person2 : Person -- Person</span><br><span class="line">2018-07-19 11:05:52.772905+0800 KVO-KVC[40616:2560144] 添加后 person1 : Person -- NSKVONotifying_Person   person2 : Person -- Person</span><br></pre></td></tr></table></figure></p><p>可以看到我们通常用来获取class的方法在添加前后结果都是 <code>Person</code> ，通过runtime API获取到的class不相同，怎么回事呢？我们先来看一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。<br>我们来分析一下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class方法：</span><br><span class="line"></span><br><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime object_getClass方法：</span><br><span class="line"></span><br><span class="line">Class object_getClass(id obj) &#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>class</code> 的类方法或者实例方法最终返回的都是class的self，而 <code>object_getClass</code> 方法返回的是obj的isa指针，所以通过 <code>object_getClass</code> 获取的才是当前obj的真正class，所以在添加KVO之后person1的isa指针确确实实是被修改了。<br>我们再来看一下捕捉到的 <code>NSKVONotifying_Person</code> 到底是个什么鬼？<br>先来看一下 <code>NSKVONotifying_Person</code> 的meta-class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;元类对象 person : %@    person1 : %@&quot;,</span><br><span class="line">          object_getClass(object_getClass(self.person1)),</span><br><span class="line">          object_getClass(object_getClass(self.person2)));</span><br><span class="line">打印结果：</span><br><span class="line">2018-07-19 11:39:30.210378+0800 KVO-KVC[41164:2599225] 元类对象 person : NSKVONotifying_Person    person1 : Person</span><br></pre></td></tr></table></figure></p><p><code>NSKVONotifying_Person</code> 的meta-class为 <code>NSKVONotifying_Person</code>。</p><p>在添加KVO之后打住断点，借用 <strong><a href="https://github.com/delebedev/DLIntrospection" target="_blank" rel="noopener">DLIntrospection</a></strong> 再来查看一下此时class里面方法都有什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[self.person1 class] instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x60400023daa0&gt;(</span><br><span class="line">- (void)setAge:(q)arg0 ,</span><br><span class="line">- (q)age</span><br><span class="line">)</span><br><span class="line">(lldb) po [object_getClass(self.person1) instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x60400025fb30&gt;(</span><br><span class="line">- (void)setAge:(q)arg0 ,</span><br><span class="line">- (class)class,</span><br><span class="line">- (void)dealloc,</span><br><span class="line">- (BOOL)_isKVOA</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>结果可以看到 <code>NSKVONotifying_Person</code> 重写了 <code>setAge:</code> 方法，并且还有其他的三个方法，可证上面的猜想确实没错，<code>NSKVONotifying_Person</code>重写了 <code>setAge:</code> 方法，但是还有一个上面的猜想没有验证，那就是 <code>NSKVONotifying_Person</code> 的superClass到底是谁？<br>类似isa指针的方式，我们断点直接打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self.person1.superclass</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">(lldb) po self.person2.superclass</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure></p><p>咦~~~ 等等，这跟我们猜测的不一样啊，怎么superclass都是NSObject呢？那我们的猜测是不是都错了？<br>为了看看superClass里面到底是什么下面我们请出 <code>clang</code> 大神：<br><code>clang -rewrite-objc Person.m</code><br>可以看出编译完成后Person类被编译成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">    struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">    NSInteger _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>结合runtime源码分析，Class为 <code>typedef struct objc_class *Class;</code> 类型的结构体，再看下结构体里面的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面确实有superclass，仿照runtime的结构我们自己来创建一个类似的结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct XFPerson_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_Class;</span><br><span class="line">    NSInteger _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>用我们自己创建的结构体来接收 <code>NSKVONotifying_Person</code> ，看看他的superclass到底是什么类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct XFPerson_IMPL * xfPerson1 = (__bridge struct XFPerson_IMPL *)(object_getClass(self.person1));</span><br><span class="line">struct XFPerson_IMPL * xfPerson2 = (__bridge struct XFPerson_IMPL *)(object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;person1--- %@&quot;, xfPerson1-&gt;super_Class);</span><br><span class="line">NSLog(@&quot;person2--- %@&quot;, xfPerson2-&gt;super_Class);</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-19 14:05:38.855549+0800 KVO-KVC[43578:2717734] person1--- Person</span><br><span class="line">2018-07-19 14:05:38.855658+0800 KVO-KVC[43578:2717734] person2--- NSObject</span><br></pre></td></tr></table></figure></p><p>结果可见是符合我们的猜想的，<code>NSKVONotifying_Person</code> 确实是Person的子类，但是为什么上面直接打印instance的superclass却都是NSObject呢？<br>回过头来看一下上面我们找到的 <code>NSKVONotifying_Person</code> 除了 <code>setAge:</code> 还有三个方法，其中就有class方法，我们已经知道runtime的class的实现，class返回的就是self，而通过 <code>[self.person1 class]</code> 得到的是 <code>Person</code> ，这就证明了 <code>NSKVONotifying_Person</code> 重写了class方法，并且返回的是 <code>Person</code> 类，通过源码查看runtime的superclass方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    return self-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return [self class]-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是先通过class方法找到class，然后在根据class找到superclass，所以前面直接通过 <code>self.person1.superclass</code> 找到的是 <code>Person</code>，因为此时的class方法返回已经被修改了。</p><p>苹果大大可能是因为整个事件中 <code>NSKVONotifying_Person</code> 是个人畜无害的东西，对于开发者使用KVO是可以不用知道的，所以用这种方式来骗骗开发者，真不容易，还好最近看 <strong>白夜追凶</strong> 看的整个人都比较有耐心了就是要找到真相，哈(不)哈(要)哈(脸)😁。<br>再看看看其他的两个方法，<code>dealloc</code> 方法可能就是做一些销毁现场的事情，毕竟中间动态创建了 <code>NSKVONotifying_Person</code> ，不用了一定要销毁，而   <code>_isKVOA</code> 返回的一定是 YES ，表示当前确实是在用KVO，到此关于KVO的黑科技已经探究明白了，好了，打完收工，接着去看两集 <strong>白夜追凶</strong>， 哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;关于KVO的探究&quot;&gt;&lt;a href=&quot;#关于KVO的探究&quot; class=&quot;headerlink&quot; title=&quot;关于KVO的探究&quot;&gt;&lt;/a&gt;关于KVO的探究&lt;/h3&gt;&lt;h4 id=&quot;KVO的基本使用&quot;&gt;&lt;a href=&quot;#KVO
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习链接</title>
    <link href="http://yoursite.com/2018/06/06/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/06/06/学习链接/</id>
    <published>2018-06-06T02:06:16.000Z</published>
    <updated>2018-07-19T07:37:48.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git第三方链接"><a href="#Git第三方链接" class="headerlink" title="Git第三方链接"></a>Git第三方链接</h2><ul><li>打印一个类的方法、属性、协议等常用调试方法神器 <a href="https://github.com/delebedev/DLIntrospection" target="_blank" rel="noopener">NSObject+DLIntrospection</a></li><li>修改全局导航栏返回按钮样式: <a href="https://github.com/Mervin1024/MERNavigationBackItem" target="_blank" rel="noopener">MERNavigationBackItem</a></li><li>iOS常用的<a href="https://github.com/Tim9Liu9/TimLiu-iOS" target="_blank" rel="noopener">库、插件、知名博客</a></li><li><a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a></li><li>互联网公司技术架构: <a href="https://github.com/davideuler/architecture.of.internet-product" target="_blank" rel="noopener">链接</a></li><li><a href="https://github.com/BlocksKit/BlocksKit" target="_blank" rel="noopener">BlocksKit</a></li><li>一个拖拽的控制器: <a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="noopener">这里</a></li><li>中文版 Apple 官方 Swift 教程<a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="noopener">《The Swift Programming Language》</a></li><li>单元测试框架: <a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">fastlane</a>、<a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a></li><li>runTime编译源码: <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">链接</a></li></ul><ul><li>hexo主题: <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next</a>、<a href="https://github.com/pinggod/hexo-theme-apollo/blob/master/doc%2Fdoc-zh.md" target="_blank" rel="noopener">Apollo</a>、<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题集</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git第三方链接&quot;&gt;&lt;a href=&quot;#Git第三方链接&quot; class=&quot;headerlink&quot; title=&quot;Git第三方链接&quot;&gt;&lt;/a&gt;Git第三方链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;打印一个类的方法、属性、协议等常用调试方法神器 &lt;a href=&quot;https:/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建</title>
    <link href="http://yoursite.com/2018/06/01/hexo%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/06/01/hexo搭建/</id>
    <published>2018-06-01T01:24:54.000Z</published>
    <updated>2018-07-19T07:38:52.092Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="1-创建Git仓库"><a href="#1-创建Git仓库" class="headerlink" title="1. 创建Git仓库"></a>1. 创建Git仓库</h3><p>在git上创建存放blog的仓库，名称为 username.github.io<br><br></p><h3 id="2-安装homebrew"><a href="#2-安装homebrew" class="headerlink" title="2. 安装homebrew"></a>2. 安装homebrew</h3><p>执行以下命令安装homebrew：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>还可以查看homebrew <a href="https://brew.sh/" target="_blank" rel="noopener">官方文档</a></p><p>安装Node.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew link node</span><br><span class="line">$ brew uninstall node</span><br><span class="line">$ brew install node</span><br></pre></td></tr></table></figure></p><p>安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><h3 id="3-创建博客"><a href="#3-创建博客" class="headerlink" title="3. 创建博客"></a>3. 创建博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init username.github.io</span><br></pre></td></tr></table></figure><p>安装主题 (经典的next主题)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd username.github.io</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>博客和主题的配置都可以在对应文件下名为”_config.yml”的文件中修改.</p><p>新建博客文章可以在目录: /source/_posts下直接创建:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new blogname</span><br></pre></td></tr></table></figure></p><p>开启测试服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>测试就可以访问: <a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a>来查看本地博客内容了</p><p>将hexo部署到Git上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p><p>在文章中加入 <code>&lt;!-- more --&gt;</code>表示首页 <strong>阅读全文</strong> 的分界线</p><p>参考链接:</p><ol><li><a href="https://juejin.im/post/5ac8db4d6fb9a028d5675c13" target="_blank" rel="noopener">mac环境下搭建hexo+github pages+next个人博客</a></li><li><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">5分钟 搭建免费个人博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h2 id=&quot;开始搭建&quot;&gt;&lt;a href=&quot;#开始搭建&quot; class=&quot;headerlink&quot; title=&quot;开始搭建&quot;&gt;&lt;/a&gt;开始搭建&lt;/h2&gt;&lt;h3 id=&quot;1-创建Git仓库&quot;&gt;&lt;a href=&quot;#1-创建Git仓库&quot; class=
      
    
    </summary>
    
    
  </entry>
  
</feed>
