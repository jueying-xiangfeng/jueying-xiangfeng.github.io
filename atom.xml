<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白夜追凶</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T08:11:24.387Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Key</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018总结-2019计划</title>
    <link href="http://yoursite.com/2019/01/22/2018%E6%80%BB%E7%BB%93-2019%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/01/22/2018总结-2019计划/</id>
    <published>2019-01-22T07:31:50.000Z</published>
    <updated>2019-04-08T08:11:24.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018总结"><a href="#2018总结" class="headerlink" title="2018总结"></a>2018总结</h3><p>不平凡的2018，很无奈的换了四份工作，最近也在想原因，总结如下：</p><ul><li>技术不够硬</li><li>处世不够圆滑</li><li>运气不好</li></ul><p>怎么会说运气呢？个人性格是那种实干行的，有什么事都会比较负责的去完成，但是在渣浪好像刷新了我的三观，就是不合适吧，换个环境也许不是坏事。</p><p>断断续续的写了几篇技术博客，算是笔记吧，在渣浪确实是太放松了，上班开小差下班各种玩，接下来应该改变一下了，继续写博客记笔记。</p><p>坚持是2018一点都没有做下去的，跑步、看书、电子琴、博客… 一件也没有坚持下去，接下来怎么办心里没点数吗(~~)。</p><p>以前总觉得自己还小，有什么事都可以交给老爸老妈，2018之后不会再有这种想法了，发什么好多事，突然发现原来老爸老妈真的老了，有些事需要自己成熟点认真对待了。</p><p>就在刚刚写到一半接到了离职申请的通过通知，不知咋地_如释重负。来渣浪6个月勤勤恳恳的工作，最后是这样的结果有觉得有点不甘，或者说有点不值得，总之以后再没交集，此刻很想大喊一句：渣浪~一生黑~~拜拜~</p><h4 id="2018最大的收获"><a href="#2018最大的收获" class="headerlink" title="2018最大的收获"></a>2018最大的收获</h4><p>2018.5.20很特别的一天，想好各种姿势表白，没想到最后憋了半天就蹦出一句做我女朋友吧，真想说当时真是怂的一批，有点遗憾没有给她一个隆重的最起码正式的表白(当时真的很怂~很怂~怂)…</p><p>跟她的休息时间有点不太搭，只能选择周末等她下班，但是每周等的时候就是最期待的事情吧(\^\^)，每次在地铁里面的人群中看到她，真的，只有她，周围的人自动打上了马赛克，这就是喜欢吧，心跳砰砰砰，还好现在不会脸红了，嘿嘿。2018一起去了蜡像馆、小猪演唱会、迪士尼、外滩…，希望2019能跟她继续前行，此生~唯一！</p><h3 id="2019计划"><a href="#2019计划" class="headerlink" title="2019计划"></a>2019计划</h3><p>后天去阅文，重新开始，这次不再颓废，不再迷茫，以前总感觉是小孩只有自己，现在不仅有自己还有她，还有老爸老妈，以后有什么事我来扛下。</p><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><ul><li>iOS底层原理博客分析笔记</li><li>oc之外的语言学习</li><li>看完8本书(随时做笔记)</li><li>继续电子琴</li><li>跟她学画画(\(\^o\^)/~)</li></ul><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><ul><li>800公里 (去年的1000一点没跑，今年理性800，按一天5公里计算，留出偷懒时间)</li><li>两次半程马拉松（有机会完成线上的赛程）</li><li>带上她锻炼锻炼（爬山、跑步、逛公园）</li></ul><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>努力努力再努力</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>跟她出去旅游几次</li><li>催老爸老妈各种锻炼</li><li>了解一些教育相关的知识（将来开学校是要跟老板娘混的，嘿嘿，先做好功课）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2018总结&quot;&gt;&lt;a href=&quot;#2018总结&quot; class=&quot;headerlink&quot; title=&quot;2018总结&quot;&gt;&lt;/a&gt;2018总结&lt;/h3&gt;&lt;p&gt;不平凡的2018，很无奈的换了四份工作，最近也在想原因，总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术不够硬&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block原理然就-3</title>
    <link href="http://yoursite.com/2019/01/14/block%E5%8E%9F%E7%90%86%E7%84%B6%E5%B0%B1-3/"/>
    <id>http://yoursite.com/2019/01/14/block原理然就-3/</id>
    <published>2019-01-14T11:49:18.000Z</published>
    <updated>2019-04-08T08:11:24.388Z</updated>
    
    <content type="html"><![CDATA[<p>测试</p><h3 id="block-底层数据结构"><a href="#block-底层数据结构" class="headerlink" title="block 底层数据结构"></a>block 底层数据结构</h3><p>测试代码:</p><p><code>`</code><br>int main(int argc, const char * argv[]) {<br>    @autoreleasepool {<br>        void (^block)(void) = ^{<br>            NSLog(@”block1234”);<br>        };<br>        block();<br>    }<br>    return 0;<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试&lt;/p&gt;
&lt;h3 id=&quot;block-底层数据结构&quot;&gt;&lt;a href=&quot;#block-底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;block 底层数据结构&quot;&gt;&lt;/a&gt;block 底层数据结构&lt;/h3&gt;&lt;p&gt;测试代码:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;`
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block原理探究-2</title>
    <link href="http://yoursite.com/2019/01/14/block%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-2/"/>
    <id>http://yoursite.com/2019/01/14/block原理探究-2/</id>
    <published>2019-01-14T11:25:32.000Z</published>
    <updated>2019-04-08T08:11:24.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h3><p>先来看一下测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">NSLog(@&quot;block1--- %d  %d  %d&quot;, age, height, weight);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">NSLog(@&quot;%@  %@  %@  %@&quot;, [block1 class], [[block1 class] superclass], [[[block1 class] superclass] superclass], [[[[block1 class] superclass] superclass] superclass]);</span><br><span class="line"></span><br><span class="line">打印结果:</span><br><span class="line">__NSMallocBlock__  __NSMallocBlock  NSBlock  NSObject</span><br></pre></td></tr></table></figure><p>block确实是对象,继承关系:</p><blockquote><p>__NSMallocBlock__ : __NSMallocBlock : NSBlock : NSObject</p></blockquote><p>应用程序的内存分配关系为：</p><p><code>程序区</code> –&gt; <code>数据区</code>     –&gt; <code>堆区</code> –&gt; <code>栈区</code><br>———————————————————-&gt;</p><p>block类型分为三种:</p><blockquote><p>__NSGlobalBlock__     (没有访问 auto 变量 – <code>数据区</code> – copy:无操作)<br>__NSStackBlock__  (访问了 auto 变量 – <code>栈区</code> – copy:由栈复制到堆)<br>__NSMallocBlock__     (<strong>NSStackBlock</strong>调用了copy – <code>堆区</code> – copy:引用计数增加)</p></blockquote><h3 id="总结下block的copy"><a href="#总结下block的copy" class="headerlink" title="总结下block的copy"></a>总结下block的copy</h3><h4 id="1、ARC环境下"><a href="#1、ARC环境下" class="headerlink" title="1、ARC环境下"></a>1、ARC环境下</h4><p>在ARC环境下编译器会根据情况自动将栈上的block复制到堆上：</p><ul><li>block作为函数返回值</li><li>将block赋值给__strong指针</li><li>block作为Cocoa API中的方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时 </li></ul><h4 id="2、block作为属性的写法-修饰"><a href="#2、block作为属性的写法-修饰" class="headerlink" title="2、block作为属性的写法 (修饰)"></a>2、block作为属性的写法 (修饰)</h4><ul><li>ARC ：strong/copy</li><li>MRC ：copy</li></ul><h3 id="补充：对象类型的AUTO变量"><a href="#补充：对象类型的AUTO变量" class="headerlink" title="补充：对象类型的AUTO变量"></a>补充：对象类型的AUTO变量</h3><p>当block内部访问了对象类型的auto变量时：</p><p>1、 如果block在栈上，不会对auto变量产生强引用<br>2、 如果block被拷贝到堆上会调用block的copy函数</p><ul><li>copy函数调用_Block_object_assign</li><li>_Block_object_assign函数会根据auto变量的修饰符 (__strong、<strong>weak、</strong>unsafe_unretained)做出相应的操作，形成强引用或弱引用</li></ul><p>3、如果block从堆上移除会调用dispose函数</p><ul><li>dispose函数会调用_Block_object_dispose函数</li><li>_Block_object_dispose会自动释放引用的auto变量(release)</li></ul><h4 id="clang命令无法支持-weak的问题"><a href="#clang命令无法支持-weak的问题" class="headerlink" title="clang命令无法支持__weak的问题"></a>clang命令无法支持__weak的问题</h4><p>在使用clang转换OC为C++时，遇到以下问题：<br>cannot create __weak refrence in file using manual refrence</p><p>解决：支持ARC、指定运行时系统版本：<br>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</p><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^Block)(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        Block block;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            NSObject * obj = [[NSObject alloc] init];</span><br><span class="line">            </span><br><span class="line">            __weak typeof(obj) weakObj = obj;</span><br><span class="line">            </span><br><span class="line">            block = [^&#123;</span><br><span class="line">                NSLog(@&quot;---- %@&quot;, weakObj);</span><br><span class="line">            &#125; copy];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;------&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换C++：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSObject *__weak weakObj;// 为捕获到的对象auto变量</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *__weak _weakObj, int flags=0) : weakObj(_weakObj) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSObject *__weak weakObj = __cself-&gt;weakObj; // bound by copy</span><br><span class="line"></span><br><span class="line">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_lw_6z_mkyd178q8n6w9m1vqbk9w0000gn_T_main_5e91db_mi_0, weakObj);</span><br><span class="line">            &#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    </span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;weakObj, (void*)src-&gt;weakObj, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    </span><br><span class="line">    _Block_object_dispose((void*)src-&gt;weakObj, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  </span><br><span class="line">  // 多出以下两个函数  copy、dispose</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;block的类型&quot;&gt;&lt;a href=&quot;#block的类型&quot; class=&quot;headerlink&quot; title=&quot;block的类型&quot;&gt;&lt;/a&gt;block的类型&lt;/h3&gt;&lt;p&gt;先来看一下测试:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block原理探究-1</title>
    <link href="http://yoursite.com/2018/07/25/block%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-1/"/>
    <id>http://yoursite.com/2018/07/25/block原理探究-1/</id>
    <published>2018-07-25T05:26:21.000Z</published>
    <updated>2019-04-08T08:11:24.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="block-底层数据结构"><a href="#block-底层数据结构" class="headerlink" title="block 底层数据结构"></a>block 底层数据结构</h3><p>测试代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        void (^block)(void) = ^&#123;</span><br><span class="line">            NSLog(@&quot;block1234&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>clang</code> 编译查看 .cpp 文件, 看block被编译成了什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">去掉上面的强制类型转换如下:</span><br><span class="line">void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">block-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><p>可以看到最终block的调用就是 <code>block-&gt;FuncPtr(block);</code> , 就是调用函数</p><p>看一下block的 <code>__main_block_impl_0</code> 的结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">           NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_y5_bv8t9pxx6jg830_kh4l6p_800000gn_T_main_fc5269_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>可以看到block其实就是一个结构体,再仔细看一下还有isa指针,是不是跟我们前面讲到的对象一样,所以block也是OC的对象,里面有 <code>struct __block_impl impl;</code> 和 <code>struct __main_block_desc_0* Desc;</code> 结构, 而 <code>__block_impl</code> 里面有isa指针和 <code>void *FuncPtr;</code> ,不过结构体里面有构造函数 <code>__main_block_impl_0</code> .</p><p>可以分析block在编译的时候是这样的: 根据block里面的实现先生成一个函数 <code>__main_block_func_0</code> ,然后接着生成一个 <code>__main_block_impl_0</code> 类型的结构体,将生成的函数指针和 <code>__main_block_desc_0</code> 传入并调用构造函数初始化block,这样block的结构就生成了.<br>当我们调用block时其实就是根据 <code>__block_impl</code> 查找函数指针 <code>void *FuncPtr</code> ,然后调用对应的函数的过程.</p><h3 id="block-变量的捕获"><a href="#block-变量的捕获" class="headerlink" title="block 变量的捕获"></a>block 变量的捕获</h3><p>我们来针对三种方式来测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1.全局变量 --&gt;</span><br><span class="line">int weight = 10;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &lt;!-- 2.局部变量 auto修饰(默认值) --&gt;</span><br><span class="line">        auto int age = 10;</span><br><span class="line">        &lt;!-- 3.局部变量 static修饰 --&gt;</span><br><span class="line">        static int height = 10;</span><br><span class="line">        </span><br><span class="line">        void (^block1)(void) = ^&#123;</span><br><span class="line">            NSLog(@&quot;block1--- %d  %d  %d&quot;, age, height, weight);</span><br><span class="line">        &#125;;</span><br><span class="line">        age = 20;</span><br><span class="line">        height = 20;</span><br><span class="line">        weight = 20;</span><br><span class="line">        </span><br><span class="line">        block1();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新用clang编译查看结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int weight = 10;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age;</span><br><span class="line">  int *height;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age = __cself-&gt;age; // bound by copy</span><br><span class="line">  int *height = __cself-&gt;height; // bound by copy</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_k8_chp8jt5d231d16l0s6w3c_gh0000gn_T_main_53994b_mi_0, age, (*height), weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        auto int age = 10;</span><br><span class="line">        static int height = 10;</span><br><span class="line"></span><br><span class="line">        void (*block1)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height));</span><br><span class="line"></span><br><span class="line">        age = 20;</span><br><span class="line">        height = 20;</span><br><span class="line">        weight = 20;</span><br><span class="line"></span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到block里面只捕捉到了局部变量,而且捕捉到的局部变量的类型不一样, <code>auto</code> 类型的为值传递,而 <code>static</code> 类型的为指针传递.全局变量类型的为直接访问.</p><blockquote><p>block能捕获到局部变量,不能捕获到全局变量.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;block-底层数据结构&quot;&gt;&lt;a href=&quot;#block-底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;block 底层数据结构&quot;&gt;&lt;/a&gt;block 底层数据结构&lt;/h3&gt;&lt;p&gt;测试代码:&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>category原理探究-3</title>
    <link href="http://yoursite.com/2018/07/22/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-3/"/>
    <id>http://yoursite.com/2018/07/22/category原理探究-3/</id>
    <published>2018-07-22T10:40:53.000Z</published>
    <updated>2019-04-08T08:11:24.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal (Eat)</span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal (Eat)</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>key值几种使用方法</code></p><blockquote><p>1.static void *AnimalKey = &AnimalKey;<br>2.static char AnimalKey;<br>3.使用属性名作为key;<br>4.使用get方法的@selector作为key;</p></blockquote><h3 id="关联对象的源码解读"><a href="#关联对象的源码解读" class="headerlink" title="关联对象的源码解读"></a>关联对象的源码解读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * retain the new value (if any) outside the lock.</span><br><span class="line">    * 用来记录原有关联值的变量</span><br><span class="line">    */ </span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 全局的manager</span><br><span class="line">        */    </span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        /**</span><br><span class="line">        * 获取 AssociationsHashMap</span><br><span class="line">        */</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        /**</span><br><span class="line">        * 根据 object 获取disguised_ptr_t</span><br><span class="line">        */</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * break any existing association.</span><br><span class="line">            * 根据 disguised_ptr_t 找到对应的AssociationsHashMap</span><br><span class="line">            */ </span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            /**</span><br><span class="line">            * 如果找到了AssociationsHashMap 则取出里面对应的 ObjectAssociationMaps</span><br><span class="line">            * 根据 key 取出ObjectAssociationMaps 里面的ObjectAssociationMap</span><br><span class="line">            */</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                /**</span><br><span class="line">                * 如果存在key对应的ObjectAssociationMap,则取出里面的数据:</span><br><span class="line">                * ObjcAssociation, 否则新建ObjcAssociation 并将ObjcAssociation以key为键存入ObjectAssociationMap中.</span><br><span class="line">                */</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /**</span><br><span class="line">                * create the new association (first time).</span><br><span class="line">                * 没有找到disguised_object对应的AssociationsHashMap,则创建一个并存入</span><br><span class="line">                */</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /**</span><br><span class="line">            * setting the association to nil breaks the association.</span><br><span class="line">            * 当要存入的 new_value为空时,查找对应的数据空间,如果找到用old_association记录存值的内存,并将ObjectAssociationMap里面的数据擦除</span><br><span class="line">            */ </span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * release the old value (outside of the lock).</span><br><span class="line">    * 如果old_association.hasValue的值不为空的话则释放这块内存的数据</span><br><span class="line">    */ </span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是关联对象时数据的结构.</p><p>看一下AssociationsManager的数据结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- AssociationsManager --&gt;</span><br><span class="line">class AssociationsManager &#123;</span><br><span class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;!-- AssociationsHashMap --&gt;</span><br><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&lt;!-- ObjectAssociationMap --&gt;</span><br><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&lt;!-- ObjcAssociation --&gt;</span><br><span class="line">class ObjcAssociation &#123;</span><br><span class="line">uintptr_t _policy;</span><br><span class="line">id _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 ObjcAssociation 里面存储的就是我们存贮相关的策略和值: _policy : _value.</p><p>void objc_setAssociateObject(id object, const void *key, id value, Objc_AssociationPolicy policy);</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>关联对象并不是存储在被关联对象本身内存中<br>关联对象存储在全局的统一的一个AssociatesManager中<br>设置关联对象为nil,就相当于是移除关联对象</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关联对象的使用&quot;&gt;&lt;a href=&quot;#关联对象的使用&quot; class=&quot;headerlink&quot; title=&quot;关联对象的使用&quot;&gt;&lt;/a&gt;关联对象的使用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>category原理探究-2</title>
    <link href="http://yoursite.com/2018/07/22/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-2/"/>
    <id>http://yoursite.com/2018/07/22/category原理探究-2/</id>
    <published>2018-07-22T04:55:46.000Z</published>
    <updated>2019-04-08T08:11:24.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="load-方法解析"><a href="#load-方法解析" class="headerlink" title="+load 方法解析"></a>+load 方法解析</h3><p>分析load方法前先来做一个小测验：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// Animal 类</span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Animal -- load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Dog 类 (-&gt;superclass animal)</span><br><span class="line">@interface Dog : Animal</span><br><span class="line">@end</span><br><span class="line">@implementation Dog</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Dog -- load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Cat 类 (-&gt;superclass animal)</span><br><span class="line">@interface Cat : Animal</span><br><span class="line">@end</span><br><span class="line">@implementation Cat</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Cat -- load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Animal 分类</span><br><span class="line">@interface Animal (Eat)</span><br><span class="line">@end</span><br><span class="line">@implementation Animal (Eat)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Animal (Eat) -- load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Dog 分类</span><br><span class="line">@interface Dog (Eat)</span><br><span class="line">@end</span><br><span class="line">@implementation Dog (Eat)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Dog (Eat) -- load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Cat 分类</span><br><span class="line">@interface Cat (Eat)</span><br><span class="line">@end</span><br><span class="line">@implementation Cat (Eat)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Cat (Eat) -- load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们来运行一下程序，发现没有调用这些类但是load方法都加载了，加载的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-07-22 15:36:46.369503+0800 debug-objc[11354:638134] Animal -- load</span><br><span class="line">2018-07-22 15:36:46.369954+0800 debug-objc[11354:638134] Cat -- load</span><br><span class="line">2018-07-22 15:36:46.369965+0800 debug-objc[11354:638134] Dog -- load</span><br><span class="line">2018-07-22 15:36:46.369981+0800 debug-objc[11354:638134] Cat (Eat) -- load</span><br><span class="line">2018-07-22 15:36:46.369996+0800 debug-objc[11354:638134] Dog (Eat) -- load</span><br><span class="line">2018-07-22 15:36:46.370009+0800 debug-objc[11354:638134] Animal (Eat) -- load</span><br></pre></td></tr></table></figure><p><a href="https://jueying-xiangfeng.github.io/2018/07/21/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-1/" target="_blank" rel="noopener">上一篇</a>中我们讲到了category的原理，猜想这里的结果应该是只会调用分类的方法，可是为什么这里都调用了呢？还有看一下 <code>PROJECT-&gt;TARGETS-&gt;Build Phases-&gt;Compole Source</code> 的编译顺序，分类的编译顺序和调用顺序能对上，但是cat和dog都在animal的前面，为什么会是先调用的animal的load方法呢?</p><p>我们来分析一下load方法在runtime的源码，老规矩，先下载runtime源码，找到入口 <code>_objc_init</code> 的 <code>load_images</code> 方法，看一下上面的官方注解：<code>Process +load in the given images which are being mapped in by dyld.</code> ，可以发现load方法就是在这里面加载的，看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">load_images(const char *path __unused, const struct mach_header *mh) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 准备 load methods</span><br><span class="line">    */</span><br><span class="line">    prepare_load_methods((const headerType *)mh);</span><br><span class="line">    /**</span><br><span class="line">    * 调用 load methods</span><br><span class="line">    */</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法我们拿出来单独看一下：</p><p><strong>a&gt;</strong> <code>prepare_load_methods</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 加载所有类</span><br><span class="line">    */</span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 调用 class 的 load 方法</span><br><span class="line">        */    </span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 加载所有分类</span><br><span class="line">    */</span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0； i &lt; count；i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i]；</span><br><span class="line">        /**</span><br><span class="line">        * 将category中的load方法加载到loadable的列表中</span><br><span class="line">        */</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里永远都是先加载类的load方法然后在加载分类的load方法，正好解释我们上面的小测试的结果，类的load方法会先与分类被调用。再把 <code>schedule_class_load</code> 方法拿出来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 判断如果已经加载过load方法则直接返回</span><br><span class="line">    */</span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line">    /**</span><br><span class="line">    * Ensure superclass-first ordering</span><br><span class="line">    * 这里是递归调用，优先加载 class的superclass的load方法，直到superclass为空</span><br><span class="line">    */</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line">    /**</span><br><span class="line">    * 将类的load方法加载到loadable的类表中</span><br><span class="line">    */</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    /**</span><br><span class="line">    * 设置此类的load方法标志位，表示已经加载过load方法</span><br><span class="line">    */</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用非常巧妙，用递归调用优先加载superclass的load方法，这里就明白了原来在加载类的load方法时会优先加载superclass的load方法，到这里明白了上面的小测验为什么先回调 animal 的load方法了吗？<br>再看一下 <code>add_class_to_loadable_list</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void add_class_to_loadable_list(Class cls) &#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    if (!method) return;  // Don&apos;t bother if cls has no +load method</span><br><span class="line">    /**</span><br><span class="line">    * 这里是将cls的method方法存放到 loadable_classes 数组中，</span><br><span class="line">    * loadable_classes_used++ 可以看出这里是按编译时的顺序加载的</span><br><span class="line">    */</span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面获取 method 的时候是获取的load method 的 <code>IMP</code> 。</p><p><code>prepare_load_methods</code> 的分类加载的时候调用的就是 <code>add_class_to_loadable_list</code> 方法，所以分类的加载顺序就是按编译的顺序加载的。</p><p>到这里所有的类和分类的数据load完毕，并且加载顺序也已经确定。</p><p><strong>b&gt;</strong> <code>call_load_methods</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* call_class_loads 方法</span><br><span class="line">*/</span><br><span class="line">static void call_class_loads(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    /**</span><br><span class="line">    * loadable_classes 就是我们上面 prepare 的加载完成的数据</span><br><span class="line">    */</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    /**</span><br><span class="line">    * i ++  可以看到这里是按着顺序加载我们在 prepare 时准备的数据的</span><br><span class="line">    */</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line">        /**</span><br><span class="line">        * 调用 load 方法</span><br><span class="line">        */</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的call_load_methods方法，先加载类在加载分类，在加载类的方法 <code>call_class_loads</code> 中是按着我们在 <code>prepare_load_methods</code> 方法中准备好的数据顺序执行的，所有prepare时加载的顺序就是load调用的顺序，可以查看分类的 <code>call_category_loads</code> 方法，跟加载类的方式是一样的。</p><p>到这里类和分类的所有load方法调用完毕。</p><p><code>关于load方法总结</code>：</p><blockquote><ol><li>调用方式：根据函数的 IMP 直接调用。</li><li>调用时机：在runtime加载类、分类时调用（只调用一次）</li><li>调用顺序：”1、a&gt; 先调用类的load(优先编译的优先调用)”  “b&gt; 调用子类的load方法之前会先调用父类的load方法”  “1、a&gt; 再调用分类的load方法(优先编译的分类优先调用)”</li></ol></blockquote><h3 id="initialize-方法"><a href="#initialize-方法" class="headerlink" title="initialize 方法"></a>initialize 方法</h3><p><code>我们知道 + initialize 方法会在类的第一次接收消息时调用。</code></p><p>将上面的小测试的所有load替换为initialize，然后分别调用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">第一次调用：</span><br><span class="line">[Animal class];</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-22 16:52:15.039883+0800 debug-objc[12499:710327] Animal (Eat) -- initialize</span><br><span class="line"></span><br><span class="line">第二次调用：</span><br><span class="line">[Dog class];</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-22 16:53:35.175441+0800 debug-objc[12534:711843] Animal (Eat) -- initialize</span><br><span class="line">2018-07-22 16:53:35.175637+0800 debug-objc[12534:711843] Dog (Eat) -- initialize</span><br><span class="line"></span><br><span class="line">第三次调用：</span><br><span class="line">[Animal class];</span><br><span class="line">[Dog class];</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-22 16:54:04.664353+0800 debug-objc[12553:712521] Animal (Eat) -- initialize</span><br><span class="line">2018-07-22 16:54:04.664578+0800 debug-objc[12553:712521] Dog (Eat) -- initialize</span><br></pre></td></tr></table></figure><p>看到三次的打印结果可以推测 <code>initialize</code> 的方法的调用符合我们上一篇文章中讲解，最后加载的分类会优先类调用，并且类的方法不会再调用，第二次的调用可以推测在调用 <code>initialize</code> 时会先调用父类的 <code>initialize</code> 方法。</p><p>下面我们来把子类Dog和dog分类的 <code>initialize</code> 方式删除，再来打印看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用：</span><br><span class="line">[Dog class];</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-22 17:08:29.497283+0800 debug-objc[12830:725499] Animal (Eat) -- initialize</span><br><span class="line">2018-07-22 17:08:29.497558+0800 debug-objc[12830:725499] Animal (Eat) -- initialize</span><br></pre></td></tr></table></figure><p>为什么 Animnal 的 <code>initialize</code> 会出现两次的调用呢？ <code>initialize</code> 不是只在第一次接收消息时调用吗？</p><p>initialize 是在发送消息时调用的，所以我们找到 <code>objc_msgSend</code> 方法，最终找到 <code>class_getInstanceMethod</code> 方法，根据调用：<code>-&gt;class_getInstanceMethod -&gt; lookUpImpOrNil -&gt;lookUpImpOrForward</code> 下面我们来分析一下runtime的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 如果cls还没有 Initialized 调用 _class_initialize</span><br><span class="line">    */</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _class_initialize(Class cls) &#123;</span><br><span class="line">    Class supercls;</span><br><span class="line">    /**</span><br><span class="line">    * 递归调用 cls父类的 callInitialize</span><br><span class="line">    */</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 没有 initialize 时设置 reallyInitialize为true</span><br><span class="line">    */</span><br><span class="line">    if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">        cls-&gt;setInitializing();</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 调用返送 SEL_initialize 消息方法</span><br><span class="line">        */</span><br><span class="line">        callInitialize(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 发送 SEL_initialize 消息</span><br><span class="line">*/</span><br><span class="line">void callInitialize(Class cls) &#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码可以看到，<code>initialize</code> 方法会先去查找父类，如果父类 <code>initialize</code> 没有调用过，会先向父类发送 <code>SEL_initialize</code> 消息，这里可以解释一下我们上面的小测试为什么 animal 的方法调用了两次，因为在 <code>_class_initialize</code> 方法中第一次由父类 animal 发送 <code>SEL_initialize</code> 消息，第二次由 dog 类发送 <code>SEL_initialize</code> 消息，而由于 dog 类没有 <code>initialize</code> 方法，所以会去调用父类 animal 的方法。</p><p><code>关于initialize方法总结</code>：</p><blockquote><ol><li>调用方式：initialize是通过objc_msgSend调用。</li><li>调用时机：initialize时类在第一次接收到消息时调用，每个类只会initialize一次（父类的initialize方法可能会被多次调用）。</li><li>调用顺序：先初始化父类 再初始化子类（可能最终调用的是父类的initialize方法）</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;load-方法解析&quot;&gt;&lt;a href=&quot;#load-方法解析&quot; class=&quot;headerlink&quot; title=&quot;+load 方法解析&quot;&gt;&lt;/a&gt;+load 方法解析&lt;/h3&gt;&lt;p&gt;分析load方法前先来做一个小测验：&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>category原理探究-1</title>
    <link href="http://yoursite.com/2018/07/21/category%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-1/"/>
    <id>http://yoursite.com/2018/07/21/category原理探究-1/</id>
    <published>2018-07-21T06:40:13.000Z</published>
    <updated>2019-04-08T08:11:24.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="category探究准备"><a href="#category探究准备" class="headerlink" title="category探究准备"></a>category探究准备</h3><p>先来创建我们测试需要的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Animal类 --&gt;</span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">- (void)animal;</span><br><span class="line">@end</span><br><span class="line">&lt;!-- Animal+Eat分类 --&gt;</span><br><span class="line">@interface Animal (Eat) &lt;NSCopying, NSCoding&gt;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">- (void)eat;</span><br><span class="line">@end</span><br><span class="line">&lt;!-- Animal+Play分类 --&gt;</span><br><span class="line">@interface Animal (Play)</span><br><span class="line">- (void)play;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>以Eat分类为例，请出 <code>clang</code> 命令：<code>clang -rewrite-objc Animal+Eat.m</code> ，生成.cpp文件。</p><h3 id="category的真面目"><a href="#category的真面目" class="headerlink" title="category的真面目"></a>category的真面目</h3><p>在.cpp文件最下面可以找到category被编译后的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 这里的name表示的是 <code>类名</code> 而不是category的名字。</li><li><code>cls</code> 要扩展的类对象，编译期间值为空，在被runtime加载时根据name对应到类对象。</li><li><code>instance_methods</code> category所有的实例方法。</li><li><code>class_methods</code> category所有的类方法。</li><li><code>protocols</code> category实现的所有协议。</li><li><code>properties</code> category的所有属性。</li></ul><p>再来看看我们的Animal+Eat被编译成了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t _OBJC_$_CATEGORY_Animal_$_Eat __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =  &#123;</span><br><span class="line">&quot;Animal&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_Animal,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Eat,</span><br><span class="line">0,</span><br><span class="line">(const struct _protocol_list_t *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_Animal_$_Eat,</span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Animal_$_Eat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看一下结构体的名称：<code>_OBJC_$_CATEGORY_Animal_$_Eat</code>，最后面的Eat就是我们分类的名称，前面有表示CATEGORY和类名Animal，这也就是为什么同一个类的category不能重名的原因了。<br>再对应一下其他的结构，例如instance_methods：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Eat __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;eat&quot;, &quot;v16@0:8&quot;, (void *)_I_Animal_Eat_eat&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们里面只有一个 <code>eat</code> 方法，被编译后为 <code>_I_Animal_Eat_eat</code>。</p><p>最后可以看到所有的category被放到了一个数组中，存在了 <code>__DATA</code> 段下的 <code>__objc_catlist section</code> 里了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Animal_$_Eat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里编译期间的工作就做完了，接下来进入runtime。</p><h3 id="runtime加载category"><a href="#runtime加载category" class="headerlink" title="runtime加载category"></a>runtime加载category</h3><p>先下载一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。</p><p>大致加载的流程如下：</p><ul><li>找到runtime的入口：<code>objc-os.mm</code> 的 <code>_objc_init</code> 方法，在library加载前由libSystem dyld调用，进行初始化操作。</li><li>调用map_images方法将文件中的image map到内存。</li><li>调用_read_images方法初始化map后的image。</li><li>找到 <code>Discover categories</code> 可以看到 <code>category_t</code> 是通过 <code>_getObjc2CategoryList</code> 方法初始化的，这个方法拿出来看看：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define GETSECT(name, type, sectname)                                   \</span><br><span class="line">    type *name(const headerType *mhdr, size_t *outCount) &#123;              \</span><br><span class="line">        return getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    type *name(const header_info *hi, size_t *outCount) &#123;               \</span><br><span class="line">        return getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, nil, outCount); \</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;);</span><br></pre></td></tr></table></figure><p>看到这里有没有很熟悉，在这里加载的 <code>__objc_catlist</code> 就是在编译期间存放的数据。</p><p>来看一下加载的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">for (EACH_HEADER) &#123;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">   * 取出 category 数据 此处为数组代表一个类所有的分类</span><br><span class="line">   */</span><br><span class="line">   category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">   for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">   </span><br><span class="line">  /**</span><br><span class="line">  * 按顺序取出 category_t </span><br><span class="line">  */</span><br><span class="line">  category_t *cat = catlist[i];</span><br><span class="line">  /**</span><br><span class="line">  * remapClass：加载category_t的class指针</span><br><span class="line">  */</span><br><span class="line">  Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">  </span><br><span class="line">  if (cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties) </span><br><span class="line">  &#123;</span><br><span class="line">      addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">      if (cls-&gt;isRealized()) &#123;</span><br><span class="line">      remethodizeClass(cls);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (cat-&gt;classMethods  ||  cat-&gt;protocols ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">  &#123;</span><br><span class="line">      addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">      if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">      remethodizeClass(cls-&gt;ISA());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次循环中 <code>category_t</code> 的加载 <code>addUnattachedCategoryForClass</code> 方法有两个调用，对比一下参数可以发现第二个参数不同 cls 和 cls-&gt;ISA()，再结合判断条件的 cat-&gt;instanceMethods 和 cat-&gt;classMethods，这两次的加载是将category中的信息分别加载到类和元类中，然后再调用 <code>remethodizeClass</code> 重新组织结构。接下来调用附加信息的方法 <code>attachCategories</code> ，将分类的信息附加到类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">    * 是否为元类</span><br><span class="line">    */ </span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 方法数组</span><br><span class="line">    */</span><br><span class="line">    method_list_t **mlists = (method_list_t **) </span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    /**</span><br><span class="line">    * 属性数组</span><br><span class="line">    */</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">   /**</span><br><span class="line">    * 协议数组</span><br><span class="line">    */</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line">    /**</span><br><span class="line">    ********** 注意 ：这里是倒序循环 **********</span><br><span class="line">    */</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类</span><br><span class="line">        */</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类的方法列表 (根据 isMeta 来判断取实例方法还是类方法)</span><br><span class="line">        */</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 将分类方法列表正序添加到 mlists</span><br><span class="line">            */        </span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类的属性列表</span><br><span class="line">        */</span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 将分类属性列表正序添加到 proplists</span><br><span class="line">            */  </span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类的协议列表</span><br><span class="line">        */</span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 将分类协议列表正序添加到 protolists</span><br><span class="line">            */  </span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 取出类的信息数据  class_rw_t</span><br><span class="line">    */</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">    /**</span><br><span class="line">    * 初始化方法的一些信息，比如有没有实现retain、release、allocWithZone等方法。</span><br><span class="line">    */</span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    /**</span><br><span class="line">    * 将所有分类的方法、属性、协议列表附加到类的方法、属性、协议列表中。</span><br><span class="line">    */</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的while循环可以看到加载方法、协议、属性的时候是 <code>倒序</code> 加载的，是不是想到了什么？如果Animal类和两个分类都有一个 <code>-(void)run</code> 方法，那么最终会调用哪个里面的run方法呢？答案当然是最后加载的那个run方法，不过没有被调用的run方法并没有被 <code>覆盖</code> ，方法还在那里只是按顺序没有被调用。</p><p>最后看一下 <code>methods.attachLists</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 将分类的 方法、协议、属性等信息附加到类中</span><br><span class="line">*/</span><br><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line"> </span><br><span class="line">uint32_t oldCount = array()-&gt;count;</span><br><span class="line">uint32_t newCount = oldCount + addedCount;</span><br><span class="line">/**</span><br><span class="line">* 重新分配内存（大小为： oldCount addedCount 原有count和要添加的count总和）</span><br><span class="line">*/ </span><br><span class="line">setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">array()-&gt;count = newCount;</span><br><span class="line">/**</span><br><span class="line">* 重新布局</span><br><span class="line">*/</span><br><span class="line">memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line"> oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">memcpy(array()-&gt;lists, addedLists,</span><br><span class="line"> addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新布局的时候有两个方法：</p><ul><li><code>memmove</code>：<code>void *memmove(void *__dst, const void *__src, size_t __len);</code> 可以看到是将src变量的数据移动到dst，所以最终是将 array()-&gt;lists 的数据移动到了 array()-&gt;lists + addedCount 的位置。</li><li><code>memcpy</code>：<code>void    *memcpy(void *__dst, const void *__src, size_t __n);</code> 可以看到是将src变量的数据copy到dst，所以最终是将分类中的信息 <code>addedLists</code> copy 到 array()-&gt;lists 的位置。</li></ul><p>正如我们上面说的run方法，Animal类中的run方法是被最后加载的，因为Animal类中的方法列表被移动到了分类的后面，加载的时候会先调用分类中的方法，而且可以看到Animal中的run方法确实没有被覆盖，只是调用的时候发现分类中有不会再调用Animal的run方法而已。</p><h3 id="class-extention与category"><a href="#class-extention与category" class="headerlink" title="class extention与category"></a>class extention与category</h3><p>上面知道了category，我们再来看看class extention，class extention算是一种特殊的分类（匿名分类），那么我们可以思考平时在 .m 文件的匿名分类中写的私有属性、方法等在加载的时候会不会和分类一样呢？我们来验证一下，在Animal的 .m 文件里添加属性 height 和方法 test：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal ()</span><br><span class="line">@property (nonatomic, assign) int height;</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">- (void)animal &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>用clang命令来编译 Animal：<code>clang -rewrite-objc Animal.m</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 元类结构</span><br><span class="line">*/</span><br><span class="line">static struct _class_ro_t _OBJC_METACLASS_RO_$_Animal __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">1, sizeof(struct _class_t), sizeof(struct _class_t), </span><br><span class="line">(unsigned int)0, </span><br><span class="line">0, </span><br><span class="line">&quot;Animal&quot;,</span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line">* 类结构</span><br><span class="line">*/</span><br><span class="line">static struct _class_ro_t _OBJC_CLASS_RO_$_Animal __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">0, __OFFSETOFIVAR__(struct Animal, _height), sizeof(struct Animal_IMPL), </span><br><span class="line">(unsigned int)0, </span><br><span class="line">0, </span><br><span class="line">&quot;Animal&quot;,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_Animal,</span><br><span class="line">0, </span><br><span class="line">(const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_Animal,</span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">&#125;;</span><br><span class="line">/***************************************/</span><br><span class="line">/**</span><br><span class="line">* 可以看到类中方法列表 ‘_INSTANCE_METHODS_Animal’对应下面的结构</span><br><span class="line">* animal、test、height、setHeight 方法都在类结构中</span><br><span class="line">*/</span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[4];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Animal __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">4,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;animal&quot;, &quot;v16@0:8&quot;, (void *)_I_Animal_animal&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_Animal_test&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;height&quot;, &quot;i16@0:8&quot;, (void *)_I_Animal_height&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setHeight:&quot;, &quot;v20@0:8i16&quot;, (void *)_I_Animal_setHeight_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译的结果如上，可以看到匿名类别的编译结果并不是 <code>category_t</code> 的类型在 runtime 时加载的，而是直接在编译期间将相关的属性方法等加载到了类中，匿名分类声明的属性方法相当于在类的 .h 文件的声明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;category探究准备&quot;&gt;&lt;a href=&quot;#category探究准备&quot; class=&quot;headerlink&quot; title=&quot;category探究准备&quot;&gt;&lt;/a&gt;category探究准备&lt;/h3&gt;&lt;p&gt;先来创建我们测试需要的类：&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO-KVC的原理探究 - KVC篇</title>
    <link href="http://yoursite.com/2018/07/19/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVC%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/19/KVO-KVC的原理探究-KVC篇/</id>
    <published>2018-07-19T07:12:40.000Z</published>
    <updated>2019-04-08T08:11:24.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于KVC的探究"><a href="#关于KVC的探究" class="headerlink" title="关于KVC的探究"></a>关于KVC的探究</h3><h4 id="基本介绍和使用"><a href="#基本介绍和使用" class="headerlink" title="基本介绍和使用"></a>基本介绍和使用</h4><p>KVC全称Key-Value Coding 键值编码，可以通过Key来访问某个属性，常见的API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p><p>创建Person类、Animal类，添加属性如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger height;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, strong) Animal * dog;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>如上，使用KVC赋值的方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Animal * dog = [[Animal alloc] init];</span><br><span class="line">Person * person = [[Person alloc] init];</span><br><span class="line">person.dog = dog;</span><br><span class="line">// Key        </span><br><span class="line">[person setValue:@11 forKey:@&quot;age&quot;];</span><br><span class="line">// KeyPath</span><br><span class="line">[person setValue:@123 forKeyPath:@&quot;dog.height&quot;];</span><br><span class="line">        </span><br><span class="line">NSLog(@&quot;---- %@ -- %@&quot;, @(person.age), @(person.dog.height));</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-19 23:00:48.546719+0800 KVC[53839:3059207] ---- 11 -- 123</span><br></pre></td></tr></table></figure></p><p>可以看到直接赋值的话两中方式都可以，但是类似上面的dog.height嵌套的方式必须通过KeyPath的方式赋值。</p><h4 id="KVC原理"><a href="#KVC原理" class="headerlink" title="KVC原理"></a>KVC原理</h4><p>进入Foundation里面查看 <code>- (void)setValue:(nullable id)value forKey:(NSString *)key;</code> 方法的注解可以了解到，<strong><code>KVC的赋值步骤</code></strong> 如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 调用setValue：forKey</span><br><span class="line">e_findSucceed=&gt;end: 传递参数，调用方法</span><br><span class="line">op1=&gt;operation: Operation1</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond_findMethod=&gt;condition: 按照 setKey：</span><br><span class="line">_setKey：</span><br><span class="line">顺序查找方法</span><br><span class="line">cond_instanceVariables=&gt;condition: 查看</span><br><span class="line">accessInstance</span><br><span class="line">VariablesDirectly</span><br><span class="line">（默认返回YES）</span><br><span class="line">方法的返回值</span><br><span class="line">cond_findIvar=&gt;condition: 按照</span><br><span class="line">_key、_isKey</span><br><span class="line">key、isKey</span><br><span class="line">顺序查找</span><br><span class="line">成员变量</span><br><span class="line">e_findIvar=&gt;end: 直接赋值</span><br><span class="line">e_exception=&gt;end: 调用</span><br><span class="line">setValue：forUndefinedKey：</span><br><span class="line">并且抛出</span><br><span class="line">NSUnKnownKeyException</span><br><span class="line"></span><br><span class="line">st-&gt;cond_findMethod</span><br><span class="line">cond_findMethod(yes, bottom)-&gt;e_findSucceed</span><br><span class="line">cond_findMethod(no, right)-&gt;cond_instanceVariables</span><br><span class="line">cond_instanceVariables(yes, bottom)-&gt;cond_findIvar</span><br><span class="line">cond_findIvar(yes, bottom)-&gt;e_findIvar</span><br><span class="line">cond_instanceVariables(no, right)-&gt;e_exception</span><br><span class="line">cond_findIvar(no, right)-&gt;e_exception</span><br></pre></td></tr></table></figure><p>以上为markdown语法，用的 MWebLite编写的，奈何blog不支持，所以直接将结果导图截图贴在下面：<br><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ftgaf779vdj315m10a7c9.jpg" alt=""></p><p>进入Foundation里面查看 <code>- (nullable id)valueForKey:(NSString *)key;</code> 方法的注解可以了解到，<strong><code>KVC的取值步骤</code></strong> 如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 调用valueForKey：</span><br><span class="line">e_findSucceed=&gt;end: 调用方法</span><br><span class="line">op1=&gt;operation: Operation1</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond_findMethod=&gt;condition: 按照 getKey</span><br><span class="line">key、isKey、</span><br><span class="line">_key、_getKey</span><br><span class="line">顺序查找方法</span><br><span class="line">cond_instanceVariables=&gt;condition: 查看</span><br><span class="line">accessInstance</span><br><span class="line">VariablesDirectly</span><br><span class="line">（默认返回YES）</span><br><span class="line">方法的返回值</span><br><span class="line">cond_findIvar=&gt;condition: 按照</span><br><span class="line">_key、_isKey</span><br><span class="line">key、isKey</span><br><span class="line">顺序查找</span><br><span class="line">成员变量</span><br><span class="line">e_findIvar=&gt;end: 直接取值</span><br><span class="line">e_exception=&gt;end: 调用</span><br><span class="line">valueForUndefinedKey：</span><br><span class="line">并且抛出</span><br><span class="line">NSUnKnownKeyException</span><br><span class="line"></span><br><span class="line">st-&gt;cond_findMethod</span><br><span class="line">cond_findMethod(yes, bottom)-&gt;e_findSucceed</span><br><span class="line">cond_findMethod(no, right)-&gt;cond_instanceVariables</span><br><span class="line">cond_instanceVariables(yes, bottom)-&gt;cond_findIvar</span><br><span class="line">cond_findIvar(yes, bottom)-&gt;e_findIvar</span><br><span class="line">cond_instanceVariables(no, right)-&gt;e_exception</span><br><span class="line">cond_findIvar(no, right)-&gt;e_exception</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/005O0Zogly1ftgcd9stvjj30lx0i7mzu.jpg" alt=""></p><h4 id="接下来我们来验证一下："><a href="#接下来我们来验证一下：" class="headerlink" title="接下来我们来验证一下："></a>接下来我们来验证一下：</h4><p><strong>setValue：forKey：赋值</strong><br>使用上面的Person类，将属性全部删除，添加以下成员变量，重写两个set方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    int _age;</span><br><span class="line">    int _isAge;</span><br><span class="line">    int age;</span><br><span class="line">    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)setAge:(NSInteger)age &#123;</span><br><span class="line">    NSLog(@&quot;--- setAge&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_setAge:(NSInteger)age &#123;</span><br><span class="line">    NSLog(@&quot;--- _setAge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后调用KVC给age赋值，可以看打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-07-20 14:41:18.679275+0800 KVC[65810:3455316] --- setAge</span><br></pre></td></tr></table></figure></p><p>此时调用的是 <code>setAge:</code> 方法，注释掉 <code>setAge:</code> 方法再次运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-07-20 14:41:43.561291+0800 KVC[65834:3456053] --- _setAge</span><br></pre></td></tr></table></figure></p><p>当这两个方法都没有实现的时候就会调用 <code>accessInstanceVariablesDirectly</code> 方法，若返回YES，则直接给成员变量赋值，如没有或返回值为NO则会调用 <code>setValue：forUndefinedKey：</code> 并且抛出NSUnKnownKeyException异常。<br><strong>valueForKey：取值</strong><br>重写流程图中的get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (int)getAge &#123;</span><br><span class="line">    return 11;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)age &#123;</span><br><span class="line">    return 12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)isAge &#123;</span><br><span class="line">    return 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)_age &#123;</span><br><span class="line">    return 14;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)_getAge &#123;</span><br><span class="line">    return 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">NSLog(@&quot;---- %@&quot;, [person valueForKey:@&quot;age&quot;]);</span><br></pre></td></tr></table></figure></p><p>如上我们可以查看当调用过的方法后就注释，直到执行完成所有的方法。我们可以控制 <code>accessInstanceVariablesDirectly</code> 方法的返回值来证明我们想要的结果。</p><h4 id="思考一下KVC能触发KVO吗？"><a href="#思考一下KVC能触发KVO吗？" class="headerlink" title="思考一下KVC能触发KVO吗？"></a>思考一下KVC能触发KVO吗？</h4><p>我们来测试一下，添加Observer类来监听并输出Log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation Observer</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;observeValueForKeyPath - %@&quot;, change);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">测试代码：</span><br><span class="line">Observer * ob = [Observer new];</span><br><span class="line">Person * person = [[Person alloc] init];</span><br><span class="line">[person addObserver:ob forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">        </span><br><span class="line">[person setValue:@1 forKey:@&quot;age&quot;];</span><br><span class="line">[person removeObserver:ob forKeyPath:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">打印结果为：</span><br><span class="line">2018-07-20 15:19:30.526730+0800 KVC[67145:3507833] observeValueForKeyPath - &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 1;</span><br><span class="line">    old = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到KVC确实调用了KVO，<a href="https://jueying-xiangfeng.github.io/2018/07/17/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVO%E7%AF%87/" target="_blank" rel="noopener">上一篇文章</a>中我们了解到了KVO的实现，接下来可以大概验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在Person类中实现如下方法：</span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey&quot;);</span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey-- begin&quot;);</span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey-- end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-20 15:23:34.761496+0800 KVC[67256:3513685] willChangeValueForKey</span><br><span class="line">2018-07-20 15:23:34.761836+0800 KVC[67256:3513685] didChangeValueForKey-- begin</span><br><span class="line">2018-07-20 15:23:34.762151+0800 KVC[67256:3513685] observeValueForKeyPath - &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 1;</span><br><span class="line">    old = 0;</span><br><span class="line">&#125;</span><br><span class="line">2018-07-20 15:23:34.762202+0800 KVC[67256:3513685] didChangeValueForKey-- end</span><br></pre></td></tr></table></figure></p><p>可以看到打印结果跟KVO是一样的，这里可以猜测苹果大大在KVC内部的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">person-&gt;_age = 1;</span><br><span class="line">[person didChangeValueForKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure></p><p>KVC相当于手动调用了KVO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于KVC的探究&quot;&gt;&lt;a href=&quot;#关于KVC的探究&quot; class=&quot;headerlink&quot; title=&quot;关于KVC的探究&quot;&gt;&lt;/a&gt;关于KVC的探究&lt;/h3&gt;&lt;h4 id=&quot;基本介绍和使用&quot;&gt;&lt;a href=&quot;#基本介绍和使用&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO-KVC的原理探究 - KVO篇</title>
    <link href="http://yoursite.com/2018/07/17/KVO-KVC%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-KVO%E7%AF%87/"/>
    <id>http://yoursite.com/2018/07/17/KVO-KVC的原理探究-KVO篇/</id>
    <published>2018-07-17T03:38:17.000Z</published>
    <updated>2019-04-08T08:11:24.387Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="关于KVO的探究"><a href="#关于KVO的探究" class="headerlink" title="关于KVO的探究"></a>关于KVO的探究</h3><h4 id="KVO的基本使用"><a href="#KVO的基本使用" class="headerlink" title="KVO的基本使用"></a>KVO的基本使用</h4><p>创建Person类，添加属性age：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在ViewController中添加属性<code>@property (nonatomic, strong) Person * person1;</code><br>实例化并添加KVO观察age属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.person1 = [[Person alloc] init];    </span><br><span class="line">self.person1.age = 1;</span><br><span class="line"></span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br></pre></td></tr></table></figure></p><p>添加观察监听回调并打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;被监听的 %@ 的值 %@ 改变为 %@&quot;, object, keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时准备工作完成，当点击view时就会修改age的值，并且回调打印出监听的结果，这里在ViewController的touchedBegan中修改值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.person.age = 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记得在最后移除键值观察<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上为KVO的基本使用。</p><h4 id="关于KVO的疑问和分析"><a href="#关于KVO的疑问和分析" class="headerlink" title="关于KVO的疑问和分析"></a>关于KVO的疑问和分析</h4><p>再次添加属性 <code>@property (nonatomic, strong) Person * person2;</code><br>实例化person2，在touchedBegan方法中修改值但是不添加KVO：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.person2 = [[Person alloc] init];</span><br><span class="line">self.person2.age = 2;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.person.age = 11;</span><br><span class="line">    self.person1.age = 22;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击view可以看到打印台的日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-07-17 14:09:26.944619+0800 KVO-KVC[36344:935709] 被监听的 &lt;Person: 0x6040000106d0&gt; 的值 age 改变为 &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 11;</span><br><span class="line">    old = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就可以思考都是修改age属性值，为什么person1会有回调而person2没有，修改的本质都是调用age的set方法。猜想person1和person2的set方法实现可能不一样，但是实例方法都是存放在class中的，set方法应该是一样的才对，在<code>touchesBegan处打断点</code>，然后直接查看person1和person2的isa指针，看看person1和person2的class是否一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p self.person1.isa</span><br><span class="line">(Class) $0 = NSKVONotifying_Person</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    self.person1-&gt;isa</span><br><span class="line">(lldb) p self.person2.isa</span><br><span class="line">(Class) $1 = Person</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    self.person2-&gt;isa</span><br></pre></td></tr></table></figure><p>可以看到person1的class为 <code>NSKVONotifying_Person</code> person2的class为 <code>Person</code> ，isa指针指向的就是instance的class，但是为什么person1和person2会不一样呢？我们在添加键值观察之前和之后分别打印person的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;添加前 person1 : %@    person2 : %@&quot;, object_getClass(self.person1), object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;添加后 person1 : %@    person2 : %@&quot;, object_getClass(self.person1), object_getClass(self.person2));</span><br></pre></td></tr></table></figure></p><p>打印的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-17 14:40:59.918227+0800 KVO-KVC[37038:970983] 添加前 person1 : Person    person2 : Person</span><br><span class="line">2018-07-17 14:40:59.918636+0800 KVO-KVC[37038:970983] 添加后 person1 : NSKVONotifying_Person    person2 : Person</span><br></pre></td></tr></table></figure><p>可以看到添加键值观察之后person1的isa指针指向确实被修改了，指向了 <code>NSKVONotifying_Person</code> 类，结合上面的猜想，会不会是 <code>NSKVONotifying_Person</code> 这个类重新实现了person1的 <code>setAge:</code> ，否则怎么会和person2不一样呢？<br>我们来验证一下，通过 <code>methodForSelector:</code> 来获取 <code>setAge:</code> 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;添加前 person1 : %p    person2 : %p&quot;,</span><br><span class="line">          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">          [self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">          </span><br><span class="line">NSLog(@&quot;添加后 person1 : %p    person2 : %p&quot;,</span><br><span class="line">          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">          [self.person2 methodForSelector:@selector(setAge:)]);</span><br></pre></td></tr></table></figure></p><p>打印的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-17 14:46:56.489956+0800 KVO-KVC[37183:978368] 添加前 person1 : 0x102493570    person2 : 0x102493570</span><br><span class="line">2018-07-17 14:46:56.490699+0800 KVO-KVC[37183:978368] 添加后 person1 : 0x1027d9bf4    person2 : 0x102493570</span><br></pre></td></tr></table></figure><p>我们知道instance的方法、属性、协议等信息都存在与class中，所以当person1和person2调用 <code>setAge:</code> 时得到的地址应该是一样的，但是在添加键值观察之后person1的调用方法地址改变了，为什么会改变呢？让我们来看看这两个地址的IMP，在添加键值观察之后断点，直接查看两个地址的IMP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (IMP)0x100a43570</span><br><span class="line">(IMP) $0 = 0x0000000100a43570 (KVO-KVC -[Person setAge:] at Person.m:13)</span><br><span class="line">(lldb) p (IMP)0x100d89bf4</span><br><span class="line">(IMP) $1 = 0x0000000100d89bf4 (Foundation _NSSetLongLongValueAndNotify)</span><br></pre></td></tr></table></figure><p>可以看到添加键值观察之后调用 <code>setAge:</code> 方法其实就是调用了 <code>Foundation _NSSetLongLongValueAndNotify</code> </p><p>由此可以猜测在添加键值观察之后person1的isa指向了新生成的类 <code>NSKVONotifying_Person</code> ，<code>NSKVONotifying_Person</code> 可能继承自 <code>Person</code> 类，并且重写了 <code>setAge:</code> 方法，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age &#123;</span><br><span class="line">    _NSSetLongLongValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetLongLongValueAndNotify() &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    [super setAge:age];</span><br><span class="line">    [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    [observer observeValueForKeyPath:key ofObject:self change:opetions context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>综上我们的猜想KVO的实现：instance添加键值观察之后isa指针会被修改为指向 <code>NSKVONotifying_Person</code> ，<code>NSKVONotifying_Person</code> 继承自 <code>Person</code> 并且重写了 <code>setAge:</code> 方法，方法实现如上。</strong><br>在这里就有了那道最经典的面试题：<strong>如何手动实现KVO</strong>，我们只需要在修改值的时候替换 <code>_NSSetLongLongValueAndNotify</code> 方法里面的 <code>[super setAge:age];</code> 就好了。</p><h4 id="KVO内部实现窥探"><a href="#KVO内部实现窥探" class="headerlink" title="KVO内部实现窥探"></a>KVO内部实现窥探</h4><p>由上我们猜测出了KVO的实现原理，下面我们来继续探索一下KVO内部的实现。<br>我们分别在添加KVO前后打印person1和person2的class，这次我们用两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;添加前 person1 : %@ -- %@   person2 : %@ -- %@&quot;, [self.person1 class], object_getClass(self.person1), [self.person2 class], object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;添加后 person1 : %@ -- %@   person2 : %@ -- %@&quot;, [self.person1 class], object_getClass(self.person1), [self.person2 class], object_getClass(self.person2));</span><br></pre></td></tr></table></figure></p><p>打印出的结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-07-19 11:05:50.553735+0800 KVO-KVC[40616:2560144] 添加前 person1 : Person -- Person   person2 : Person -- Person</span><br><span class="line">2018-07-19 11:05:52.772905+0800 KVO-KVC[40616:2560144] 添加后 person1 : Person -- NSKVONotifying_Person   person2 : Person -- Person</span><br></pre></td></tr></table></figure></p><p>可以看到我们通常用来获取class的方法在添加前后结果都是 <code>Person</code> ，通过runtime API获取到的class不相同，怎么回事呢？我们先来看一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。<br>我们来分析一下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class方法：</span><br><span class="line"></span><br><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runtime object_getClass方法：</span><br><span class="line"></span><br><span class="line">Class object_getClass(id obj) &#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>class</code> 的类方法或者实例方法最终返回的都是class的self，而 <code>object_getClass</code> 方法返回的是obj的isa指针，所以通过 <code>object_getClass</code> 获取的才是当前obj的真正class，所以在添加KVO之后person1的isa指针确确实实是被修改了。<br>我们再来看一下捕捉到的 <code>NSKVONotifying_Person</code> 到底是个什么鬼？<br>先来看一下 <code>NSKVONotifying_Person</code> 的meta-class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;元类对象 person : %@    person1 : %@&quot;,</span><br><span class="line">          object_getClass(object_getClass(self.person1)),</span><br><span class="line">          object_getClass(object_getClass(self.person2)));</span><br><span class="line">打印结果：</span><br><span class="line">2018-07-19 11:39:30.210378+0800 KVO-KVC[41164:2599225] 元类对象 person : NSKVONotifying_Person    person1 : Person</span><br></pre></td></tr></table></figure></p><p><code>NSKVONotifying_Person</code> 的meta-class为 <code>NSKVONotifying_Person</code>。</p><p>在添加KVO之后打住断点，借用 <strong><a href="https://github.com/delebedev/DLIntrospection" target="_blank" rel="noopener">DLIntrospection</a></strong> 再来查看一下此时class里面方法都有什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[self.person1 class] instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x60400023daa0&gt;(</span><br><span class="line">- (void)setAge:(q)arg0 ,</span><br><span class="line">- (q)age</span><br><span class="line">)</span><br><span class="line">(lldb) po [object_getClass(self.person1) instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x60400025fb30&gt;(</span><br><span class="line">- (void)setAge:(q)arg0 ,</span><br><span class="line">- (class)class,</span><br><span class="line">- (void)dealloc,</span><br><span class="line">- (BOOL)_isKVOA</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>结果可以看到 <code>NSKVONotifying_Person</code> 重写了 <code>setAge:</code> 方法，并且还有其他的三个方法，可证上面的猜想确实没错，<code>NSKVONotifying_Person</code>重写了 <code>setAge:</code> 方法，但是还有一个上面的猜想没有验证，那就是 <code>NSKVONotifying_Person</code> 的superClass到底是谁？<br>类似isa指针的方式，我们断点直接打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self.person1.superclass</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">(lldb) po self.person2.superclass</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure></p><p>咦~~~ 等等，这跟我们猜测的不一样啊，怎么superclass都是NSObject呢？那我们的猜测是不是都错了？<br>为了看看superClass里面到底是什么下面我们请出 <code>clang</code> 大神：<br><code>clang -rewrite-objc Person.m</code><br>可以看出编译完成后Person类被编译成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">    struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">    NSInteger _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>结合runtime源码分析，Class为 <code>typedef struct objc_class *Class;</code> 类型的结构体，再看下结构体里面的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面确实有superclass，仿照runtime的结构我们自己来创建一个类似的结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct XFPerson_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_Class;</span><br><span class="line">    NSInteger _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>用我们自己创建的结构体来接收 <code>NSKVONotifying_Person</code> ，看看他的superclass到底是什么类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct XFPerson_IMPL * xfPerson1 = (__bridge struct XFPerson_IMPL *)(object_getClass(self.person1));</span><br><span class="line">struct XFPerson_IMPL * xfPerson2 = (__bridge struct XFPerson_IMPL *)(object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;person1--- %@&quot;, xfPerson1-&gt;super_Class);</span><br><span class="line">NSLog(@&quot;person2--- %@&quot;, xfPerson2-&gt;super_Class);</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">2018-07-19 14:05:38.855549+0800 KVO-KVC[43578:2717734] person1--- Person</span><br><span class="line">2018-07-19 14:05:38.855658+0800 KVO-KVC[43578:2717734] person2--- NSObject</span><br></pre></td></tr></table></figure></p><p>结果可见是符合我们的猜想的，<code>NSKVONotifying_Person</code> 确实是Person的子类，但是为什么上面直接打印instance的superclass却都是NSObject呢？<br>回过头来看一下上面我们找到的 <code>NSKVONotifying_Person</code> 除了 <code>setAge:</code> 还有三个方法，其中就有class方法，我们已经知道runtime的class的实现，class返回的就是self，而通过 <code>[self.person1 class]</code> 得到的是 <code>Person</code> ，这就证明了 <code>NSKVONotifying_Person</code> 重写了class方法，并且返回的是 <code>Person</code> 类，通过源码查看runtime的superclass方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    return self-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return [self class]-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是先通过class方法找到class，然后在根据class找到superclass，所以前面直接通过 <code>self.person1.superclass</code> 找到的是 <code>Person</code>，因为此时的class方法返回已经被修改了。</p><p>苹果大大可能是因为整个事件中 <code>NSKVONotifying_Person</code> 是个人畜无害的东西，对于开发者使用KVO是可以不用知道的，所以用这种方式来骗骗开发者，真不容易，还好最近看 <strong>白夜追凶</strong> 看的整个人都比较有耐心了就是要找到真相，哈(不)哈(要)哈(脸)😁。<br>再看看看其他的两个方法，<code>dealloc</code> 方法可能就是做一些销毁现场的事情，毕竟中间动态创建了 <code>NSKVONotifying_Person</code> ，不用了一定要销毁，而   <code>_isKVOA</code> 返回的一定是 YES ，表示当前确实是在用KVO，到此关于KVO的黑科技已经探究明白了，好了，打完收工，接着去看两集 <strong>白夜追凶</strong>， 哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;关于KVO的探究&quot;&gt;&lt;a href=&quot;#关于KVO的探究&quot; class=&quot;headerlink&quot; title=&quot;关于KVO的探究&quot;&gt;&lt;/a&gt;关于KVO的探究&lt;/h3&gt;&lt;h4 id=&quot;KVO的基本使用&quot;&gt;&lt;a href=&quot;#KVO
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习链接</title>
    <link href="http://yoursite.com/2018/06/06/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/06/06/学习链接/</id>
    <published>2018-06-06T02:06:16.000Z</published>
    <updated>2019-04-08T08:11:24.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git第三方链接"><a href="#Git第三方链接" class="headerlink" title="Git第三方链接"></a>Git第三方链接</h2><ul><li>打印一个类的方法、属性、协议等常用调试方法神器 <a href="https://github.com/delebedev/DLIntrospection" target="_blank" rel="noopener">NSObject+DLIntrospection</a></li><li>修改全局导航栏返回按钮样式: <a href="https://github.com/Mervin1024/MERNavigationBackItem" target="_blank" rel="noopener">MERNavigationBackItem</a></li><li>iOS常用的<a href="https://github.com/Tim9Liu9/TimLiu-iOS" target="_blank" rel="noopener">库、插件、知名博客</a></li><li><a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a></li><li>互联网公司技术架构: <a href="https://github.com/davideuler/architecture.of.internet-product" target="_blank" rel="noopener">链接</a></li><li><a href="https://github.com/BlocksKit/BlocksKit" target="_blank" rel="noopener">BlocksKit</a></li><li>一个拖拽的控制器: <a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="noopener">这里</a></li><li>中文版 Apple 官方 Swift 教程<a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="noopener">《The Swift Programming Language》</a></li><li>单元测试框架: <a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">fastlane</a>、<a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a></li><li>runTime编译源码: <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">链接</a></li></ul><ul><li>hexo主题: <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next</a>、<a href="https://github.com/pinggod/hexo-theme-apollo/blob/master/doc%2Fdoc-zh.md" target="_blank" rel="noopener">Apollo</a>、<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题集</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git第三方链接&quot;&gt;&lt;a href=&quot;#Git第三方链接&quot; class=&quot;headerlink&quot; title=&quot;Git第三方链接&quot;&gt;&lt;/a&gt;Git第三方链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;打印一个类的方法、属性、协议等常用调试方法神器 &lt;a href=&quot;https:/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建</title>
    <link href="http://yoursite.com/2018/06/01/hexo%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/06/01/hexo搭建/</id>
    <published>2018-06-01T01:24:54.000Z</published>
    <updated>2019-04-08T08:11:24.389Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="1-创建Git仓库"><a href="#1-创建Git仓库" class="headerlink" title="1. 创建Git仓库"></a>1. 创建Git仓库</h3><p>在git上创建存放blog的仓库，名称为 username.github.io<br><br></p><h3 id="2-安装homebrew"><a href="#2-安装homebrew" class="headerlink" title="2. 安装homebrew"></a>2. 安装homebrew</h3><p>执行以下命令安装homebrew：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>还可以查看homebrew <a href="https://brew.sh/" target="_blank" rel="noopener">官方文档</a></p><p>安装Node.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew link node</span><br><span class="line">$ brew uninstall node</span><br><span class="line">$ brew install node</span><br></pre></td></tr></table></figure></p><p>安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><h3 id="3-创建博客"><a href="#3-创建博客" class="headerlink" title="3. 创建博客"></a>3. 创建博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init username.github.io</span><br></pre></td></tr></table></figure><p>安装主题 (经典的next主题)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd username.github.io</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>博客和主题的配置都可以在对应文件下名为”_config.yml”的文件中修改.</p><p>新建博客文章可以在目录: /source/_posts下直接创建:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new blogname</span><br></pre></td></tr></table></figure></p><p>开启测试服务器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>测试就可以访问: <a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a>来查看本地博客内容了</p><p>将hexo部署到Git上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p><p>在文章中加入 <code>&lt;!-- more --&gt;</code>表示首页 <strong>阅读全文</strong> 的分界线</p><p>参考链接:</p><ol><li><a href="https://juejin.im/post/5ac8db4d6fb9a028d5675c13" target="_blank" rel="noopener">mac环境下搭建hexo+github pages+next个人博客</a></li><li><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">5分钟 搭建免费个人博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h2 id=&quot;开始搭建&quot;&gt;&lt;a href=&quot;#开始搭建&quot; class=&quot;headerlink&quot; title=&quot;开始搭建&quot;&gt;&lt;/a&gt;开始搭建&lt;/h2&gt;&lt;h3 id=&quot;1-创建Git仓库&quot;&gt;&lt;a href=&quot;#1-创建Git仓库&quot; class=
      
    
    </summary>
    
    
  </entry>
  
</feed>
