---
title: 异步转同步
date: 2020-09-12 14:36:24
tags: async to sync
toc: false
description: 最近时间比较充足，正好放慢生活的节奏。抽时间整理了下工作中比较实用的小工具，和遇到的比较难解的问题的解决方法。下面介绍的是一个同步转异步的小工具。因为项目中使用其他的库（集团其他部门提供的库或者一些第三方库）而导致的异步同步问题，为了方便使用，单独写了一个异步转同步的小工具。

---



### 这里使用了两种方式：

- GCD  -- 阻塞当前线程
- RunLoop -- 不阻塞当前线程



看下对应 API

```objective-c
typedef void (^k_async_task_callback)(id, ...);
typedef void (^k_async_task)(id obj, k_async_task_callback callback);

typedef void (^k_async_task_interrupt_handler)(void);
typedef void (^k_async_task_interruptable)(id obj, k_async_task_interrupt_handler interrupt_handler, k_async_task_callback callback);


/// GCD 阻塞当前线程等待
void k_async_to_sync(k_async_task task, k_async_task_callback callback);
void k_async_to_sync_interruptable(k_async_task_interruptable task, k_async_task_callback callback);

/// RunLoop 不阻塞当前线程
void k_async_to_sync_nonblocking(k_async_task task, k_async_task_callback callback);
void k_async_to_sync_nonblocking_interruptable(k_async_task_interruptable task, k_async_task_callback callback);
```



具体使用见如下 Demo 测试代码：

```objective-c
- (void)gcd_test {
    NSLog(@"gcd_test begin -----");
    
    k_async_task_callback async_task_callback = ^(id obj, ...) {
        
        va_list args;
        va_start(args, obj);
        
        id string = va_arg(args, id);
        while (string) {
            string = va_arg(args, id);
        }
        va_end(args);
        
        NSLog(@"gcd_test task complete -----");
    };
    
    k_async_task task = ^(id obj, k_async_task_callback callback) {

        // 开始执行异步费时操作
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{

            // 在异步操作完成后，必须调用 callback: 第一个参数 obj 必须传
            // 这里 后面可以跟多个参数，不过在获取时注意参数个数
            callback(obj, @"aaa", nil);
        });
    };
    k_async_to_sync(task, async_task_callback);
    NSLog(@"gcd_test end -----");
    
    
    
    NSLog(@"gcd_test111 begin -----");
    
    __block k_async_task_interrupt_handler custom_interrupt_handler;
    k_async_task_interruptable interrupt_task = ^(id obj, k_async_task_interrupt_handler interrupt_handler, k_async_task_callback callback) {
        // 保存 interrupt handler，外界可以随时打断 task
        custom_interrupt_handler = [interrupt_handler copy];
        
        // 开始执行异步费时操作
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{
            
            callback(obj, @"aaa", nil);
        });
    };
    k_async_to_sync_interruptable(interrupt_task, async_task_callback);
    
    NSLog(@"gcd_test111 end -----");
}





- (void)runLoop_test {
    NSLog(@"runLoop_test begin -----");
    
    k_async_task_callback async_task_callback = ^(id obj, ...) {
        
        va_list args;
        va_start(args, obj);
        
        id string = va_arg(args, id);
        while (string) {
            string = va_arg(args, id);
        }
        va_end(args);
        
        NSLog(@"runLoop_test task complete -----");
    };
    
    
    k_async_task task = ^(id obj, k_async_task_callback callback) {

        // 开始执行异步费时操作
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{

            // 在异步操作完成后，必须调用 callback: 第一个参数 obj 必须传
            // 这里 后面可以跟多个参数，不过在获取时注意参数个数
            callback(obj, @"aaa", nil);
        });
    };
    k_async_to_sync_nonblocking(task, async_task_callback);
    NSLog(@"runLoop_test end -----");
    
    
    
    NSLog(@"runLoop_test111 begin -----");
    
    __block k_async_task_interrupt_handler custom_interrupt_handler;
    k_async_task_interruptable interrupt_task = ^(id obj, k_async_task_interrupt_handler interrupt_handler, k_async_task_callback callback) {
        // 保存 interrupt handler，外界可以随时打断 task
        custom_interrupt_handler = [interrupt_handler copy];
        
        // 开始执行异步费时操作
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{
            
            callback(obj, @"aaa", nil);
        });
    };
    k_async_to_sync_nonblocking_interruptable(interrupt_task, async_task_callback);
    
    NSLog(@"runLoop_test111 end -----");
}
```



[Demo地址](https://github.com/jueying-xiangfeng/asyncToSync) 

