---
title: å†…å­˜ç®¡ç†åŸç†æ¢ç©¶
date: 2020-08-08 16:42:16
tags: å†…å­˜ç®¡ç†
toc: true
description: 
---



æœ€è¿‘æ—¶é—´æ¯”è¾ƒæ•£ï¼Œè¿˜æœ‰å°±æ˜¯å…¬å¸æ¯”è¾ƒåŠ¨è¡ğŸ˜Œï¼Œå½“åˆæ€€ç€ä¸€é¢—åšäº‹çš„å¿ƒæ¥åˆ°è¿™é‡Œï¼Œæ²¡æƒ³åˆ°æœ€åè½å¾—è¿™æ ·çš„ç»“å±€ã€‚ä¸è¯´äº†ï¼Œè¿˜æ˜¯ä¿æŒæœ¬å¿ƒæ¯”è¾ƒå¥½ï¼Œå°½ç®¡æƒ³åšå¥½é£è¯»ï¼Œä½†æ˜¯æˆ‘ä»¬å°èŒå‘˜ä¹Ÿæ”¹å˜ä¸äº†ä»€ä¹ˆã€‚åšå¥½è‡ªå·±çš„äº‹æƒ…å°±å¥½ï¼ŒæŒ‰ç€å­¦ä¹ è®¡åˆ’ç»§ç»­ã€‚ã€‚ã€‚

<!-- more -->

### å®šæ—¶å™¨

iOS çš„å†…å­˜ç®¡ç†å¿…ç„¶å°‘ä¸äº†å®šæ—¶å™¨ï¼Œä»¥å‰æ²¡æœ‰æ·±ç©¶è¿‡å…·ä½“çš„åŸç†ï¼ŒåªçŸ¥é“ timer ä¼šå¯¹ target äº§ç”Ÿå¼ºå¼•ç”¨ï¼Œç°åœ¨æ¥åˆ†æä¸‹ä¸ºä»€ä¹ˆä¼šäº§ç”Ÿå¼ºå¼•ç”¨ä»¥åŠæ€æ ·è§£å†³ã€‚

å…ˆæ¥çœ‹ä¸€æ®µæµ‹è¯•ä»£ç ï¼š

```objective-c
- (void)testTimer {   
    self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];
    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
}

- (void)timerAction {
    NSLog(@"-- %s", __func__);
}
```

å¦‚ä¸Šï¼Œå½“æˆ‘ä»¬é”€æ¯æ§åˆ¶å™¨æ—¶æ²¡æœ‰è°ƒç”¨ dealloc æ–¹æ³•ï¼Œ è¯´æ˜æ­¤æ—¶æœ‰å¾ªç¯å¼•ç”¨ã€‚ä¹‹å‰åªæ˜¯çŸ¥é“ timer ä¼šå¯¹ self äº§ç”Ÿå¼ºå¼•ç”¨ï¼Œé‚£ä¹ˆå…·ä½“æ€ä¹ˆäº§ç”Ÿçš„å‘¢ï¼Œè¿™é‡Œå¯ä»¥çœ‹ä¸€ä¸‹ [GNU](http://www.gnustep.org/resources/downloads.php) æºç ï¼š

```objective-c
- (id) initWithFireDate: (NSDate*)fd
	       interval: (NSTimeInterval)ti
		 target: (id)object
	       selector: (SEL)selector
	       userInfo: (id)info
		repeats: (BOOL)f
{
  if (ti <= 0.0)
    {
      ti = 0.0001;
    }
  if (fd == nil)
    {
      _date = [[NSDate_class allocWithZone: NSDefaultMallocZone()]
        initWithTimeIntervalSinceNow: ti];
    }
  else
    {
      _date = [fd copyWithZone: NSDefaultMallocZone()];
    }
  _target = RETAIN(object);
  _selector = selector;
  _info = RETAIN(info);
  if (f == YES)
    {
      _repeats = YES;
      _interval = ti;
    }
  else
    {
      _repeats = NO;
      _interval = 0.0;
    }
  return self;
}
```

å¦‚ä¸Šå¯ä»¥çœ‹å‡º timer ä¼šå¯¹ target åšä¸€æ¬¡ retain æ“ä½œï¼Œè¿™ä¹Ÿå°±è§£é‡Šäº†ä¸ºä»€ä¹ˆä½¿ç”¨ __weak è§£å†³ä¸äº†å¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œå› ä¸ºä¸ç®¡ target ä¼ å…¥ self è¿˜æ˜¯ weakSelfï¼Œtimer éƒ½ä¼šå¯¹ self åšä¸€æ¬¡ retain æ“ä½œã€‚

<br/>

è¦æƒ³è§£å†³å¾ªç¯å¼•ç”¨ï¼Œé‚£ä¹ˆç›´æ¥çš„åŠæ³•å°±æ˜¯æ·»åŠ ä¸€ä¸ªä¸­é—´ä»£ç†ï¼Œä½¿ç”¨åˆ°äº† NSProxyï¼š

```objective-c
@interface TargetProxy : NSProxy
@property (nonatomic, weak) id target;
+ (instancetype)proxyWithTarget:(id)target;
@end

@implementation TargetProxy
+ (instancetype)proxyWithTarget:(id)target {
    TargetProxy * proxy = [TargetProxy alloc];
    proxy.target = target;
    return proxy;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    [invocation invokeWithTarget:self.target];
}
@end
```

è¿™æ ·å°±èƒ½è§£å†³å¾ªç¯å¼•ç”¨çš„é—®é¢˜ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ³¨æ„ç‚¹ï¼šå½“ç¨‹åºé€€åˆ°åå°æ—¶ timer å°±ä¼šåœæ­¢ï¼Œå› ä¸º timer æ˜¯åŸºäº RunLoop çš„ï¼Œå¦‚ä¹‹å‰ RunLoop ç« èŠ‚æ‰€è®²ï¼Œ timer ä¹Ÿæ˜¯ä¸ç²¾å‡†çš„ã€‚å¯ä»¥é€šè¿‡æ·»åŠ  observer æ¥éªŒè¯æˆ‘ä»¬çš„çŒœæƒ³ï¼Œå½“ç¨‹åºé€€åˆ°åå°æ—¶ï¼Œæœ€ç»ˆä¼šèµ°åˆ° kCFRunLoopBeforeWaiting çŠ¶æ€ï¼Œä»è€Œ timer åœæ­¢å·¥ä½œï¼Œå½“ç¨‹åºä»åå°å›åˆ°å‰å°æ—¶ï¼ŒRunLoop åˆä» kCFRunLoopAfterWaiting çŠ¶æ€å¼€å§‹æ‰§è¡Œï¼š

```objective-c
- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self testTimer];
    
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        NSLog(@"%lu", activity);
    });
    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);
    CFRelease(observer);
}
```



`CADisplayLink` åŸç†å’Œ `NSTimer` ç›¸åŒã€‚

å¦‚æœæƒ³è¦æ›´ç²¾å‡†çš„è®¾ç½® timerï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ GCD æ¥å®ç°ï¼š

```objective-c
@interface CTTimer : NSObject
+ (id)executeTask:(dispatch_block_t)task
            start:(NSTimeInterval)star
         interval:(NSTimeInterval)interval
         repeates:(BOOL)repeates
            async:(BOOL)async;

+ (id)executeWithTarget:(id)target
                 action:(SEL)action
                  start:(NSTimeInterval)star
               interval:(NSTimeInterval)interval
               repeates:(BOOL)repeates
                  async:(BOOL)async;

+ (void)cancelTask:(id)key;
@end

@implementation CTTimer
static NSMutableDictionary * timers_;
dispatch_semaphore_t semphore_;

+ (void)initialize {
    timers_ = [NSMutableDictionary dictionary];
    semphore_ = dispatch_semaphore_create(1);
}

+ (id)executeTask:(dispatch_block_t)task
            start:(NSTimeInterval)star
         interval:(NSTimeInterval)interval
         repeates:(BOOL)repeates
            async:(BOOL)async {
    
    if (!task || star < 0 || (interval < 0 && repeates)) { return nil; }
    
    static dispatch_queue_t _queue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _queue = dispatch_queue_create("queue timer", DISPATCH_QUEUE_CONCURRENT);
    });
    
    dispatch_queue_t timerQueue = async ? _queue : dispatch_get_main_queue();
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, timerQueue);
    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, star), interval * NSEC_PER_SEC, 0 * NSEC_PER_SEC);
    
    dispatch_semaphore_wait(semphore_, DISPATCH_TIME_FOREVER);
    NSString * key = [NSString stringWithFormat:@"key_%lu", (unsigned long)timers_.count];
    timers_[key] = timer;
    dispatch_semaphore_signal(semphore_);
    
    dispatch_source_set_event_handler(timer, ^{
        if (task) { task(); }
        if (!repeates) {
            [self cancelTask:key];
        }
    });
    dispatch_resume(timer);
    return key;
}

+ (id)executeWithTarget:(id)target
                 action:(SEL)action
                  start:(NSTimeInterval)star
               interval:(NSTimeInterval)interval
               repeates:(BOOL)repeates
                  async:(BOOL)async {
    
    if (!target || !action) { return nil; }
    
    return [self executeTask:^{
        if ([target respondsToSelector:action]) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
            [target performSelector:action];
#pragma clang diagnostic pop
        }
    } start:star interval:interval repeates:repeates async:async];
}

+ (void)cancelTask:(id)key {
    if (!key) { return; }
    dispatch_semaphore_wait(semphore_, DISPATCH_TIME_FOREVER);
    dispatch_source_t timer = timers_[key];
    if (timer) {
        dispatch_source_cancel(timer);
        [timers_ removeObjectForKey:key];
    }
    dispatch_semaphore_signal(semphore_);
}
@end
```



### iOS ç¨‹åºå†…å­˜å¸ƒå±€

iOS å†…å­˜å¸ƒå±€å¦‚ä¸‹æ‰€ç¤ºï¼š

![å†…å­˜å¸ƒå±€](https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

æ¥åšä¸ªç®€å•éªŒè¯ï¼š

```objective-c
int a = 10;
int b;

int main(int argc, char * argv[]) {
    @autoreleasepool {
        static int c = 20;
        static int d;
        int e;
        int f = 20;
        NSString *str = @"123";
        NSObject *obj = [[NSObject alloc] init];
        
        NSLog(@"\n&a=%p\n&b=%p\n&c=%p\n&d=%p\n&e=%p\n&f=%p\nstr=%p\nobj=%p\n",
              &a, &b, &c, &d, &e, &f, str, obj);
        return 0;
    }
}

// ç»“æœ
/*
 å­—ç¬¦ä¸²å¸¸é‡
 str=0x10dfa0068
 
 å·²åˆå§‹åŒ–çš„å…¨å±€å˜é‡ã€é™æ€å˜é‡
 &a =0x10dfa0db8
 &c =0x10dfa0dbc
 
 æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡ã€é™æ€å˜é‡
 &d =0x10dfa0e80
 &b =0x10dfa0e84
 
 å †
 obj=0x608000012210
 
 æ ˆ
 &f =0x7ffee1c60fe0
 &e =0x7ffee1c60fe4
 */
```



### Tagged Pointer

> ä»64 bit å¼€å§‹ï¼ŒiOS å¼•å…¥äº† TaggedPointer æŠ€æœ¯ï¼Œç”¨äºä¼˜åŒ– NSNumberã€NSDateã€NSString ç­‰å°å¯¹è±¡çš„å­˜å‚¨ã€‚
>
> åœ¨æ²¡æœ‰ Tagged Pointer ä¹‹å‰ï¼ŒNSNumber ç­‰å¯¹è±¡éœ€è¦åŠ¨æ€åˆ†é…å†…å­˜ã€ç»´æŠ¤å¼•ç”¨è®¡æ•°ç­‰ï¼ŒNSNumber æŒ‡é’ˆå­˜å‚¨çš„æ˜¯å †ä¸­ NSNumber å¯¹è±¡çš„åœ°å€å€¼ã€‚
>
> åœ¨ä½¿ç”¨äº† Tagged Pointer ä¹‹åï¼ŒNSNumber æŒ‡é’ˆé‡Œé¢å­˜å‚¨çš„æ•°æ®æ ‡ç§°äº†ï¼šTag+Dataï¼Œä¹Ÿå°±æ˜¯å°†æ•°æ®ç›´æ¥å­˜å‚¨åœ¨äº†æŒ‡é’ˆä¸­ã€‚
>
> å½“æŒ‡é’ˆä¸å¤Ÿå­˜å‚¨æ•°æ®æ—¶ï¼Œæ‰ä¼šä½¿ç”¨åŠ¨æ€åˆ†é…å†…å­˜çš„æ–¹å¼æ¥å­˜å‚¨æ•°æ®ã€‚
>
> objc_msgSend èƒ½è¯†åˆ« Tagged Pointerï¼Œæ¯”å¦‚ NSNumber çš„ intValue æ–¹æ³•ï¼Œç›´æ¥ä»æŒ‡é’ˆæå–æ•°æ®ï¼ŒèŠ‚çœäº†ä»¥å‰çš„è°ƒç”¨å¼€é”€ã€‚

ä¸‹é¢æ¥çœ‹ä¸‹æ€ä¹ˆæ ·åˆ¤æ–­ä¸€ä¸ªæŒ‡é’ˆæ˜¯å¦æ˜¯ Tagged Pointer å‘¢ã€‚

```objective-c
static inline bool 
_objc_isTaggedPointer(const void * _Nullable ptr) 
{
    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
}

#if TARGET_OS_OSX && __x86_64__
    // 64-bit Mac - tag bit is LSB
#   define OBJC_MSB_TAGGED_POINTERS 0
#else
    // Everything else - tag bit is MSB
#   define OBJC_MSB_TAGGED_POINTERS 1
#endif

#if OBJC_MSB_TAGGED_POINTERS
#   define _OBJC_TAG_MASK (1UL<<63)
#   define _OBJC_TAG_INDEX_SHIFT 60
#   define _OBJC_TAG_SLOT_SHIFT 60
#   define _OBJC_TAG_PAYLOAD_LSHIFT 4
#   define _OBJC_TAG_PAYLOAD_RSHIFT 4
#   define _OBJC_TAG_EXT_MASK (0xfUL<<60)
#   define _OBJC_TAG_EXT_INDEX_SHIFT 52
#   define _OBJC_TAG_EXT_SLOT_SHIFT 52
#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12
#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12
#else
#   define _OBJC_TAG_MASK 1UL
#   define _OBJC_TAG_INDEX_SHIFT 1
#   define _OBJC_TAG_SLOT_SHIFT 0
#   define _OBJC_TAG_PAYLOAD_LSHIFT 0
#   define _OBJC_TAG_PAYLOAD_RSHIFT 4
#   define _OBJC_TAG_EXT_MASK 0xfUL
#   define _OBJC_TAG_EXT_INDEX_SHIFT 4
#   define _OBJC_TAG_EXT_SLOT_SHIFT 4
#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0
#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12
#endif
```

å¦‚ä¸Šï¼ŒæŒ‡é’ˆæ˜¯å¦æ˜¯ Tagged Pointer æ˜¯é€šè¿‡ `&mask` å¾—åˆ°çš„ï¼Œçœ‹ä¸‹ä¸Šé¢çš„ mask å€¼æ˜¯åŒºåˆ† `iPhone` å’Œ `Mac` çš„ã€‚

å¯ä»¥çœ‹åˆ°ï¼š

- iOS å¹³å°ï¼šæœ€é«˜æœ‰æ•ˆä½æ˜¯ 1ï¼ˆç¬¬64 bitï¼‰
- Mac å¹³å°ï¼šæœ€ä½æœ‰æ•ˆä½æ˜¯ 1

å…·ä½“çš„ isa æŒ‡é’ˆå„ä¸ªä½çš„æ ‡è¯†ä¹‹å‰åœ¨ [RuntimeåŸç†æ¢ç©¶](https://jueying-xiangfeng.github.io/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/) ä¸­æœ‰è®²åˆ°è¿‡ã€‚



### OC å¯¹è±¡çš„å†…å­˜ç®¡ç†

åœ¨ iOS ä¸­ï¼Œä½¿ç”¨å¼•ç”¨è®¡æ•°æ¥ç®¡ç† OC å¯¹è±¡çš„å†…å­˜ã€‚

ä¸€ä¸ªæ–°åˆ›å»ºçš„ OC å¯¹è±¡å¼•ç”¨è®¡æ•°é»˜è®¤ä¸º 1ï¼Œå½“å¼•ç”¨è®¡æ•°å™¨å‡ä¸º0ï¼ŒOC å¯¹è±¡å°±é”€æ¯ï¼Œé‡Šæ”¾å ç”¨çš„å†…å­˜ç©ºé—´ã€‚

è°ƒç”¨ retain ä¼šè®© OC å¯¹è±¡çš„å¼•ç”¨è®¡æ•° +1ï¼Œrelease ä¼š -1.



å†…å­˜ç®¡ç†ç»éªŒæ€»ç»“ï¼š

- å½“è°ƒç”¨ allocã€mallocã€copyã€mutableCopy æ–¹æ³•è¿”å›äº†ä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨ä¸éœ€è¦è¿™ä¸ªå¯¹è±¡æ—¶ï¼Œè¦è°ƒç”¨ release æˆ–è€… autorelease æ¥é‡Šæ”¾ã€‚
- æƒ³æ‹¥æœ‰æŸä¸ªå¯¹è±¡ï¼Œå°±è®©å®ƒçš„å¼•ç”¨è®¡æ•° +1ï¼Œä¸æƒ³åœ¨æ‹¥æœ‰æŸä¸ªå¯¹è±¡ï¼Œå°±è®©å®ƒçš„å¼•ç”¨è®¡æ•° -1ã€‚



### copyã€mutableCopy

![copyã€mutableCopy](https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/copy%E3%80%81mutableCopy.png)



### weak åŸç†

å…ˆæ¥çœ‹ä¸‹ dealloc æ–¹æ³•çš„å®ç°ï¼š

```objective-c
inline void
objc_object::rootDealloc()
{
    if (isTaggedPointer()) return;  // fixme necessary?

    if (fastpath(isa.nonpointer  &&  
                 !isa.weakly_referenced  &&  
                 !isa.has_assoc  &&  
                 !isa.has_cxx_dtor  &&  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    } 
    else {
        object_dispose((id)this);
    }
}

id 
object_dispose(id obj)
{
    if (!obj) return nil;

    objc_destructInstance(obj);    
    free(obj);

    return nil;
}

void *objc_destructInstance(id obj) 
{
    if (obj) {
        // Read all of the flags at once for performance.
        bool cxx = obj->hasCxxDtor();
        bool assoc = obj->hasAssociatedObjects();

        // This order is important.
        if (cxx) object_cxxDestruct(obj);
        if (assoc) _object_remove_assocations(obj);
        obj->clearDeallocating();
    }

    return obj;
}

inline void 
objc_object::clearDeallocating()
{
    if (slowpath(!isa.nonpointer)) {
        // Slow path for raw pointer isa.
        sidetable_clearDeallocating();
    }
    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {
        // Slow path for non-pointer isa with weak refs and/or side table data.
        clearDeallocating_slow();
    }

    assert(!sidetable_present());
}

objc_object::clearDeallocating_slow()
{
    assert(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));

    SideTable& table = SideTables()[this];
    table.lock();
    if (isa.weakly_referenced) {
        weak_clear_no_lock(&table.weak_table, (id)this);
    }
    if (isa.has_sidetable_rc) {
        table.refcnts.erase(this);
    }
    table.unlock();
}
```

åœ¨ [RuntimeåŸç†æ¢ç©¶](https://jueying-xiangfeng.github.io/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/) ä¸­æˆ‘ä»¬è®²åˆ°è¿‡ ISA æŒ‡é’ˆçš„å„ä¸ªä½çš„ä½œç”¨ï¼Œåœ¨ dealloc æ—¶å¦‚æœæ²¡æœ‰ `å…³è”å¯¹è±¡(has_assoc)`ã€`c++ææ„å‡½æ•°(has_cxx_dtor)`ã€`å¼±å¼•ç”¨(weakly_referenced)`ã€`æ˜¯å¦ä½¿ç”¨ sidetable(has_sidetable_rc)` æ—¶é‡Šæ”¾ä¼šæ›´å¿«ã€‚è¿™é‡Œæˆ‘ä»¬å•ç‹¬çœ‹ä¸€ä¸‹ weakï¼Œè·Ÿåˆ° `clearDeallocating_slow` æ–¹æ³•å¯ä»¥çœ‹åˆ°æœ€ç»ˆçš„ç»“æ„ï¼š`SideTable`ï¼š

```objective-c
struct SideTable {
    spinlock_t slock;
    RefcountMap refcnts;
    weak_table_t weak_table;
};

// RefcountMap disguises its pointers because we 
// don't want the table to act as a root for `leaks`.
typedef objc::DenseMap<DisguisedPtr<objc_object>,size_t,true> RefcountMap;

struct weak_table_t {
    weak_entry_t *weak_entries;
    size_t    num_entries;
    uintptr_t mask;
    uintptr_t max_hash_displacement;
};

typedef DisguisedPtr<objc_object *> weak_referrer_t;

struct weak_entry_t {
    DisguisedPtr<objc_object> referent;
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };

    bool out_of_line() {
        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);
    }

    weak_entry_t& operator=(const weak_entry_t& other) {
        memcpy(this, &other, sizeof(other));
        return *this;
    }

    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)
        : referent(newReferent)
    {
        inline_referrers[0] = newReferrer;
        for (int i = 1; i < WEAK_INLINE_COUNT; i++) {
            inline_referrers[i] = nil;
        }
    }
};

```

å¦‚ä¸Šï¼ŒSidetable åŒ…å«ä¸‰éƒ¨åˆ†å†…å®¹ï¼Œlock éƒ¨åˆ†ä¸ç”¨ç®¡ï¼Œè¿™é‡Œçš„ RefcountMap å°±æ˜¯å½“ ISA æŒ‡é’ˆå­˜å‚¨ä¸ä¸‹å¼•ç”¨è®¡æ•°æ—¶æœ‰ Sidetable å­˜å‚¨çš„æ•£åˆ—è¡¨ã€‚å¦‚æœ `isa.has_sidetable_rc` ä¸º trueï¼Œåˆ™ä¼šè°ƒç”¨ `table.refcnts.erase(this);` æ¸…é™¤ç›¸å…³çš„å¼•ç”¨ã€‚

å†æ¥çœ‹ä¸‹ `weak_table` ç»“æ„ï¼Œå¯ä»¥çœ‹åˆ° weak_table ä¸ä¼šå¯¹ä¿®é¥°çš„å¯¹è±¡äº§ç”Ÿå¼ºå¼•ç”¨ï¼Œè€Œå½“å¯¹è±¡è¢« `weak` ä¿®é¥°è¿‡ï¼Œåˆ™åœ¨é‡Šæ”¾æ—¶å°±ä¼šè°ƒç”¨ `weak_clear_no_lock(&table.weak_table, (id)this);` æ–¹æ³•ï¼š

```objective-c
void 
weak_clear_no_lock(weak_table_t *weak_table, id referent_id) 
{
    objc_object *referent = (objc_object *)referent_id;

    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);
    if (entry == nil) {
        return;
    }
    
    for (size_t i = 0; i < count; ++i) {
        objc_object **referrer = referrers[i];
        if (referrer) {
            // é‡ç‚¹ï¼šè¿™é‡Œå°† weakReference ç½®ä¸º nil
            if (*referrer == referent) {
                *referrer = nil;
            }
            else if (*referrer) {
                objc_weak_error();
            }
        }
    }
    
    weak_entry_remove(weak_table, entry);
}
```

å¦‚ä¸Šæºç æ‰€ç¤ºï¼Œåœ¨é‡Šæ”¾å†…å­˜æ—¶ï¼Œä¼šå°†ç›¸å…³çš„ weak reference è®¾ç½®ä¸º nilï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨ `__weak` ä¿®é¥°è¿‡çš„å˜é‡åœ¨è¢«ä¿®é¥°çš„å¯¹è±¡é‡Šæ”¾æ—¶èƒ½ç½®ä¸º nil çš„åŸç†ã€‚

> ARC å°±æ˜¯ LLVM ç¼–è¯‘å™¨å’Œ Runtime ç³»ç»Ÿç›¸äº’åä½œçš„ç»“æœ



### Autorelease åŸç†

å½“å°†å¯¹è±¡è°ƒç”¨ `autorelease` æ–¹æ³•åï¼Œå°±ä¼šè¢«åŠ å…¥åˆ° `è‡ªåŠ¨é‡Šæ”¾æ± ` é‡Œé¢ï¼Œä½¿ç”¨ clang å‘½ä»¤æ¥çœ‹ä¸‹ autoreleasepool åˆ°åº•è¢«ç¼–è¯‘æˆäº†ä»€ä¹ˆï¼š

```objective-c
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
    }
    return 0;
}
```

è¿™é‡Œè¢«ç¼–è¯‘æˆäº† `__AtAutoreleasePool`ï¼Œç„¶ååœ¨ objc æºç é‡Œé¢æŸ¥æ‰¾ `autorelease` æ–¹æ³•ï¼Œæœ€ç»ˆå¯ä»¥çœ‹åˆ° autorelease çš„ç®¡ç†ç±»ï¼š`autoreleasepoolpage`ã€‚



æ‰€ä»¥è‡ªåŠ¨é‡Šæ”¾æ± çš„ä¸»è¦åº•å±‚æ•°æ®ç»“æ„æ˜¯ï¼š`__AtAutoreleasePool`ã€`AutoreleasePoolPage`ã€‚è°ƒç”¨äº† autorelease çš„å¯¹è±¡æœ€ç»ˆéƒ½æ˜¯é€šè¿‡ AutoreleasePoolPage å¯¹è±¡æ¥ç®¡ç†çš„ã€‚æ¥çœ‹ä¸‹ AutoreleasePoolPage çš„ç»“æ„ï¼š

```objective-c
class AutoreleasePoolPage 
{
    static size_t const SIZE = 
#if PROTECT_AUTORELEASEPOOL
        PAGE_MAX_SIZE;  // must be multiple of vm page size
#else
        PAGE_MAX_SIZE;  // size and alignment, power of 2 -- 4096
#endif
    static size_t const COUNT = SIZE / sizeof(id);
  
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
}
```

æ ¹æ® AutoreleasePoolPage å®šä¹‰é‡Œé¢çš„ PAGE_MAX_SIZE å¯ä»¥çœ‹åˆ°å ç”¨ 4096 å­—èŠ‚çš„å†…å­˜ã€‚é™¤äº†ç”¨æ¥å­˜æ”¾å®ƒå†…å­˜çš„æˆå‘˜å˜é‡ï¼Œå‰©ä¸‹çš„ç©ºé—´ç”¨æ¥å­˜æ”¾ autorelease å¯¹è±¡çš„åœ°å€ã€‚

æ‰€æœ‰çš„ AutoreleasePoolPage å¯¹è±¡éƒ½æ˜¯é€šè¿‡åŒå‘é‡è¡¨çš„å½¢å¼è¿æ¥åœ¨ä¸€èµ·çš„ã€‚

æ¥çœ‹ä¸‹åŸç†ç»“æ„å›¾ï¼š

![autoreleasepoolpageåŸç†](https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autoreleasepoolpage.png)

è°ƒç”¨ push æ–¹æ³•ä¼šå°†ä¸€ä¸ª POOL_BOUNDARY å…¥æ ˆï¼Œå¹¶ä¸”è¿”å›å…¶å­˜æ”¾çš„å†…å­˜åœ°å€ã€‚

è°ƒç”¨ pop æ–¹æ³•æ—¶ä¼ å…¥ä¸€ä¸ª POOL_BOUNDARY çš„å†…å­˜åœ°å€ï¼Œä¼šä»æœ€åä¸€ä¸ªå…¥æ ˆçš„å¯¹è±¡å¼€å§‹å‘é€ release æ¶ˆæ¯ï¼Œç›´åˆ°é‡åˆ°è¿™ä¸ª POOL)BOUNDARYã€‚

id *next æŒ‡å‘äº†ä¸‹ä¸€ä¸ªèƒ½å­˜æ”¾ autorelease å¯¹è±¡åœ°å€çš„åŒºåŸŸã€‚

```c++
static inline void *push() 
{
    id *dest;
    // push æ—¶å°† POOL_BOUNDARY å…¥æ ˆï¼Œå¹¶è¿”å› POOL_BOUNDARY å…¥æ ˆçš„åœ°å€
    if (DebugPoolAllocation) {
        // Each autorelease pool starts on a new pool page.
        dest = autoreleaseNewPage(POOL_BOUNDARY);
    } else {
        dest = autoreleaseFast(POOL_BOUNDARY);
    }
    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);
    return dest;
}

static inline void pop(void *token) 
{
    AutoreleasePoolPage *page;
    id *stop;
    // åˆ¤æ–­å½“å‰æ˜¯å¦æ˜¯ hotpageï¼Œå¦‚æœä¸æ˜¯åˆ™è°ƒç”¨ coldePage çš„ pop æ–¹æ³•
    // å¦‚æœå½“å‰æ˜¯ hotPageï¼Œåˆ™è°ƒç”¨ releaseUntil æ–¹æ³•
    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {
        // Popping the top-level placeholder pool.
        if (hotPage()) {
            // Pool was used. Pop its contents normally.
            // Pool pages remain allocated for re-use as usual.
            pop(coldPage()->begin());
        } else {
            // Pool was never used. Clear the placeholder.
            setHotPage(nil);
        }
        return;
    }

    page = pageForPointer(token);
    stop = (id *)token;
    if (*stop != POOL_BOUNDARY) {
        if (stop == page->begin()  &&  !page->parent) {
            // Start of coldest page may correctly not be POOL_BOUNDARY:
            // 1. top-level pool is popped, leaving the cold page in place
            // 2. an object is autoreleased with no pool
        } else {
            // Error. For bincompat purposes this is not 
            // fatal in executables built with old SDKs.
            return badPop(token);
        }
    }

    if (PrintPoolHiwat) printHiwat();

    page->releaseUntil(stop);
		...
}

void releaseUntil(id *stop) 
{
    while (this->next != stop) {
        AutoreleasePoolPage *page = hotPage();

        // fixme I think this `while` can be `if`, but I can't prove it
        while (page->empty()) {
            page = page->parent;
            setHotPage(page);
        }

        page->unprotect();
        id obj = *--page->next;
        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));
        page->protect();
        
        // çŸ¥é“æ‰¾åˆ°ä¸Šä¸€ä¸ªä¸ä¹‹å¯¹åº”çš„ POOL_BOUNDARYï¼Œå¦åˆ™ä¸­é—´çš„å¯¹è±¡éƒ½è°ƒç”¨ release æ–¹æ³•è¿›è¡Œé‡Šæ”¾
        if (obj != POOL_BOUNDARY) {
            objc_release(obj);
        }
    }
}
```



å†æ¥çœ‹ä¸‹ä¸€ä¸ªå˜é‡è¢«æ ‡è®°ä¸º autorelease åï¼Œæ˜¯åœ¨ä»€ä¹ˆæ—¶å€™ release çš„ã€‚

è‡ªåŠ¨é‡Šæ”¾æ± æ˜¯æœ‰ RunLoop æ§åˆ¶çš„ï¼ŒåŠ å…¥è‡ªåŠ¨é‡Šæ”¾æ± çš„å˜é‡ä¼šåœ¨æŸæ¬¡ RunLoop å¾ªç¯ä¸­ï¼ŒRunLoopä¼‘çœ ä¹‹å‰è°ƒç”¨ releaseã€‚

è€Œæˆ‘ä»¬å¹³æ—¶å¼€å‘æ—¶ä¸»çº¿ç¨‹çš„ RunLoop ä¸­å·²ç»æ³¨å†Œäº† 2 ä¸ª observerï¼š

1. ç¬¬ä¸€ä¸ª observer ç›‘å¬äº† kCFRunLoopEntry äº‹ä»¶ï¼Œä¼šè°ƒç”¨ objc_autoreleasePoolPush()ã€‚
2. ç¬¬äºŒä¸ª observer ç›‘å¬äº†ä¸¤ä¸ªäº‹ä»¶
   - kCFRunLoopBeforeWaiting äº‹ä»¶ï¼Œä¼šè°ƒç”¨ objc_autoreleasePoolPop()ã€objc_autoreleasePoolPush()ã€‚
   - kCFRunLoopBeforeExit äº‹ä»¶ï¼Œä¼šè°ƒç”¨ objc_autoreleasePoolPop()ã€‚



å…·ä½“çš„åº”ç”¨å¯ä»¥çœ‹ä¸‹ YY å¤§ç¥çš„ [YYKit](https://github.com/ibireme/YYKit/blob/master/YYKit/Base/Foundation/NSThread%2BYYAdd.m)  NSThread+YYAdd ç›¸å…³ä»£ç ï¼š

```objective-c
static inline void YYAutoreleasePoolPush() {
    NSMutableDictionary *dic =  [NSThread currentThread].threadDictionary;
    NSMutableArray *poolStack = dic[YYNSThreadAutoleasePoolStackKey];
    
    if (!poolStack) {
        /*
         do not retain pool on push,
         but release on pop to avoid memory analyze warning
         */
        CFArrayCallBacks callbacks = {0};
        callbacks.retain = PoolStackRetainCallBack;
        callbacks.release = PoolStackReleaseCallBack;
        poolStack = (id)CFArrayCreateMutable(CFAllocatorGetDefault(), 0, &callbacks);
        dic[YYNSThreadAutoleasePoolStackKey] = poolStack;
        CFRelease(poolStack);
    }
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // create
    [poolStack addObject:pool]; // push
}

static inline void YYAutoreleasePoolPop() {
    NSMutableDictionary *dic =  [NSThread currentThread].threadDictionary;
    NSMutableArray *poolStack = dic[YYNSThreadAutoleasePoolStackKey];
    [poolStack removeLastObject]; // pop
}

static void YYRunLoopAutoreleasePoolObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {
    switch (activity) {
        // è¿›å…¥ loop æ—¶ push
        case kCFRunLoopEntry: {
            YYAutoreleasePoolPush();
        } break;
        // loop ä¸€åœˆèµ°å®Œï¼Œå…ˆ pop ç„¶ååœ¨ push
        case kCFRunLoopBeforeWaiting: {
            YYAutoreleasePoolPop();
            YYAutoreleasePoolPush();
        } break;
        // é€€å‡ºæ—¶ pop
        case kCFRunLoopExit: {
            YYAutoreleasePoolPop();
        } break;
        default: break;
    }
}

static void YYRunloopAutoreleasePoolSetup() {
    CFRunLoopRef runloop = CFRunLoopGetCurrent();
    // å½“å‰çº¿ç¨‹æ·»åŠ ç›‘å¬ï¼škCFRunLoopEntryã€kCFRunLoopBeforeWaiting | kCFRunLoopExit
    CFRunLoopObserverRef pushObserver;
    pushObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopEntry,
                                           true,         // repeat
                                           -0x7FFFFFFF,  // before other observers
                                           YYRunLoopAutoreleasePoolObserverCallBack, NULL);
    CFRunLoopAddObserver(runloop, pushObserver, kCFRunLoopCommonModes);
    CFRelease(pushObserver);
    
    CFRunLoopObserverRef popObserver;
    popObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting | kCFRunLoopExit,
                                          true,        // repeat
                                          0x7FFFFFFF,  // after other observers
                                          YYRunLoopAutoreleasePoolObserverCallBack, NULL);
    CFRunLoopAddObserver(runloop, popObserver, kCFRunLoopCommonModes);
    CFRelease(popObserver);
}

@implementation NSThread (YYAdd)

+ (void)addAutoreleasePoolToCurrentRunloop {
    // ä¸»çº¿ç¨‹å­˜åœ¨è‡ªåŠ¨é‡Šæ”¾æ± ï¼Œæ‰€ä»¥è¿™é‡Œåªéœ€è¦åœ¨å­çº¿ç¨‹ä¸­æ·»åŠ   
    if ([NSThread isMainThread]) return; // The main thread already has autorelease pool.
    NSThread *thread = [self currentThread];
    if (!thread) return;
    if (thread.threadDictionary[YYNSThreadAutoleasePoolKey]) return; // already added
    YYRunloopAutoreleasePoolSetup();
    thread.threadDictionary[YYNSThreadAutoleasePoolKey] = YYNSThreadAutoleasePoolKey; // mark the state
}
```

