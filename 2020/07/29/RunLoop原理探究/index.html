<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RunLoop原理探究 | 白夜追凶</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RunLoop原理探究</h1><a id="logo" href="/.">白夜追凶</a><p class="description">Talk is cheap. Show me the code.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RunLoop原理探究</h1><div class="post-meta">2020年07月29日</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-概念"><span class="toc-number">1.</span> <span class="toc-text">RunLoop 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-结构"><span class="toc-number">2.</span> <span class="toc-text">RunLoop 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-与线程的关系"><span class="toc-number">3.</span> <span class="toc-text">RunLoop 与线程的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、RunLoop-的运行逻辑"><span class="toc-number">4.</span> <span class="toc-text">4、RunLoop 的运行逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-应用"><span class="toc-number">5.</span> <span class="toc-text">RunLoop 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSTimer"><span class="toc-number">5.1.</span> <span class="toc-text">NSTimer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCD"><span class="toc-number">5.2.</span> <span class="toc-text">GCD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PerformSelector"><span class="toc-number">5.3.</span> <span class="toc-text">PerformSelector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程保活"><span class="toc-number">5.4.</span> <span class="toc-text">线程保活</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Discussion"><span class="toc-number"></span> <span class="toc-text">Discussion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考-："><span class="toc-number">1.</span> <span class="toc-text">参考 ：</span></a></li></ol></div></div><div class="post-content"><h3 id="RunLoop-概念"><a href="#RunLoop-概念" class="headerlink" title="RunLoop 概念"></a>RunLoop 概念</h3><p>顾名思义，RunLoop 就是运行循环，在程序运行过程中循环做一些事情。这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event Loop</a>，这种模型的关键点在于：如何管理事件/消息，如果保证线程在没有处理消息时休眠避免资源占用、再有消息到来时立刻被唤醒。</p>
<a id="more"></a>
<p>一般来说，一个线程一次只能执行一次任务，执行完成后线程就会退出，如果要保证线程能随时处理事件但不退出，我们可能需要这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 睡眠中等待消息</span><br><span class="line">            int message = sleep_and_wait();</span><br><span class="line">            // 处理消息</span><br><span class="line">            retVal = process_message(message);</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 其实就是一个对象，这个对象管理了其需要处理的消息和事件，并且提供了一个入口函数来执行上面的 Event Loop 逻辑。线程执行了这个函数后，会一直处于：接受消息-&gt;等待-&gt;处理消息 的循环中，直到 retVal 为0才会退出函数。</p>
<p>可以在<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">这里</a>下载到 CoreFoundation的源码来查看具体实现。</p>
<h3 id="RunLoop-结构"><a href="#RunLoop-结构" class="headerlink" title="RunLoop 结构"></a>RunLoop 结构</h3><p>iOS 有两套 API 来访问和使用 RunLoop：<code>NSRunLoop</code>、<code>CFRunLoop</code>。NSRunLoop 是基于 CFRunLoop 的包装</p>
<p>Core Foundation 中关于 RunLoop 的类有5个：</p>
<ol>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ol>
<p>CFRunLoopRef：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    CFMutableSetRef _commonModes;			<span class="comment">// set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// set&lt;Source、Observer、Timer&gt;</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;		<span class="comment">// current mode</span></span><br><span class="line">    CFMutableSetRef _modes;						<span class="comment">// set</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>CFRunLoopModeRef：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFStringRef _name; <span class="comment">// mode name：such as - kCFRunLoopDefaultMode</span></span><br><span class="line">    CFMutableSetRef _sources0;		<span class="comment">// set</span></span><br><span class="line">    CFMutableSetRef _sources1;		<span class="comment">// set</span></span><br><span class="line">    CFMutableArrayRef _observers;	<span class="comment">// array</span></span><br><span class="line">    CFMutableArrayRef _timers;		<span class="comment">// array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫做 commonModes：一个 mode 可以将自己标记为 common 属性（通过将其 mode name 添加到 RunLoop 的 commonModes 中）。每当 RunLoop 内容发生时，RunLoop 会自动将 commonModeItems 里面的 source/observer/timer 同步到具有 common 标记的所有 mode 里面。</p>
<p>CFRunLoop 对外暴露的管理 mode 的接口有两个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>
<p>mode 暴露的管理 mode item 的接口有以下几个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>
<p>这里只能通过 mode name 来操作内部的 mode，当传入一个新的 mode name 单 RunLoop 里面没有对应的 mode 时，RunLoop 内部会自动创建 CFRunLoopModeRef。对于一个 Runloop 来说，内部的 mode 只能增加，不能删除。</p>
<p>苹果公开的 mode 有两个</p>
<ol>
<li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</li>
<li>UITrackingRunLoopMode</li>
</ol>
<p>这里还提供了一个操作 common 标记符的字符串 kCFRunLoopCommonModes (NSRunLoopCommonModes)。使用时注意这个标记和其他的 mode name。</p>
<p>看下 RunLoop 图示结构：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runloop/runloop%E7%BB%93%E6%9E%84.png" alt="RunLoop结构"></p>
<p>从上图的结构可以看到，一个 RunLoop 包含若干个 mode，每个 mode 有包含若干个 source/observer/timer，每次调用 RunLoop 的主函数时，只能指定其中一个 mode 作为 currentMode。如果需要切换 mode，只能退出当前 loop，再重新指定一个 mode 进入。这样做是为了不同组的 source/observer/timer，可以做到互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。source 有两个版本：source0 和 source1</p>
<ul>
<li>source0：只包含了一个回调（函数指针），它并不能主动触发事件。使用时需要先调用 CFRunLoopSourceSignal(source)，将这个 source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 – 触摸事件处理、performSelector:onThread；</li>
<li>source1：包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息，这种 source 能主动唤醒 RunLoop 的线程。 – 基于 port 的线程间通信、系统事件捕捉。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是基于事件的触发器，它和 NSTimer 是可以混用的。当加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个任务。 – NSTimer、performSelector:withObject:afterDelay:</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 observer 都包含了一个回调，当 RunLoop 的状态发生改变时，观察者就能通过回调接收到这个变化。</p>
<p>– 用于监听 RunLoop 的状态、UI 刷新（BeforeWaiting）、Autorelease pool（BeforeWaiting）</p>
<p>可以观测到的状态有一下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入 RunLoop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 即将被唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出 RunLoop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 source/timer/observer 统称为 mode item，一个 item 可以被同时加入多个 mode，但一个 item 被重复加入同一个 mode 是不会有效果的。如果一个 mode 里面一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h3><p>每条线程都有唯一一个与之对应的 RunLoop 对象，他们是一一对应的。</p>
<p>线程在刚创建时是没有 RunLoop 对象的，RunLoop 会在第一次获取它时创建，我们通常获取的方式有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopGetMain();</span><br><span class="line">[NSRunLoop currentRunLoop];</span><br><span class="line">[NSRunLoop mainRunLoop];</span><br></pre></td></tr></table></figure>
<p>来看下获取的源码，已 getCurrent 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的 Dictionary，key 是 pthread_t，value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> CFLock_t loopsLock = CFLockInit;	<span class="comment">// 访问 __CFRunLoops 时的锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for "main thread" that always works</span></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">// 线程为空则获取主线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果全局的 CFMutableDictionaryRef 为空，则先初始化全局的 CFMutableDictionaryRef，并先为主线程创建一个 RunLoop</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接从全局 CFMutableDictionaryRef 里面获取</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取不到则创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop</span></span><br><span class="line">    _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有源码分析可知：</p>
<ul>
<li>线程和 RunLoop 是一一对应的</li>
<li>RunLoop 保存在一个全局的 Dictionary 里面，pthread_t 为 key，RunLoop 为 value</li>
<li>线程刚创建时并没有 RunLoop，RunLoop 会在第一次获取它时创建</li>
<li>RunLoop 会在线程结束时销毁</li>
<li>只能在线程内部获取 RunLoop（主线程除外）</li>
</ul>
<h3 id="4、RunLoop-的运行逻辑"><a href="#4、RunLoop-的运行逻辑" class="headerlink" title="4、RunLoop 的运行逻辑"></a>4、RunLoop 的运行逻辑</h3><p>先来看流程图：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runloop/runloop%E6%B5%81%E7%A8%8B.png" alt="runloop流程"></p>
<p>来分析下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;	/* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    </span><br><span class="line">    /// 根据 mode name 找打对应 mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    /// 如果 mode 里面没有 source/timer/observer 则直接返回</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; return; &#125;</span><br><span class="line">    </span><br><span class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">	/// 1、通知 observer 即将进入 loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    /// 进入 RunLoop</span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    /// 11、通知 observer 退出 loop</span><br><span class="line">	__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* rl, rlm are locked on entrance and exit */</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    </span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 2、通知Observers：即将处理Timers</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        // 3、通知Observers：即将处理Sources</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        // 4、处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        // 5、处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        // 6、判断有无Source1</span><br><span class="line">        if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">            // 如果有Source1 则跳转到 handle_msg -- 即 第 8 步</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 7、通知Observers：即将休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 等待别的消息唤醒当前线程</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        // 8、通知Observers：结束休眠 -- 被某个消息唤醒</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    handle_msg:</span><br><span class="line">        </span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            // 8.1、处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">        &#125; else if (被GCD唤醒) &#123;</span><br><span class="line">            // 8.2、处理 GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 8.3、处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply);</span><br><span class="line">	    &#125;</span><br><span class="line">        </span><br><span class="line">        // 9、处理BLocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        // 10、根据当前结果决定如何操作</span><br><span class="line">        // -- 1&gt; 回到第 2 步</span><br><span class="line">        // -- 2&gt; 退出 RunLoop</span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            // 进入 loop 时处理完事件就返回</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            // 超出传入参数标记的时间了</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            // 被外部调用强制停止了</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;  else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            // source/timer/observer 一个都没有时</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line">        </span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下 RunLoop 休眠原理：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runloop/runloop%E4%BC%91%E7%9C%A0%E5%8E%9F%E7%90%86.png" alt="runloop休眠原理"></p>
<h3 id="RunLoop-应用"><a href="#RunLoop-应用" class="headerlink" title="RunLoop 应用"></a>RunLoop 应用</h3><h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>我们知道 NSTimer 是一个不准确的定时器，是有误差的。</p>
<p>当一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">uint16_t</span> _bits;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;		<span class="comment">/* immutable */</span></span><br><span class="line">  <span class="comment">/// 误差 -- 宽容度</span></span><br><span class="line">    CFTimeInterval _tolerance;          <span class="comment">/* mutable */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _fireTSR;			<span class="comment">/* TSR units */</span></span><br><span class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerCallBack _callout;	<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerContext _context;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果 timer 错过了某个时间点，例如执行一个很长的任务，则这个时间点的回调也会跳过去，不会延后执行。所以错过了就需要等下一次的 loop，这也就是 timer 不准确的原因。</p>
<p>再有就是 Timer 在滑动时会失效的问题。因为 RunLoop 只能选择一个 mode 运行，如果 timer 处于 kCFRunLoopDefaultMode 时，此时界面滑动，RunLoop 会切换到另一种模式：UITrackingRunLoopMode，此时界面处于跟踪 mode，此种模式用于 scrollView 追踪触摸滑动，保证界面滑动时不受其他 mode 影响，但是相对了也会使处于 default mode 的 timer 失效。</p>
<p>有两种方式解决：</p>
<ol>
<li>将 timer 依次加入到上述两个 mode 里面</li>
<li>将 timer 放到顶层的 commonModeItems 里面，commonModeItems 会被 RunLoop 自动更新到具有 common 属性的 mode 里面去</li>
</ol>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD 的某些接口也用到了 RunLoop，例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="name">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    // 处理一些子线程的逻辑</span><br><span class="line">    </span><br><span class="line">    // 回到主线程去刷新UI界面</span><br><span class="line">    dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), ^{})</code> 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调里面执行这个 block。这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是有 libDispatch 处理的。 </p>
<h4 id="PerformSelector"><a href="#PerformSelector" class="headerlink" title="PerformSelector"></a>PerformSelector</h4><p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [self performSelector:@selector(test1)];</span><br><span class="line">        [self performSelector:@selector(test2) withObject:nil];</span><br><span class="line">        [self performSelector:@selector(test3) withObject:nil withObject:nil];</span><br><span class="line">        </span><br><span class="line">        [self performSelector:@selector(test4) withObject:nil afterDelay:0];</span><br><span class="line">        </span><br><span class="line">        [self performSelector:@selector(test5) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">        </span><br><span class="line">//        [[NSRunLoop currentRunLoop] addPort:[NSPort new] forMode:NSDefaultRunLoopMode];</span><br><span class="line">//        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test1 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test2 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test3 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test4 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test5 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有在子线程获取 RunLoop 时，是没有 test4 和 test5 方法打印的，当添加 RunLoop 时才会有方法打印。因为子线程默认是没有 RunLoop 的。</p>
<p>来看下 <code>[self performSelector:@selector(test4) withObject:nil afterDelay:0];</code>的调用栈：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* thread #<span class="number">4</span>, queue = <span class="string">'com.apple.root.default-qos'</span>, stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x0000000109013387</span> Interview01-runloop流程`-[ViewController test4](self=<span class="number">0x00007fd80c40b680</span>, _cmd=<span class="string">"test4"</span>) at ViewController.m:<span class="number">66</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff25958d64</span> Foundation`__NSFireDelayedPerform + <span class="number">420</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x00007fff23da2414</span> CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + <span class="number">20</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00007fff23da20ae</span> CoreFoundation`__CFRunLoopDoTimer + <span class="number">1038</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00007fff23da170a</span> CoreFoundation`__CFRunLoopDoTimers + <span class="number">282</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x00007fff23d9c35e</span> CoreFoundation`__CFRunLoopRun + <span class="number">1950</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00007fff23d9b8a4</span> CoreFoundation`CFRunLoopRunSpecific + <span class="number">404</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x00007fff25957c71</span> Foundation`-[NSRunLoop(NSRunLoop) runMode:beforeDate:] + <span class="number">211</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00007fff25957e85</span> Foundation`-[NSRunLoop(NSRunLoop) run] + <span class="number">76</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000109013254</span> Interview01-runloop流程`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="number">0x00006000022fe3d0</span>) at ViewController.m:<span class="number">48</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x000000010927af11</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x000000010927be8e</span> libdispatch.dylib`_dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x000000010927e2d8</span> libdispatch.dylib`_dispatch_queue_override_invoke + <span class="number">1022</span></span><br><span class="line">    frame #<span class="number">13</span>: <span class="number">0x000000010928d399</span> libdispatch.dylib`_dispatch_root_queue_drain + <span class="number">351</span></span><br><span class="line">    frame #<span class="number">14</span>: <span class="number">0x000000010928dca6</span> libdispatch.dylib`_dispatch_worker_thread2 + <span class="number">135</span></span><br><span class="line">    frame #<span class="number">15</span>: <span class="number">0x00007fff522b39f7</span> libsystem_pthread.dylib`_pthread_wqthread + <span class="number">220</span></span><br><span class="line">    frame #<span class="number">16</span>: <span class="number">0x00007fff522b2b77</span> libsystem_pthread.dylib`start_wqthread + <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>可以看出触发的是 timer。</p>
<p>再来看下 <code>[self performSelector:@selector(test5) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</code>的调用栈：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* thread #<span class="number">4</span>, queue = <span class="string">'com.apple.root.default-qos'</span>, stop reason = breakpoint <span class="number">2.1</span></span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001090133b7</span> Interview01-runloop流程`-[ViewController test5](self=<span class="number">0x00007fd80c40b680</span>, _cmd=<span class="string">"test5"</span>) at ViewController.m:<span class="number">70</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff2596de42</span> Foundation`__NSThreadPerformPerform + <span class="number">209</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x00007fff23da1c91</span> CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + <span class="number">17</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00007fff23da1bbc</span> CoreFoundation`__CFRunLoopDoSource0 + <span class="number">76</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00007fff23da1394</span> CoreFoundation`__CFRunLoopDoSources0 + <span class="number">180</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x00007fff23d9bf8e</span> CoreFoundation`__CFRunLoopRun + <span class="number">974</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00007fff23d9b8a4</span> CoreFoundation`CFRunLoopRunSpecific + <span class="number">404</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x00007fff25957c71</span> Foundation`-[NSRunLoop(NSRunLoop) runMode:beforeDate:] + <span class="number">211</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00007fff25957e85</span> Foundation`-[NSRunLoop(NSRunLoop) run] + <span class="number">76</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000109013254</span> Interview01-runloop流程`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="number">0x00006000022fe3d0</span>) at ViewController.m:<span class="number">48</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x000000010927af11</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x000000010927be8e</span> libdispatch.dylib`_dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x000000010927e2d8</span> libdispatch.dylib`_dispatch_queue_override_invoke + <span class="number">1022</span></span><br><span class="line">    frame #<span class="number">13</span>: <span class="number">0x000000010928d399</span> libdispatch.dylib`_dispatch_root_queue_drain + <span class="number">351</span></span><br><span class="line">    frame #<span class="number">14</span>: <span class="number">0x000000010928dca6</span> libdispatch.dylib`_dispatch_worker_thread2 + <span class="number">135</span></span><br><span class="line">    frame #<span class="number">15</span>: <span class="number">0x00007fff522b39f7</span> libsystem_pthread.dylib`_pthread_wqthread + <span class="number">220</span></span><br><span class="line">    frame #<span class="number">16</span>: <span class="number">0x00007fff522b2b77</span> libsystem_pthread.dylib`start_wqthread + <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>这次触发的是 source0。</p>
<h4 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h4><p>我们知道当线程在执行完当前任务后就会退出，那么如果想要线程在执行完任务后依然保留，当我们彻底不需要时再将线程退出。这个时候就需要使用 RunLoop 来做到线程保活，我们自己来控制线程的生命周期。</p>
<p>来做个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface XFThread : NSThread</span><br><span class="line">@end</span><br><span class="line">@implementation XFThread</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) XFThread * thread;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.thread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;---- tread begin -----&quot;);</span><br><span class="line">      </span><br><span class="line">        NSLog(@&quot;---- tread end -----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    [self performSelector:@selector(threadAction) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadAction &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当 push 进 ViewController 时，可以看到 thread 的 begin、end 都已经打印完，此时当我们点击屏幕的时候，并没有走 <code>threadAction</code>方法，而当把 waitUntilDone 参数设置为 YES 时，会直接报出坏内存访问的 crash，因为线程在 start 时已经执行完任务了，这条线程已经是一个没用的线程，不能再用来执行任务了。</p>
<p>这是就需要用到了 RunLoop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    self.thread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;---- tread begin -----&quot;);</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line"> </span><br><span class="line">        NSLog(@&quot;---- tread end -----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)stop:(id)sender &#123;</span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopThread &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加 RunLoop 后再增加一个 stop 按钮，当点击 stop 时，我们发现并没有执行 tread end。这是因为 run 方法导致的，来看下 run 方法的官方解释：</p>
<blockquote>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the <code>NSDefaultRunLoopMode</code> by repeatedly invoking <a href="apple-reference-documentation://hcGlc34FMW" target="_blank" rel="noopener"><code>runMode:beforeDate:</code></a>. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers. </p>
<p>Manually removing all known input sources and timers from the run loop is not a guarantee that the run loop will exit. macOS can install and remove additional input sources as needed to process requests targeted at the receiver’s thread. Those sources could therefore prevent the run loop from exiting. </p>
<p>If you want the run loop to terminate, you shouldn’t use this method. Instead, use one of the other run methods and also check other arbitrary conditions of your own, in a loop. A simple example would be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BOOL shouldKeepRunning = YES; // global</span><br><span class="line">&gt; NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">&gt; while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>where <code>shouldKeepRunning</code> is set to <code>NO</code> somewhere else in the program.</p>
</blockquote>
<p>可以看到 run 方法是用来设置永不销毁的线程的，如果想要控制线程的生命周期，需要使用 example 里面的方法。来试下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) XFThread * thread;</span><br><span class="line">@property (nonatomic, assign, getter=isStoped) BOOL stoped;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    typeof(self) __weak weakSelf = self;</span><br><span class="line">    self.stoped = NO;</span><br><span class="line">    </span><br><span class="line">    self.thread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;---- tread begin -----&quot;);</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        while (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;---- tread end -----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadAction &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)stop:(id)sender &#123;</span><br><span class="line">    if (!self.thread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopThread &#123;</span><br><span class="line">    self.stoped = YES;</span><br><span class="line"></span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line"></span><br><span class="line">    self.thread = nil;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    if (!self.thread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(threadAction) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但此时直接退出界面或者主动触发 stop，会出现 crash，因为此时 stopThread 和 dealloc 方法是同事进行的，这里需要保证先执行 stopTread，然后在执行 dealloc。所以这里需要把 waitUntilDone 方法设置为 YES：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)stop:(id)sender &#123;</span><br><span class="line">    if (!self.thread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完美解决~</p>
<p>简单来封装下 thread：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">@interface XFThread : NSThread</span><br><span class="line">@end</span><br><span class="line">@implementation XFThread</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@interface XFPermenentThread : NSObject</span><br><span class="line">- (void)stop;</span><br><span class="line">- (void)executeTask:(dispatch_block_t)task;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface XFPermenentThread ()</span><br><span class="line">@property (nonatomic, strong) XFThread * innerThread;</span><br><span class="line">@property (nonatomic, assign, getter=isStopped) BOOL stopped;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XFPermenentThread</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.stopped = NO;</span><br><span class="line">        </span><br><span class="line">        typeof(self) __weak weakSelf = self;</span><br><span class="line">        </span><br><span class="line">        self.innerThread = [[XFThread alloc] initWithBlock:^&#123;</span><br><span class="line">            </span><br><span class="line">            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">            </span><br><span class="line">            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [self.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stop &#123;</span><br><span class="line">    if (!self.innerThread) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)executeTask:(dispatch_block_t)task &#123;</span><br><span class="line">    if (!self.innerThread || !task) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__stop &#123;</span><br><span class="line">    self.stopped = YES;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    self.innerThread = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__executeTask:(dispatch_block_t)task &#123;</span><br><span class="line">    !task ? : task();</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>至此我们可以做到手动控制一条线程的生命周期。</p>
<h3 id="参考-："><a href="#参考-：" class="headerlink" title="参考 ："></a>参考 ：</h3><ol>
<li>YY 大神：<a href="https://blog.ibireme.com/2015/05/18/runloop/#more-41710" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/#more-41710</a></li>
<li>官方源码：<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></li>
</ol>
</div><div class="tags"><a href="/tags/RunLoop/"><i class="fa fa-tag"></i>RunLoop</a></div><div class="post-nav"><a class="pre" href="/2020/08/05/多线程/">多线程</a><a class="next" href="/2020/07/20/Runtime原理探究/">Runtime原理探究</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/KVC/" style="font-size: 15px;">KVC</a> <a href="/tags/block-变量捕获/" style="font-size: 15px;">block 变量捕获</a> <a href="/tags/block-类型、copy/" style="font-size: 15px;">block 类型、copy</a> <a href="/tags/block-循环引用/" style="font-size: 15px;">block 循环引用</a> <a href="/tags/block/" style="font-size: 15px;">block</a> <a href="/tags/category-原理/" style="font-size: 15px;">category 原理</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/KVO/" style="font-size: 15px;">KVO</a> <a href="/tags/block-原理/" style="font-size: 15px;">block 原理</a> <a href="/tags/block-内存管理/" style="font-size: 15px;">block 内存管理</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/内存管理、RunLoop、Autorelease/" style="font-size: 15px;">内存管理、RunLoop、Autorelease</a> <a href="/tags/内存管理/" style="font-size: 15px;">内存管理</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/内存管理原理探究-续/">内存管理原理探究-续</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/内存管理原理探究/">内存管理原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/多线程/">多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/RunLoop原理探究/">RunLoop原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/20/Runtime原理探究/">Runtime原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block6-循环引用/">block6-循环引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block5-block内存管理/">block5-block内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/block3-block原理/">block4-__block原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block3-类型、copy原理/">block3-类型、copy原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block2-变量的捕获/">block2-变量的捕获</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/jueying-xiangfeng" title="github" target="_blank">github</a><ul></ul><a title="生活随笔-复盘(最近正在整理)" target="_blank">生活随笔-复盘(最近正在整理)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">白夜追凶.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>