<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Runtime原理探究 | 白夜追凶</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Runtime原理探究</h1><a id="logo" href="/.">白夜追凶</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Runtime原理探究</h1><div class="post-meta">2020年07月20日</div><div class="post-content"><blockquote>
<p>原计划一周一个模块，但是看到 runTime 这里持续时间有点长，底层内容很多啊，原因还是之前基础太差，菜的抠脚。。。还有整理完 block 后再想 block hook 应该怎么实现，瞎搞了一通最后找到了开源的库 <code>blockHook</code>，看了几天的源码发现底层掌握的还是不牢，其中包括 runtime 部分，先整理完 runtime 部分然后再回头重新分析 blockHook。</p>
</blockquote>
<p>下文内容是根据 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a> 版本分析的，目前最新版本是 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-781</a>，最新版本做了一些优化，不过不影响我们理解。</p>
<h3 id="1、isa-详解"><a href="#1、isa-详解" class="headerlink" title="1、isa 详解"></a>1、isa 详解</h3><p>在 arm64 结构之前，isa 就是一个普通指针，存储着 Class、Meta-Class 对象的内存地址。</p>
<p>从 arm64 结构开始，对 isa 进行了优化，变成了一个共用体（union）结构，使用位域来存储更多信息</p>
<p>更多信息是指 isa 除了存储对象内存地址外还存储了其他的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL  </span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33;</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>nonpointer：0 代表普通指针，存储着 Class、Meta-Class 对象的内存地址，1 代表优化过，使用位域存储更对信息</li>
<li>has_assoc：是否有设置过关联对象，如果没有释放时更快</li>
<li>has_cxx_dtor：是否有 C++ 的析构函数（.cxx_destruct），如果没有释放时更快</li>
<li>shiftcls：存储着 Class、Meta-Class 对象的内存地址信息</li>
<li>magic：用于在调试时分辨对相关是否完成初始化</li>
<li>weakly_referenced：是否有被弱引用指向过，如果没有，释放更快</li>
<li>deallocating： 对象是否正在释放</li>
<li>has_sidetable_rc：引用计数器是否过大无法存储在isa中。1标识引用计数会存储在side table的类属性中</li>
<li>extra_rc：里面存储的值是引用计数器减1</li>
</ul>
<p>这里可以简单看一下实例对象 isa 指针里面存储的类，我们这里只研究 arm64 架构，可以看到上面有 ISA_MASK，这个是用来取 Class、Meta-Class 对象的内存地址的，来个小实验：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"--- %p"</span>, [ViewController <span class="class"><span class="keyword">class</span>]);</span></span><br><span class="line"></span><br><span class="line">结果<span class="symbol">:</span></span><br><span class="line">--- <span class="number">0x1000b1cf0</span></span><br><span class="line"></span><br><span class="line">再来打印 <span class="keyword">self</span> 的 isa：</span><br><span class="line">(lldb) p/x <span class="keyword">self</span>-&gt;isa</span><br><span class="line">(Class) $0 = <span class="number">0x000005a1000b1cf7</span> ViewController</span><br><span class="line"></span><br><span class="line">可以看到上面的两个地址是不一样的，根据上面的结构，我们使用 ISA_MASK 来取一下 isa 中关于对象的内存地址：</span><br><span class="line">(lldb) p/x <span class="number">0x000005a1000b1cf7</span> &amp; <span class="number">0x0000000ffffffff8</span>ULL</span><br><span class="line">(unsigned long long) $1 = <span class="number">0x00000001000b1cf0</span></span><br><span class="line"></span><br><span class="line">由上可以看到，由 isa 取出来的地址和 ViewController <span class="class"><span class="keyword">class</span> 类的真实地址是一样的。</span></span><br></pre></td></tr></table></figure>
<p>关于上述标记位中更快释放，可以再 objc4 里面看到源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，在 dealloc 时会分别获取是否有关联对象、析构函数、弱指针等标记位，如果没有是直接释放的，否则会调用相关的方式释放对应的资源。</p>
<h3 id="2、Class-结构"><a href="#2、Class-结构" class="headerlink" title="2、Class 结构"></a>2、Class 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bits &amp; FAST_DATA_MASK 可以拿到 class_rw_t</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>class_rw_t 里面的 methods、properties、protocols 是二维数组，是可读可写的，包含类的初始内容、分类的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">method_array_t</span> :</span> </span><br><span class="line">	<span class="keyword">public</span> list_array_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> list_array_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>&gt; Super;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Class_ro_t 里面的 baseMethodList、baseProtocols、ivars、baseProperties 是一维数组，是只读的，包含了类的初始信息。</p>
<p>下面来看下 method_t 的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;	// 函数名</span><br><span class="line">    const char *types;	// 编码（返回值类型、参数类型）</span><br><span class="line">    IMP imp; // 指向函数的指针（函数地址）</span><br><span class="line"></span><br><span class="line">    struct SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;const method_t&amp;,</span><br><span class="line">                                    const method_t&amp;, bool&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator() (const method_t&amp; lhs,</span><br><span class="line">                         const method_t&amp; rhs)</span><br><span class="line">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IMP 代表函数的具体实现：</p>
<p><code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p>
<p>SEL 代表方法\函数名，一般称作选择器，底层结构和 char* 类型</p>
<ul>
<li>可以通过 @selector() 和 sel_registerName() 获得</li>
<li>可以通过 sel_getName() 和 NSStringFromSelector() 转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
<p><code>typedef struct objc_selector *SEL;</code></p>
<p>types 是包含了函数返回值、参数编码的字符串</p>
<h3 id="3、方法缓存"><a href="#3、方法缓存" class="headerlink" title="3、方法缓存"></a>3、方法缓存</h3><p>Class 内部结构用有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key; // SEL 作为 key</span><br><span class="line">    IMP _imp;	// 函数的内存地址</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets; // 散列表</span><br><span class="line">    mask_t _mask;	// 散列表长度 - 1</span><br><span class="line">    mask_t _occupied; // 已经缓存的方法数量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t occupied();</span><br><span class="line">    void incrementOccupied();</span><br><span class="line">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class="line">    void initializeToEmpty();</span><br><span class="line"></span><br><span class="line">    mask_t capacity();</span><br><span class="line">    bool isConstantEmptyCache();</span><br><span class="line">    bool canBeFreed();</span><br><span class="line"></span><br><span class="line">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class="line">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    void expand();</span><br><span class="line">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class="line">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看下获取 cache 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 如果 i为0则从mask开始查找（mask为表长度-1），如果i不为空则从i-1开始查找</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = mask();</span><br><span class="line">    mask_t begin = cache_hash(k, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    // hack</span><br><span class="line">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>散列表扩容，从源码可以看到，每次扩容都是原来容积的两倍，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity = capacity();</span><br><span class="line">    uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    if ((uint32_t)(mask_t)newCapacity != newCapacity) &#123;</span><br><span class="line">        // mask overflow - can&apos;t grow further</span><br><span class="line">        // fixme this wastes one bit of mask</span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、objc-msgSend-执行流程"><a href="#4、objc-msgSend-执行流程" class="headerlink" title="4、objc_msgSend 执行流程"></a>4、objc_msgSend 执行流程</h3><h4 id="第一个阶段-消息发送"><a href="#第一个阶段-消息发送" class="headerlink" title="第一个阶段 - 消息发送"></a>第一个阶段 - 消息发送</h4><p>看一下下面的经典调用图片</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/oc-class.png" alt="oc-class.png"></p>
<p>下面看下消息发送的流程：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.png" alt="消息发送"></p>
<h4 id="第二个阶段-动态方法解析"><a href="#第二个阶段-动态方法解析" class="headerlink" title="第二个阶段 - 动态方法解析"></a>第二个阶段 - 动态方法解析</h4><p>调用流程如下：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90.png" alt="动态方法解析"></p>
<p>这里可以从 objc 的源码里面查到（lookUpImpOrForward 方法）：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    _class_resolveMethod(<span class="keyword">cls</span>, sel, inst);</span><br><span class="line">    runtimeLock.read();</span><br><span class="line">    <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">    <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line"><span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">cache_fill(<span class="keyword">cls</span>, sel, imp, inst);</span><br></pre></td></tr></table></figure>
<p>可以看到标记位 triedResolver 和我们流程图里面对应。</p>
<h4 id="第三个阶段-消息转发"><a href="#第三个阶段-消息转发" class="headerlink" title="第三个阶段 - 消息转发"></a>第三个阶段 - 消息转发</h4><p>看下流程图：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/runtime/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="消息转发"></p>
<p>由于消息转发阶段没有开源，这里在网上扒出大神整理的伪代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">    <span class="keyword">id</span> receiver = *(<span class="keyword">id</span> *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        <span class="keyword">id</span> forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStret == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 僵尸对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(receiverClass);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *zombiePrefix = <span class="string">"_NSZombie_"</span>;</span><br><span class="line">    size_t prefixLen = strlen(zombiePrefix); <span class="comment">// 0xa</span></span><br><span class="line">    <span class="keyword">if</span> (strncmp(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelError,</span><br><span class="line">              <span class="string">@"*** -[%s %s]: message sent to deallocated instance %p"</span>,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(methodSignatureForSelector:))) &#123;</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">                <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">                      <span class="string">@"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s."</span>,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? <span class="string">""</span> : not,</span><br><span class="line">                      isStret ? <span class="string">""</span> : not);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (class_respondsToSelector(receiverClass, <span class="keyword">@selector</span>(forwardInvocation:))) &#123;</span><br><span class="line">                <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">                      <span class="string">@"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message"</span>,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selector 是否已经在 Runtime 注册过</span></span><br><span class="line">    <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort"</span>,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; <span class="comment">// doesNotRecognizeSelector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass,<span class="keyword">@selector</span>(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFLog</span>(kCFLogLevelWarning ,</span><br><span class="line">              <span class="string">@"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort"</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The point of no return.</span></span><br><span class="line">    kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、Super-本质"><a href="#5、Super-本质" class="headerlink" title="5、Super 本质"></a>5、Super 本质</h3><h4 id="super-本质调用"><a href="#super-本质调用" class="headerlink" title="super 本质调用"></a>super 本质调用</h4><p>了解完 objc_msgSend 机制再来看下 super 的本质。</p>
<p>做个测试，重写 forwardInvocation 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用 clang 查看转换成的 c++ 代码</span><br><span class="line"></span><br><span class="line">((void (*)(__rw_objc_super *, SEL, NSInvocation *))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;MJPerson&quot;))&#125;, sel_registerName(&quot;forwardInvocation:&quot;), (NSInvocation *)anInvocation);</span><br><span class="line"></span><br><span class="line">删除强制转换：</span><br><span class="line">    objc_msgSendSuper(</span><br><span class="line">                      &#123;self, (id)class_getSuperclass(objc_getClass(&quot;MJPerson&quot;))&#125;,</span><br><span class="line">                      sel_registerName(&quot;forwardInvocation:&quot;),</span><br><span class="line">                      anInvocation);</span><br></pre></td></tr></table></figure>
<p>如上，使用 super 调用方法的时候不再是 objc_msgSend，而是 objc_msgSendSuper，发送消息时有三个参数：</p>
<ol>
<li>结构体 struct __rw_objc_super</li>
<li>方法名 SEL</li>
<li>参数 anInvocation</li>
</ol>
<p>这里主要看下第一个参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__rw_objc_super</span></span> &#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *object; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *superClass; </span><br><span class="line">	__rw_objc_super(<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *o, <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span></span> *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据上面  objc_msgSendSuper 初始化的调用可以看到，super 的实质其实还是向 self 发送消息，receiver 依然是 self，只不过第二个参数是 superClass。</p>
<p>所以 super 的本质就是向 self（receiver）发送消息，不过查找方法时是从 super 开始查找。</p>
<p>其实这里看到的也并非最终的调用方式，通过源码或者汇编代码，或者用 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">这里</a> 调试查看，最终 super 生成的结构是：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct </span>objc_super2 &#123;</span><br><span class="line">    id receiver<span class="comment">;</span></span><br><span class="line">    Class current_class<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">ENTRY</span> _objc_msgSendSuper2</span><br><span class="line"></span><br><span class="line"><span class="keyword">ldr	</span><span class="built_in">r9</span>, [<span class="built_in">r0</span>, <span class="symbol">#CLASS</span>]	// class = <span class="keyword">struct </span>super-&gt;class</span><br><span class="line">// 通过 current_class 找到 superClass</span><br><span class="line"><span class="keyword">ldr	</span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="symbol">#SUPERCLASS</span>]   // class = class-&gt;superclass</span><br><span class="line"><span class="symbol">CacheLookup</span> NORMAL, _objc_msgSendSuper2</span><br><span class="line">// cache hit, IMP in <span class="built_in">r12</span>, eq already set for nonstret forwarding</span><br><span class="line"><span class="keyword">ldr	</span><span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="symbol">#RECEIVER</span>]	// load real receiver</span><br><span class="line"><span class="keyword">bx	</span><span class="built_in">r12</span>			// call imp</span><br><span class="line"></span><br><span class="line"><span class="symbol">CacheLookup2</span> NORMAL, _objc_msgSendSuper2</span><br><span class="line">// cache miss</span><br><span class="line"><span class="keyword">ldr	</span><span class="built_in">r9</span>, [<span class="built_in">r0</span>, <span class="symbol">#CLASS</span>]	// class = <span class="keyword">struct </span>super-&gt;class</span><br><span class="line"><span class="keyword">ldr	</span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="symbol">#SUPERCLASS</span>]   // class = class-&gt;superclass</span><br><span class="line"><span class="keyword">ldr	</span><span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="symbol">#RECEIVER</span>]	// load real receiver</span><br><span class="line"><span class="keyword">b	</span>__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line"><span class="symbol">END_ENTRY</span> _objc_msgSendSuper2</span><br></pre></td></tr></table></figure>
<p>不管是 objc_super 还是 objc_super2，对这里的理解是没有影响的，消息的接收者就是 self，不过查找方法是从 superClass 开始查找的。</p>
<h4 id="结合消息发送机制对-super-调用方法的疑问"><a href="#结合消息发送机制对-super-调用方法的疑问" class="headerlink" title="结合消息发送机制对 super 调用方法的疑问"></a>结合消息发送机制对 super 调用方法的疑问</h4><blockquote>
<p>昨天写到 super 的时候突然想到了一个问题，就是 super 的本质是：消息接受者为 self，不过查找方法是在 superClass 开始查找，根据消息发送机制，查找到方法后会将 IMP 存入到 bucket 里面。</p>
<p>注意：这里的 bucket 是哪个 cls 的呢？</p>
<p>由于对上面 【4、消息发送】那张经典图片理解的不够，认为查找到目标方法后就是把对应的方法放到 receiver 的 cache_t 里面，结果就有了下面的这个猜想。。。</p>
</blockquote>
<p>猜想是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">- (void)studentTest;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">- (void)studentTest &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface GoodStudent : Student</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation GoodStudent</span><br><span class="line">- (void)studentTest &#123;</span><br><span class="line">    [super studentTest];</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    [super studentTest];</span><br><span class="line">    [self studentTest];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如上我们使用 GoodStudent 实例调用 test 方法，</p>
<ol>
<li>当调用完 <code>[super studentTest];</code>后，GoodStudent 的 cache_t 里面就应该有了<code>studentTest</code>方法的缓存</li>
<li>当执行 <code>[self studentTest];</code>时，根据消息发送机制，在缓存中查找到了第一步调用的缓存，也就是 superClass 的方法缓存</li>
<li>所以结果就是只要缓存还在就不会调用到 self 的 <code>studentTest</code> 方法</li>
</ol>
<p>看完我的猜想是不是感觉很扯，但是就这困惑了我很久，从昨天晚上开始查资料，一直到今天早上早早来公司，看了半天 objc 的源码才找到答案，其实答案已经看过很多遍，不过由于根据网络上面各种文章的洗脑，从来没有静下心来一句一句的分析 objc 的源码，现在来看下这个很扯的想法是怎样被推翻的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 1、执行 [super studentTest]; </span><br><span class="line">// 2、会调用 lookUpImpOrForward 方法，注意：inst 就是 receiver(self)，cls 就是 superClass</span><br><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line"></span><br><span class="line">// 3、查找到方法后会调用 log_and_fill_cache，这里 receiver 就是 self，cls 为 superClass</span><br><span class="line">static void</span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line"></span><br><span class="line">// 4、调用 cache_fill 方法</span><br><span class="line">// 看下缓存的 cache_t 是在 cls 里面取出来的，而将 imp 缓存到 cache 时会调用 cache-&gt;insert</span><br><span class="line">void cache_fill(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    if (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cache_t *cache = getCache(cls);</span><br><span class="line">        cache-&gt;insert(cls, sel, imp, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 5、cache-&gt;insert 方法</span><br><span class="line">// 注意这里 set 缓存时，是放在了 cls 里面，而 receiver 的作用就是在设置缓存失败时接收消息，这就对上了，因为self 本来就是单纯的 receiver，和方法的缓存没有关系，这里方法的缓存只和 cls 有关</span><br><span class="line">void cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    // Use the cache as-is if it is less than 3/4 full</span><br><span class="line">    mask_t newOccupied = occupied() + 1;</span><br><span class="line">    unsigned oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    if (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        // Cache is read-only. Replace it.</span><br><span class="line">        if (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class="line">        reallocate(oldCapacity, capacity, /* freeOld */false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (fastpath(newOccupied &lt;= capacity / 4 * 3)) &#123;</span><br><span class="line">        // Cache is less than 3/4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;</span><br><span class="line">        if (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        reallocate(oldCapacity, capacity, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - 1;</span><br><span class="line">    mask_t begin = cache_hash(sel, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line"></span><br><span class="line">    // Scan for the first unused slot and insert there.</span><br><span class="line">    // There is guaranteed to be an empty slot because the</span><br><span class="line">    // minimum size is 4 and we resized at 3/4 full.</span><br><span class="line">    do &#123;</span><br><span class="line">        if (fastpath(b[i].sel() == 0)) &#123;</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(sel, imp, cls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b[i].sel() == sel) &#123;</span><br><span class="line">            // The entry was added to the cache by some other thread</span><br><span class="line">            // before we grabbed the cacheUpdateLock.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (fastpath((i = cache_next(i, m)) != begin));</span><br><span class="line"></span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)sel, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6、经过上面分析，在调用 [self studentTest]; 时，会先从 self.class 里面查找缓存，此时是没有的，因为 super 调用时缓存是在 superClass 里面的，所以这里会从新走消息发送的流程。</span><br></pre></td></tr></table></figure>
<p>扯归扯，但是这里一定要清楚这里的方法查找和缓存是针对 cls 的。</p>
<p>关于这个很扯问题的分析使用的是 objc 最新的代码版本（781），和之前的版本是有一些不同的，关于最新版本 objc 的优化项可以看<a href="https://mp.weixin.qq.com/s/47fSMCwhl8KwhVWk9uRoag" target="_blank" rel="noopener">这里</a>。 </p>
<h3 id="6、几个-runtime-相关的应用"><a href="#6、几个-runtime-相关的应用" class="headerlink" title="6、几个 runtime 相关的应用"></a>6、几个 runtime 相关的应用</h3><h4 id="常用的几个类的实现"><a href="#常用的几个类的实现" class="headerlink" title="常用的几个类的实现"></a>常用的几个类的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    return self-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return [self class]-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return self-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的有两个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 1、isKindOfClass 与 isMemberOfClass 的区别</span><br><span class="line">-+ (BOOL)isKindOfClass:(Class)cls;</span><br><span class="line">-+ (BOOL)isMemberOfClass:(Class)cls;</span><br><span class="line"></span><br><span class="line">// 2、object_getClass 与 objc_getClass 的区别</span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class objc_getClass(const char *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    if (!aClassName) return Nil;</span><br><span class="line"></span><br><span class="line">    // NO unconnected, YES class handler</span><br><span class="line">    return look_up_class(aClassName, NO, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="经典的-hook-实现"><a href="#经典的-hook-实现" class="headerlink" title="经典的 hook 实现"></a>经典的 hook 实现</h4><p>创建两个测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Animal</span><br><span class="line">- (void)animalTest &#123;</span><br><span class="line">    NSLog(@&quot;Animal test&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Person : Animal</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self, @selector(animalTest));</span><br><span class="line">        Method swizzlingMethod = class_getInstanceMethod(self, @selector(hook_animalTest));</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hook_animalTest &#123;</span><br><span class="line">    NSLog(@&quot;hook_animalTest test&quot;);</span><br><span class="line">    [self hook_animalTest];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // 测试 1</span><br><span class="line">        Person * p = [[Person alloc] init];</span><br><span class="line">        [p animalTest];</span><br><span class="line">      </span><br><span class="line">        // 测试 2</span><br><span class="line">        Animal * a = [[Animal alloc] init];</span><br><span class="line">        [a animalTest];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，我们 hook <code>animalTest</code>方法，然后运行</p>
<p>测试1 可以看到如下打印：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020<span class="selector-tag">-07-22</span> 14<span class="selector-pseudo">:53</span><span class="selector-pseudo">:25.496785+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[75368:2985804]</span> <span class="selector-tag">hook_animalTest</span> <span class="selector-tag">test</span></span><br><span class="line">2020<span class="selector-tag">-07-22</span> 14<span class="selector-pseudo">:53</span><span class="selector-pseudo">:25.500559+0800</span> <span class="selector-tag">debug-objc</span><span class="selector-attr">[75368:2985804]</span> <span class="selector-tag">Animal</span> <span class="selector-tag">test</span></span><br></pre></td></tr></table></figure>
<p>但是到测试2 的时候程序程序挂掉了，可以看下crash信息：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2020-07-22 14:54:43.493195+0800 debug-objc[75425:2989235] hook_animalTest test</span><br><span class="line">2020-07-22 14:54:43.493866+0800 debug-objc[75425:2989235] Animal test</span><br><span class="line">2020-07-22 14:54:45.558115+0800 debug-objc[75425:2989235] hook_animalTest test</span><br><span class="line">2020-07-22 14:54:45.558828+0800 debug-objc[75425:2989235] -[Animal hook_animalTest]: unrecognized selector sent to<span class="built_in"> instance </span>0x1019183a0</span><br><span class="line">2020-07-22 14:54:45.563992+0800 debug-objc[75425:2989235] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Animal hook_animalTest]: unrecognized selector sent to<span class="built_in"> instance </span>0x1019183a0'</span><br><span class="line">*** First<span class="built_in"> throw </span>call stack:</span><br><span class="line">(</span><br><span class="line">	0   CoreFoundation                      0x00007fff374ffbe7 __exceptionPreprocess + 250</span><br><span class="line">	1   libobjc.A.dylib                     0x000000010038f350 objc_exception_throw + 48</span><br><span class="line">	2   CoreFoundation                      0x00007fff3757ec77 -[NSObject(NSObject) __retain_OA] + 0</span><br><span class="line">	3   CoreFoundation                      0x00007fff3746444b ___forwarding___ + 1427</span><br><span class="line">	4   CoreFoundation                      0x00007fff37463e28 _CF_forwarding_prep_0 + 120</span><br><span class="line">	5   debug-objc                          0x0000000100001bfd -[Person hook_animalTest] + 61</span><br><span class="line">	6   debug-objc                          0x0000000100001c9d main + 141</span><br><span class="line">	7   libdyld.dylib                       0x00007fff7147ecc9 start + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure>
<p>为什么会出现这种情况呢？</p>
<p>来分析下 <code>method_exchangeImplementations</code>其实就是交换两个方法的 IMP，由于 <code>animalTest</code>方法是在父类 Animal 里面，所以在子类 Person 要交换方法时，其实交换的是父类 Animal 里面的方法实现，这种情况对子类Person是没有影响的，完全可以达到 hook 的目的，但是对父类 Animal 就不一样了，因为这种方法直接替换了父类的实现，当父类在调用 <code>animalTest</code>时其实最终就是在调用子类的 <code>hook_animalTest</code>，因为两个方法的IMP已经交换了，然后子类里面在执行 <code>[self hook_animalTest]</code>时，此时的 self 是 Animal，意思是向 Animal 发送 <code>hook_animalTest</code>的消息，根据我们上面分析的消息发送机制可以得到这里必然会出现这个经典的crash <code>**unrecognized selector sent to instance</code>。</p>
<p>为了解决上面的隐藏问题，我们来看下 hook 的正确姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self, @selector(animalTest));</span><br><span class="line">        Method swizzlingMethod = class_getInstanceMethod(self, @selector(hook_animalTest));</span><br><span class="line">        </span><br><span class="line">        // 如果返回 YES 则证明当前类没有这个方法，也就是说该方法可能在父类里面，所以需要将我们最终目标的 method 添加到 Person 里面，并且将 Person 的 hook_animalTest 方法与原来 method 互换。</span><br><span class="line">        // 如果返回 NO 则证明当前类有这个方法，直接交换就好</span><br><span class="line">        BOOL addResult = class_addMethod(self,</span><br><span class="line">                                         method_getName(originalMethod),</span><br><span class="line">                                         method_getImplementation(swizzlingMethod),</span><br><span class="line">                                         method_getTypeEncoding(swizzlingMethod));</span><br><span class="line">        if (addResult) &#123;</span><br><span class="line">            class_replaceMethod(self,</span><br><span class="line">                                method_getName(swizzlingMethod),</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下 objc 源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">BOOL </span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return NO;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line">    // addMethod返回的 IMP == nil ? YES : NO</span><br><span class="line">    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static IMP </span><br><span class="line">addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)</span><br><span class="line">&#123;</span><br><span class="line">    IMP result = nil;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    </span><br><span class="line">    ASSERT(types);</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    method_t *m;</span><br><span class="line">  </span><br><span class="line">    // 1、如果 cls 里面有 name 对应的 method，则直接返回对应的 IMP</span><br><span class="line">    if ((m = getMethodNoSuper_nolock(cls, name))) &#123;</span><br><span class="line">        // already exists</span><br><span class="line">        if (!replace) &#123;</span><br><span class="line">            result = m-&gt;imp;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = _method_setImplementation(cls, m, imp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 2、如果没有，则将 hook 的方法添加到 cls 中</span><br><span class="line">        method_list_t *newlist;</span><br><span class="line">        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);</span><br><span class="line">        newlist-&gt;entsizeAndFlags = </span><br><span class="line">            (uint32_t)sizeof(method_t) | fixed_up_method_list;</span><br><span class="line">        newlist-&gt;count = 1;</span><br><span class="line">        newlist-&gt;first.name = name;</span><br><span class="line">        newlist-&gt;first.types = strdupIfMutable(types);</span><br><span class="line">        newlist-&gt;first.imp = imp;</span><br><span class="line"></span><br><span class="line">        prepareMethodLists(cls, &amp;newlist, 1, NO, NO);</span><br><span class="line">        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1);</span><br><span class="line">        flushCaches(cls);</span><br><span class="line"></span><br><span class="line">        result = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下 replace 源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 可以看出和 class_addMethod 源码调用的是同一个方法，只不过给 addMethod 的最后一个参数：replace 传的 YES</span><br><span class="line">IMP </span><br><span class="line">class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line"></span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line">    return addMethod(cls, name, imp, types ?: &quot;&quot;, YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 replace 为 YES是走的 _method_setImplementation 方法</span><br><span class="line">// 可以看出这里就是替换了 method_t 的 IMP</span><br><span class="line">static IMP </span><br><span class="line">_method_setImplementation(Class cls, method_t *m, IMP imp)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    if (!m) return nil;</span><br><span class="line">    if (!imp) return nil;</span><br><span class="line"></span><br><span class="line">    IMP old = m-&gt;imp;</span><br><span class="line">    m-&gt;imp = imp;</span><br><span class="line"></span><br><span class="line">    // Cache updates are slow if cls is nil (i.e. unknown)</span><br><span class="line">    // RR/AWZ updates are slow if cls is nil (i.e. unknown)</span><br><span class="line">    // fixme build list of classes whose Methods are known externally?</span><br><span class="line"></span><br><span class="line">    flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    adjustCustomFlagsForMethodChange(cls, m);</span><br><span class="line"></span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考神经病院系列："><a href="#参考神经病院系列：" class="headerlink" title="参考神经病院系列："></a>参考神经病院系列：</h3><ol>
<li><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="noopener">https://halfrost.com/objc_runtime_isa_class/</a></li>
<li><a href="https://halfrost.com/objc_runtime_objc_msgsend/" target="_blank" rel="noopener">https://halfrost.com/objc_runtime_objc_msgsend/</a></li>
<li><a href="https://halfrost.com/how_to_use_runtime/" target="_blank" rel="noopener">https://halfrost.com/how_to_use_runtime/</a></li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/07/29/RunLoop原理探究/">RunLoop原理探究</a><a class="next" href="/2020/07/06/block6-循环引用/">block6-循环引用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/内存管理、RunLoop、Autorelease/" style="font-size: 15px;">内存管理、RunLoop、Autorelease</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/内存管理原理探究-续/">内存管理原理探究-续</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/内存管理原理探究/">内存管理原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/多线程/">多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/RunLoop原理探究/">RunLoop原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/20/Runtime原理探究/">Runtime原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block6-循环引用/">block6-循环引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block5-block内存管理/">block5-block内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/block3-block原理/">block4-__block原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block3-类型、copy原理/">block3-类型、copy原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block2-变量的捕获/">block2-变量的捕获</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">白夜追凶.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>