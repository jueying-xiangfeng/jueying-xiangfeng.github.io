<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>内存管理原理探究 | 白夜追凶</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">内存管理原理探究</h1><a id="logo" href="/.">白夜追凶</a><p class="description">Talk is cheap. Show me the code.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">内存管理原理探究</h1><div class="post-meta">2020年08月08日</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器"><span class="toc-number">1.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS-程序内存布局"><span class="toc-number">2.</span> <span class="toc-text">iOS 程序内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tagged-Pointer"><span class="toc-number">3.</span> <span class="toc-text">Tagged Pointer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OC-对象的内存管理"><span class="toc-number">4.</span> <span class="toc-text">OC 对象的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy、mutableCopy"><span class="toc-number">5.</span> <span class="toc-text">copy、mutableCopy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-原理"><span class="toc-number">6.</span> <span class="toc-text">weak 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autorelease-原理"><span class="toc-number">7.</span> <span class="toc-text">Autorelease 原理</span></a></li></ol></div></div><div class="post-content"><p>最近时间比较散，还有就是公司比较动荡😌，当初怀着一颗做事的心来到这里，没想到最后落得这样的结局。不说了，还是保持本心比较好，尽管想做好飞读，但是我们小职员也改变不了什么。做好自己的事情就好，按着学习计划继续。。。</p>
<a id="more"></a>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>iOS 的内存管理必然少不了定时器，以前没有深究过具体的原理，只知道 timer 会对 target 产生强引用，现在来分析下为什么会产生强引用以及怎样解决。</p>
<p>先来看一段测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)testTimer &#123;   </span><br><span class="line">    self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerAction &#123;</span><br><span class="line">    NSLog(@&quot;-- %s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，当我们销毁控制器时没有调用 dealloc 方法， 说明此时有循环引用。之前只是知道 timer 会对 self 产生强引用，那么具体怎么产生的呢，这里可以看一下 <a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNU</a> 源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (id) initWithFireDate: (NSDate*)fd</span><br><span class="line">	       interval: (NSTimeInterval)ti</span><br><span class="line">		 target: (id)object</span><br><span class="line">	       selector: (SEL)selector</span><br><span class="line">	       userInfo: (id)info</span><br><span class="line">		repeats: (BOOL)f</span><br><span class="line">&#123;</span><br><span class="line">  if (ti &lt;= 0.0)</span><br><span class="line">    &#123;</span><br><span class="line">      ti = 0.0001;</span><br><span class="line">    &#125;</span><br><span class="line">  if (fd == nil)</span><br><span class="line">    &#123;</span><br><span class="line">      _date = [[NSDate_class allocWithZone: NSDefaultMallocZone()]</span><br><span class="line">        initWithTimeIntervalSinceNow: ti];</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      _date = [fd copyWithZone: NSDefaultMallocZone()];</span><br><span class="line">    &#125;</span><br><span class="line">  _target = RETAIN(object);</span><br><span class="line">  _selector = selector;</span><br><span class="line">  _info = RETAIN(info);</span><br><span class="line">  if (f == YES)</span><br><span class="line">    &#123;</span><br><span class="line">      _repeats = YES;</span><br><span class="line">      _interval = ti;</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      _repeats = NO;</span><br><span class="line">      _interval = 0.0;</span><br><span class="line">    &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上可以看出 timer 会对 target 做一次 retain 操作，这也就解释了为什么使用 __weak 解决不了循环引用的问题，因为不管 target 传入 self 还是 weakSelf，timer 都会对 self 做一次 retain 操作。</p>
<p><br></p>
<p>要想解决循环引用，那么直接的办法就是添加一个中间代理，使用到了 NSProxy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface TargetProxy : NSProxy</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TargetProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target &#123;</span><br><span class="line">    TargetProxy * proxy = [TargetProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样就能解决循环引用的问题。这里还有一个注意点：当程序退到后台时 timer 就会停止，因为 timer 是基于 RunLoop 的，如之前 RunLoop 章节所讲， timer 也是不精准的。可以通过添加 observer 来验证我们的猜想，当程序退到后台时，最终会走到 kCFRunLoopBeforeWaiting 状态，从而 timer 停止工作，当程序从后台回到前台时，RunLoop 又从 kCFRunLoopAfterWaiting 状态开始执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self testTimer];</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        NSLog(@&quot;%lu&quot;, activity);</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CADisplayLink</code> 原理和 <code>NSTimer</code> 相同。</p>
<p>如果想要更精准的设置 timer，我们可以使用 GCD 来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@interface CTTimer : NSObject</span><br><span class="line">+ (id)executeTask:(dispatch_block_t)task</span><br><span class="line">            start:(NSTimeInterval)star</span><br><span class="line">         interval:(NSTimeInterval)interval</span><br><span class="line">         repeates:(BOOL)repeates</span><br><span class="line">            async:(BOOL)async;</span><br><span class="line"></span><br><span class="line">+ (id)executeWithTarget:(id)target</span><br><span class="line">                 action:(SEL)action</span><br><span class="line">                  start:(NSTimeInterval)star</span><br><span class="line">               interval:(NSTimeInterval)interval</span><br><span class="line">               repeates:(BOOL)repeates</span><br><span class="line">                  async:(BOOL)async;</span><br><span class="line"></span><br><span class="line">+ (void)cancelTask:(id)key;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CTTimer</span><br><span class="line">static NSMutableDictionary * timers_;</span><br><span class="line">dispatch_semaphore_t semphore_;</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    timers_ = [NSMutableDictionary dictionary];</span><br><span class="line">    semphore_ = dispatch_semaphore_create(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)executeTask:(dispatch_block_t)task</span><br><span class="line">            start:(NSTimeInterval)star</span><br><span class="line">         interval:(NSTimeInterval)interval</span><br><span class="line">         repeates:(BOOL)repeates</span><br><span class="line">            async:(BOOL)async &#123;</span><br><span class="line">    </span><br><span class="line">    if (!task || star &lt; 0 || (interval &lt; 0 &amp;&amp; repeates)) &#123; return nil; &#125;</span><br><span class="line">    </span><br><span class="line">    static dispatch_queue_t _queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _queue = dispatch_queue_create(&quot;queue timer&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t timerQueue = async ? _queue : dispatch_get_main_queue();</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, timerQueue);</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, star), interval * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSString * key = [NSString stringWithFormat:@&quot;key_%lu&quot;, (unsigned long)timers_.count];</span><br><span class="line">    timers_[key] = timer;</span><br><span class="line">    dispatch_semaphore_signal(semphore_);</span><br><span class="line">    </span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        if (task) &#123; task(); &#125;</span><br><span class="line">        if (!repeates) &#123;</span><br><span class="line">            [self cancelTask:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)executeWithTarget:(id)target</span><br><span class="line">                 action:(SEL)action</span><br><span class="line">                  start:(NSTimeInterval)star</span><br><span class="line">               interval:(NSTimeInterval)interval</span><br><span class="line">               repeates:(BOOL)repeates</span><br><span class="line">                  async:(BOOL)async &#123;</span><br><span class="line">    </span><br><span class="line">    if (!target || !action) &#123; return nil; &#125;</span><br><span class="line">    </span><br><span class="line">    return [self executeTask:^&#123;</span><br><span class="line">        if ([target respondsToSelector:action]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            [target performSelector:action];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; start:star interval:interval repeates:repeates async:async];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)cancelTask:(id)key &#123;</span><br><span class="line">    if (!key) &#123; return; &#125;</span><br><span class="line">    dispatch_semaphore_wait(semphore_, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_source_t timer = timers_[key];</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">        [timers_ removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(semphore_);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="iOS-程序内存布局"><a href="#iOS-程序内存布局" class="headerlink" title="iOS 程序内存布局"></a>iOS 程序内存布局</h3><p>iOS 内存布局如下所示：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="内存布局"></p>
<p>来做个简单验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        static int c = 20;</span><br><span class="line">        static int d;</span><br><span class="line">        int e;</span><br><span class="line">        int f = 20;</span><br><span class="line">        NSString *str = @&quot;123&quot;;</span><br><span class="line">        NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;\n&amp;a=%p\n&amp;b=%p\n&amp;c=%p\n&amp;d=%p\n&amp;e=%p\n&amp;f=%p\nstr=%p\nobj=%p\n&quot;,</span><br><span class="line">              &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, str, obj);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">/*</span><br><span class="line"> 字符串常量</span><br><span class="line"> str=0x10dfa0068</span><br><span class="line"> </span><br><span class="line"> 已初始化的全局变量、静态变量</span><br><span class="line"> &amp;a =0x10dfa0db8</span><br><span class="line"> &amp;c =0x10dfa0dbc</span><br><span class="line"> </span><br><span class="line"> 未初始化的全局变量、静态变量</span><br><span class="line"> &amp;d =0x10dfa0e80</span><br><span class="line"> &amp;b =0x10dfa0e84</span><br><span class="line"> </span><br><span class="line"> 堆</span><br><span class="line"> obj=0x608000012210</span><br><span class="line"> </span><br><span class="line"> 栈</span><br><span class="line"> &amp;f =0x7ffee1c60fe0</span><br><span class="line"> &amp;e =0x7ffee1c60fe4</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><blockquote>
<p>从64 bit 开始，iOS 引入了 TaggedPointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象的存储。</p>
<p>在没有 Tagged Pointer 之前，NSNumber 等对象需要动态分配内存、维护引用计数等，NSNumber 指针存储的是堆中 NSNumber 对象的地址值。</p>
<p>在使用了 Tagged Pointer 之后，NSNumber 指针里面存储的数据标称了：Tag+Data，也就是将数据直接存储在了指针中。</p>
<p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。</p>
<p>objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据，节省了以前的调用开销。</p>
</blockquote>
<p>下面来看下怎么样判断一个指针是否是 Tagged Pointer 呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static inline bool </span><br><span class="line">_objc_isTaggedPointer(const void * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_OSX &amp;&amp; __x86_64__</span><br><span class="line">    // 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">    // Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 60</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 52</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 1</span><br><span class="line">#   define _OBJC_TAG_SLOT_SHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_PAYLOAD_RSHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_MASK 0xfUL</span><br><span class="line">#   define _OBJC_TAG_EXT_INDEX_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_SLOT_SHIFT 4</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span><br><span class="line">#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如上，指针是否是 Tagged Pointer 是通过 <code>&amp;mask</code> 得到的，看下上面的 mask 值是区分 <code>iPhone</code> 和 <code>Mac</code> 的。</p>
<p>可以看到：</p>
<ul>
<li>iOS 平台：最高有效位是 1（第64 bit）</li>
<li>Mac 平台：最低有效位是 1</li>
</ul>
<p>具体的 isa 指针各个位的标识之前在 <a href="https://jueying-xiangfeng.github.io/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">Runtime原理探究</a> 中有讲到过。</p>
<h3 id="OC-对象的内存管理"><a href="#OC-对象的内存管理" class="headerlink" title="OC 对象的内存管理"></a>OC 对象的内存管理</h3><p>在 iOS 中，使用引用计数来管理 OC 对象的内存。</p>
<p>一个新创建的 OC 对象引用计数默认为 1，当引用计数器减为0，OC 对象就销毁，释放占用的内存空间。</p>
<p>调用 retain 会让 OC 对象的引用计数 +1，release 会 -1.</p>
<p>内存管理经验总结：</p>
<ul>
<li>当调用 alloc、malloc、copy、mutableCopy 方法返回了一个对象，在不需要这个对象时，要调用 release 或者 autorelease 来释放。</li>
<li>想拥有某个对象，就让它的引用计数 +1，不想在拥有某个对象，就让它的引用计数 -1。</li>
</ul>
<h3 id="copy、mutableCopy"><a href="#copy、mutableCopy" class="headerlink" title="copy、mutableCopy"></a>copy、mutableCopy</h3><p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/copy%E3%80%81mutableCopy.png" alt="copy、mutableCopy"></p>
<h3 id="weak-原理"><a href="#weak-原理" class="headerlink" title="weak 原理"></a>weak 原理</h3><p>先来看下 dealloc 方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        // Slow path for raw pointer isa.</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://jueying-xiangfeng.github.io/2020/07/20/Runtime%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">Runtime原理探究</a> 中我们讲到过 ISA 指针的各个位的作用，在 dealloc 时如果没有 <code>关联对象(has_assoc)</code>、<code>c++析构函数(has_cxx_dtor)</code>、<code>弱引用(weakly_referenced)</code>、<code>是否使用 sidetable(has_sidetable_rc)</code> 时释放会更快。这里我们单独看一下 weak，跟到 <code>clearDeallocating_slow</code> 方法可以看到最终的结构：<code>SideTable</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// RefcountMap disguises its pointers because we </span><br><span class="line">// don&apos;t want the table to act as a root for `leaks`.</span><br><span class="line">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</span><br><span class="line"></span><br><span class="line">struct weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef DisguisedPtr&lt;objc_object *&gt; weak_referrer_t;</span><br><span class="line"></span><br><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : 2;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool out_of_line() &#123;</span><br><span class="line">        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(this, &amp;other, sizeof(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[0] = newReferrer;</span><br><span class="line">        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，Sidetable 包含三部分内容，lock 部分不用管，这里的 RefcountMap 就是当 ISA 指针存储不下引用计数时有 Sidetable 存储的散列表。如果 <code>isa.has_sidetable_rc</code> 为 true，则会调用 <code>table.refcnts.erase(this);</code> 清除相关的引用。</p>
<p>再来看下 <code>weak_table</code> 结构，可以看到 weak_table 不会对修饰的对象产生强引用，而当对象被 <code>weak</code> 修饰过，则在释放时就会调用 <code>weak_clear_no_lock(&amp;table.weak_table, (id)this);</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            // 重点：这里将 weakReference 置为 nil</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上源码所示，在释放内存时，会将相关的 weak reference 设置为 nil，这也就是为什么使用 <code>__weak</code> 修饰过的变量在被修饰的对象释放时能置为 nil 的原理。</p>
<blockquote>
<p>ARC 就是 LLVM 编译器和 Runtime 系统相互协作的结果</p>
</blockquote>
<h3 id="Autorelease-原理"><a href="#Autorelease-原理" class="headerlink" title="Autorelease 原理"></a>Autorelease 原理</h3><p>当将对象调用 <code>autorelease</code> 方法后，就会被加入到 <code>自动释放池</code> 里面，使用 clang 命令来看下 autoreleasepool 到底被编译成了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里被编译成了 <code>__AtAutoreleasePool</code>，然后在 objc 源码里面查找 <code>autorelease</code> 方法，最终可以看到 autorelease 的管理类：<code>autoreleasepoolpage</code>。</p>
<p>所以自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code>。调用了 autorelease 的对象最终都是通过 AutoreleasePoolPage 对象来管理的。来看下 AutoreleasePoolPage 的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    static size_t const SIZE = </span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MAX_SIZE;  // size and alignment, power of 2 -- 4096</span><br><span class="line">#endif</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">  </span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 AutoreleasePoolPage 定义里面的 PAGE_MAX_SIZE 可以看到占用 4096 字节的内存。除了用来存放它内存的成员变量，剩下的空间用来存放 autorelease 对象的地址。</p>
<p>所有的 AutoreleasePoolPage 对象都是通过双向量表的形式连接在一起的。</p>
<p>来看下原理结构图：</p>
<p><img src="https://blog-key.oss-cn-beijing.aliyuncs.com/blog/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autoreleasepoolpage.png" alt="autoreleasepoolpage原理"></p>
<p>调用 push 方法会将一个 POOL_BOUNDARY 入栈，并且返回其存放的内存地址。</p>
<p>调用 pop 方法时传入一个 POOL_BOUNDARY 的内存地址，会从最后一个入栈的对象开始发送 release 消息，直到遇到这个 POOL)BOUNDARY。</p>
<p>id *next 指向了下一个能存放 autorelease 对象地址的区域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="comment">// push 时将 POOL_BOUNDARY 入栈，并返回 POOL_BOUNDARY 入栈的地址</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">    <span class="comment">// 判断当前是否是 hotpage，如果不是则调用 coldePage 的 pop 方法</span></span><br><span class="line">    <span class="comment">// 如果当前是 hotPage，则调用 releaseUntil 方法</span></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">            <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">            <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">            pop(coldPage()-&gt;begin());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can't prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 知道找到上一个与之对应的 POOL_BOUNDARY，否则中间的对象都调用 release 方法进行释放</span></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下一个变量被标记为 autorelease 后，是在什么时候 release 的。</p>
<p>自动释放池是有 RunLoop 控制的，加入自动释放池的变量会在某次 RunLoop 循环中，RunLoop休眠之前调用 release。</p>
<p>而我们平时开发时主线程的 RunLoop 中已经注册了 2 个 observer：</p>
<ol>
<li>第一个 observer 监听了 kCFRunLoopEntry 事件，会调用 objc_autoreleasePoolPush()。</li>
<li>第二个 observer 监听了两个事件<ul>
<li>kCFRunLoopBeforeWaiting 事件，会调用 objc_autoreleasePoolPop()、objc_autoreleasePoolPush()。</li>
<li>kCFRunLoopBeforeExit 事件，会调用 objc_autoreleasePoolPop()。</li>
</ul>
</li>
</ol>
<p>具体的应用可以看下 YY 大神的 <a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Base/Foundation/NSThread%2BYYAdd.m" target="_blank" rel="noopener">YYKit</a>  NSThread+YYAdd 相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">static inline void YYAutoreleasePoolPush() &#123;</span><br><span class="line">    NSMutableDictionary *dic =  [NSThread currentThread].threadDictionary;</span><br><span class="line">    NSMutableArray *poolStack = dic[YYNSThreadAutoleasePoolStackKey];</span><br><span class="line">    </span><br><span class="line">    if (!poolStack) &#123;</span><br><span class="line">        /*</span><br><span class="line">         do not retain pool on push,</span><br><span class="line">         but release on pop to avoid memory analyze warning</span><br><span class="line">         */</span><br><span class="line">        CFArrayCallBacks callbacks = &#123;0&#125;;</span><br><span class="line">        callbacks.retain = PoolStackRetainCallBack;</span><br><span class="line">        callbacks.release = PoolStackReleaseCallBack;</span><br><span class="line">        poolStack = (id)CFArrayCreateMutable(CFAllocatorGetDefault(), 0, &amp;callbacks);</span><br><span class="line">        dic[YYNSThreadAutoleasePoolStackKey] = poolStack;</span><br><span class="line">        CFRelease(poolStack);</span><br><span class="line">    &#125;</span><br><span class="line">    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // create</span><br><span class="line">    [poolStack addObject:pool]; // push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void YYAutoreleasePoolPop() &#123;</span><br><span class="line">    NSMutableDictionary *dic =  [NSThread currentThread].threadDictionary;</span><br><span class="line">    NSMutableArray *poolStack = dic[YYNSThreadAutoleasePoolStackKey];</span><br><span class="line">    [poolStack removeLastObject]; // pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void YYRunLoopAutoreleasePoolObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">        // 进入 loop 时 push</span><br><span class="line">        case kCFRunLoopEntry: &#123;</span><br><span class="line">            YYAutoreleasePoolPush();</span><br><span class="line">        &#125; break;</span><br><span class="line">        // loop 一圈走完，先 pop 然后在 push</span><br><span class="line">        case kCFRunLoopBeforeWaiting: &#123;</span><br><span class="line">            YYAutoreleasePoolPop();</span><br><span class="line">            YYAutoreleasePoolPush();</span><br><span class="line">        &#125; break;</span><br><span class="line">        // 退出时 pop</span><br><span class="line">        case kCFRunLoopExit: &#123;</span><br><span class="line">            YYAutoreleasePoolPop();</span><br><span class="line">        &#125; break;</span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void YYRunloopAutoreleasePoolSetup() &#123;</span><br><span class="line">    CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line">    // 当前线程添加监听：kCFRunLoopEntry、kCFRunLoopBeforeWaiting | kCFRunLoopExit</span><br><span class="line">    CFRunLoopObserverRef pushObserver;</span><br><span class="line">    pushObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopEntry,</span><br><span class="line">                                           true,         // repeat</span><br><span class="line">                                           -0x7FFFFFFF,  // before other observers</span><br><span class="line">                                           YYRunLoopAutoreleasePoolObserverCallBack, NULL);</span><br><span class="line">    CFRunLoopAddObserver(runloop, pushObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(pushObserver);</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverRef popObserver;</span><br><span class="line">    popObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                          true,        // repeat</span><br><span class="line">                                          0x7FFFFFFF,  // after other observers</span><br><span class="line">                                          YYRunLoopAutoreleasePoolObserverCallBack, NULL);</span><br><span class="line">    CFRunLoopAddObserver(runloop, popObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(popObserver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation NSThread (YYAdd)</span><br><span class="line"></span><br><span class="line">+ (void)addAutoreleasePoolToCurrentRunloop &#123;</span><br><span class="line">    // 主线程存在自动释放池，所以这里只需要在子线程中添加  </span><br><span class="line">    if ([NSThread isMainThread]) return; // The main thread already has autorelease pool.</span><br><span class="line">    NSThread *thread = [self currentThread];</span><br><span class="line">    if (!thread) return;</span><br><span class="line">    if (thread.threadDictionary[YYNSThreadAutoleasePoolKey]) return; // already added</span><br><span class="line">    YYRunloopAutoreleasePoolSetup();</span><br><span class="line">    thread.threadDictionary[YYNSThreadAutoleasePoolKey] = YYNSThreadAutoleasePoolKey; // mark the state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/内存管理/"><i class="fa fa-tag"></i>内存管理</a></div><div class="post-nav"><a class="pre" href="/2020/08/14/内存管理原理探究-续/">内存管理原理探究-续</a><a class="next" href="/2020/08/05/多线程/">多线程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/KVC/" style="font-size: 15px;">KVC</a> <a href="/tags/block-变量捕获/" style="font-size: 15px;">block 变量捕获</a> <a href="/tags/block-类型、copy/" style="font-size: 15px;">block 类型、copy</a> <a href="/tags/block-循环引用/" style="font-size: 15px;">block 循环引用</a> <a href="/tags/block/" style="font-size: 15px;">block</a> <a href="/tags/category-原理/" style="font-size: 15px;">category 原理</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/KVO/" style="font-size: 15px;">KVO</a> <a href="/tags/block-原理/" style="font-size: 15px;">block 原理</a> <a href="/tags/block-内存管理/" style="font-size: 15px;">block 内存管理</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/内存管理、RunLoop、Autorelease/" style="font-size: 15px;">内存管理、RunLoop、Autorelease</a> <a href="/tags/内存管理/" style="font-size: 15px;">内存管理</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/内存管理原理探究-续/">内存管理原理探究-续</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/内存管理原理探究/">内存管理原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/多线程/">多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/RunLoop原理探究/">RunLoop原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/20/Runtime原理探究/">Runtime原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block6-循环引用/">block6-循环引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block5-block内存管理/">block5-block内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/block3-block原理/">block4-__block原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block3-类型、copy原理/">block3-类型、copy原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block2-变量的捕获/">block2-变量的捕获</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/jueying-xiangfeng" title="github" target="_blank">github</a><ul></ul><a title="生活随笔-复盘(最近正在整理)" target="_blank">生活随笔-复盘(最近正在整理)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">白夜追凶.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>