<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>内存管理原理探究-续 | 白夜追凶</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">内存管理原理探究-续</h1><a id="logo" href="/.">白夜追凶</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">内存管理原理探究-续</h1><div class="post-meta">2020年08月14日</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARC-内存管理原理"><span class="toc-number">1.</span> <span class="toc-text">ARC 内存管理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动-release"><span class="toc-number">1.1.</span> <span class="toc-text">自动 release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动-retain"><span class="toc-number">1.2.</span> <span class="toc-text">自动 retain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对-retain、release-的一些优化"><span class="toc-number">1.3.</span> <span class="toc-text">对 retain、release 的一些优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PerformSelector-问题"><span class="toc-number">1.3.1.</span> <span class="toc-text">PerformSelector 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NSInvocation-返回值问题"><span class="toc-number">1.3.2.</span> <span class="toc-text">NSInvocation 返回值问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子线程的-Autorelease-是怎样维护的"><span class="toc-number">2.</span> <span class="toc-text">子线程的 Autorelease 是怎样维护的</span></a></li></ol></div></div><div class="post-content"><p>最近在做皮肤适配时遇到了很多的坑，进而产生了很多的疑问。下面是想到了一些问题和最终得到的验证，内功太菜。之前一直在怀疑是他们都太飘了还是我拿不动刀了。现在看看内功太菜，确实是我打不动刀了。。。</p>
<p>之前看 Autorelease 时知道了底层是由 AutoreleasePoolPage 实现的，并且是由 RunLoop 来驱动的。那么的疑问就是我们在子线程中添加 Autorelease 时，这时没有 RunLoop，那么 autorelease 是怎样工作的呢？</p>
<a id="more"></a>
<p>最近遇到了一个疑问，之前看 Autorelease 时知道了底层是由 AutoreleasePoolPage 实现的，并且是由 RunLoop 来驱动的。那么的疑问就是我们在子线程中添加 Autorelease 时，这时没有 RunLoop，那么 autorelease 是怎样工作的呢？</p>
<p>在整理上面的疑问时还遇到了几个别的内存管理的问题：</p>
<ul>
<li>ARC 到底是怎样管理内存的，平时只知道在合适的位置帮我们release，那么这个时机是在哪里？</li>
<li>weak、strong、autoreleasing 在 ARC 下的具体实现是怎样的？</li>
</ul>
<h3 id="ARC-内存管理原理"><a href="#ARC-内存管理原理" class="headerlink" title="ARC 内存管理原理"></a>ARC 内存管理原理</h3><p><code>ARC</code>即OC的自动引用计数技术，通过在编译阶段自动添加引用计数，达到自动管理引用计数的目的。使用ARC可以做到接近垃圾回收的代码编写体验，同时拥有引用计数的性能与效率。那么ARC具体是怎做到自动添加添加和释放引用计数的呢。</p>
<h4 id="自动-release"><a href="#自动-release" class="headerlink" title="自动 release"></a>自动 release</h4><p>来一段测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (void)test &#123;    </span><br><span class="line">    id a;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用 <code>clang -S -fobjc-arc -emit-llvm Person.m -o person_arc.ll</code> 命令来查看下生成的中间代码：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define internal void @<span class="string">"\01-[Person test]"</span>(%0*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca %0*,<span class="built_in"> align </span>8</span><br><span class="line">  %4 = alloca i8*,<span class="built_in"> align </span>8</span><br><span class="line">  %5 = alloca i8*,<span class="built_in"> align </span>8</span><br><span class="line">  store %0* %0, %0** %3,<span class="built_in"> align </span>8</span><br><span class="line">  store i8* %1, i8** %4,<span class="built_in"> align </span>8</span><br><span class="line">  store i8* <span class="literal">null</span>, i8** %5,<span class="built_in"> align </span>8</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %5, i8* <span class="literal">null</span>) #2</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> alloca 是在当前执行的函数堆栈帧中分配内存。store 则表示将值存到指定地址。</p>
<p>关于 llvm 语法问题可以查看官方文档：<code>https://llvm.org/docs/LangRef.html</code></p>
<p>这里有一个很重要的函数：objc.storeStrong(i8*<em> %5, i8</em> null)，来看下 objc 的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    if (obj == prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其操作就是将 obj 做一次 retain 操作，然后再将 location 指向 obj，最后将 location 做一次 release。</p>
<p>OK，objc.storeStrong(i8*<em> %5, i8</em> null) 函数其实就是将 location 置空，并且是在函数作用域结束时做的。</p>
<h4 id="自动-retain"><a href="#自动-retain" class="headerlink" title="自动 retain"></a>自动 retain</h4><p>再来加点测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    id a;</span><br><span class="line">    __strong id b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal void @&quot;\01-[Person test]&quot;(%0*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca %0*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca i8*, align 8</span><br><span class="line">  %6 = alloca i8*, align 8</span><br><span class="line">  store %0* %0, %0** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  store i8* null, i8** %5, align 8</span><br><span class="line">  %7 = load i8*, i8** %5, align 8</span><br><span class="line">  %8 = call i8* @llvm.objc.retain(i8* %7) #1</span><br><span class="line">  store i8* %8, i8** %6, align 8</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %6, i8* null) #1</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %5, i8* null) #1</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在给 b 指针赋值时调用了一次 retain。并在函数最后面调用了两次 objc.storeStrong。这里可以看到使用强指针会自动插入 retain 操作，而在作用域结束时会插入 release 操作。</p>
<p>再来试下其他修饰符：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/// __autoreleasing</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void @<span class="string">"\01-[Person test]"</span>(<span class="symbol">%0</span>*, <span class="keyword">i8</span>*) <span class="symbol">#0</span> &#123;</span><br><span class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="symbol">%0</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%4</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%5</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%6</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="symbol">%0</span>* <span class="symbol">%0</span>, <span class="symbol">%0</span>** <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%1</span>, <span class="keyword">i8</span>** <span class="symbol">%4</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="keyword">null</span>, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i8</span>*, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%8</span> = <span class="keyword">call</span> <span class="keyword">i8</span>* <span class="title">@llvm.objc.retainAutorelease</span>(<span class="keyword">i8</span>* <span class="symbol">%7</span>) <span class="symbol">#1</span>	// 注意这里</span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%8</span>, <span class="keyword">i8</span>** <span class="symbol">%6</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.storeStrong</span>(<span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">i8</span>* <span class="keyword">null</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// __weak</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void @<span class="string">"\01-[Person test]"</span>(<span class="symbol">%0</span>*, <span class="keyword">i8</span>*) <span class="symbol">#0</span> &#123;</span><br><span class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="symbol">%0</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%4</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%5</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%6</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="symbol">%0</span>* <span class="symbol">%0</span>, <span class="symbol">%0</span>** <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%1</span>, <span class="keyword">i8</span>** <span class="symbol">%4</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="keyword">null</span>, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i8</span>*, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%8</span> = <span class="keyword">call</span> <span class="keyword">i8</span>* <span class="title">@llvm.objc.initWeak</span>(<span class="keyword">i8</span>** <span class="symbol">%6</span>, <span class="keyword">i8</span>* <span class="symbol">%7</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.destroyWeak</span>(<span class="keyword">i8</span>** <span class="symbol">%6</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.storeStrong</span>(<span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">i8</span>* <span class="keyword">null</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// __unsafe_unretained</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void @<span class="string">"\01-[Person test]"</span>(<span class="symbol">%0</span>*, <span class="keyword">i8</span>*) <span class="symbol">#0</span> &#123;</span><br><span class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="symbol">%0</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%4</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%5</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%6</span> = <span class="keyword">alloca</span> <span class="keyword">i8</span>*, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="symbol">%0</span>* <span class="symbol">%0</span>, <span class="symbol">%0</span>** <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%1</span>, <span class="keyword">i8</span>** <span class="symbol">%4</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="keyword">null</span>, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i8</span>*, <span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">align</span> <span class="number">8</span>	// 注意这里是直接赋值</span><br><span class="line">  <span class="keyword">store</span> <span class="keyword">i8</span>* <span class="symbol">%7</span>, <span class="keyword">i8</span>** <span class="symbol">%6</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.objc.storeStrong</span>(<span class="keyword">i8</span>** <span class="symbol">%5</span>, <span class="keyword">i8</span>* <span class="keyword">null</span>) <span class="symbol">#1</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__autoreleasing 其实其实就是调用 objc_retainAutorelease 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 对 obj 做一次 retain 操作，然后加入自动释放池</span><br><span class="line">id objc_retainAutorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    return objc_autorelease(objc_retain(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__weak 是调用 objc_initWeak 对 weak 对象赋值，在作用域结束时调用 objc_destryWeak 进行释放。</p>
<p>__unsafe_unretained 则只是进行指针的赋值，并不考虑引用计数相关的问题。</p>
<p>综上我们可以看到，ARC 会自动的在赋值语句之前插入一些引用计数相关的函数，这就是 ARC 实现的主要原理。</p>
<h4 id="对-retain、release-的一些优化"><a href="#对-retain、release-的一些优化" class="headerlink" title="对 retain、release 的一些优化"></a>对 retain、release 的一些优化</h4><p><code>ARC</code>对于以<code>new</code>、<code>copy</code>、<code>mutableCopy</code>和<code>alloc</code>以及 以这四个单词开头的所有函数，默认认为函数返回值直接持有对象。这是ARC中必须要遵守的命名规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)newPerson &#123;</span><br><span class="line">    Person * p = [Person new];    </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)createPerson &#123;</span><br><span class="line">    Person * p = [Person new];</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i8* @&quot;\01+[Person newPerson]&quot;(i8*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca i8*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca %0*, align 8</span><br><span class="line">  store i8* %0, i8** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  %6 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %7 = bitcast %struct._class_t* %6 to i8*</span><br><span class="line">  %8 = call i8* @objc_opt_new(i8* %7)</span><br><span class="line">  %9 = bitcast i8* %8 to %0*</span><br><span class="line">  store %0* %9, %0** %5, align 8</span><br><span class="line">  %10 = load %0*, %0** %5, align 8</span><br><span class="line">  %11 = bitcast %0* %10 to i8*</span><br><span class="line">  %12 = call i8* @llvm.objc.retain(i8* %11) #1</span><br><span class="line">  %13 = bitcast i8* %12 to %0*</span><br><span class="line">  %14 = bitcast %0* %13 to i8*</span><br><span class="line">  %15 = bitcast %0** %5 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %15, i8* null) #1</span><br><span class="line">  ret i8* %14</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal i8* @&quot;\01+[Person createPerson]&quot;(i8*, i8*) #0 &#123;</span><br><span class="line">  %3 = alloca i8*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca %0*, align 8</span><br><span class="line">  store i8* %0, i8** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  %6 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %7 = bitcast %struct._class_t* %6 to i8*</span><br><span class="line">  %8 = call i8* @objc_opt_new(i8* %7)</span><br><span class="line">  %9 = bitcast i8* %8 to %0*</span><br><span class="line">  store %0* %9, %0** %5, align 8</span><br><span class="line">  %10 = load %0*, %0** %5, align 8</span><br><span class="line">  %11 = bitcast %0* %10 to i8*</span><br><span class="line">  %12 = call i8* @llvm.objc.retain(i8* %11) #1</span><br><span class="line">  %13 = bitcast i8* %12 to %0*</span><br><span class="line">  %14 = bitcast %0* %13 to i8*</span><br><span class="line">  %15 = bitcast %0** %5 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %15, i8* null) #1</span><br><span class="line">  %16 = tail call i8* @llvm.objc.autoreleaseReturnValue(i8* %14) #1</span><br><span class="line">  ret i8* %16</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 <code>newPerson</code> 中，函数的返回值不带 autorelease，是直接持有对象。而函数 <code>createPerson</code> 中返回对象的最后一步会调用 <code>autoreleaseReturnValue</code>。</p>
<p>再来看下使用赋值的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    Person * a = [Person createPerson];</span><br><span class="line">    Person * b = [Person newPerson];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define internal void @&quot;\01-[Person test]&quot;(%0*, i8*) #1 &#123;</span><br><span class="line">  %3 = alloca %0*, align 8</span><br><span class="line">  %4 = alloca i8*, align 8</span><br><span class="line">  %5 = alloca %0*, align 8</span><br><span class="line">  %6 = alloca %0*, align 8</span><br><span class="line">  store %0* %0, %0** %3, align 8</span><br><span class="line">  store i8* %1, i8** %4, align 8</span><br><span class="line">  %7 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %8 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align 8, !invariant.load !9</span><br><span class="line">  %9 = bitcast %struct._class_t* %7 to i8*</span><br><span class="line">  %10 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %9, i8* %8)</span><br><span class="line">  %11 = notail call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %10) #2</span><br><span class="line">  %12 = bitcast i8* %11 to %0*</span><br><span class="line">  store %0* %12, %0** %5, align 8</span><br><span class="line">  %13 = load %struct._class_t*, %struct._class_t** @&quot;OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8</span><br><span class="line">  %14 = load i8*, i8** @OBJC_SELECTOR_REFERENCES_.2, align 8, !invariant.load !9</span><br><span class="line">  %15 = bitcast %struct._class_t* %13 to i8*</span><br><span class="line">  %16 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %15, i8* %14)</span><br><span class="line">  %17 = bitcast i8* %16 to %0*</span><br><span class="line">  store %0* %17, %0** %6, align 8</span><br><span class="line">  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*))</span><br><span class="line">  %18 = bitcast %0** %6 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %18, i8* null) #2</span><br><span class="line">  %19 = bitcast %0** %5 to i8**</span><br><span class="line">  call void @llvm.objc.storeStrong(i8** %19, i8* null) #2</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，赋值前不会对 <code>[Person newPerson]</code> 进行操作，因为外面是一个 strong 指针，而返回的对象已经持有引用计数。</p>
<p>而对 <code>[Person createPerson]</code> 的返回值需要 retain，因为函数对返回的对象进行了一次 autoreleaseReturnValue 操作，和前面的 retain 操作对应，正好达到引用计数器的加减平衡，所以外面的 strong 指针需要对返回值进行持有。</p>
<p>这里还有一个ARC 的优化，如果返回值使用了 <code>objc_autoreleaseReturnValue</code>函数，则在赋值时对应使用 <code>objc_retainAutoreleasedReturnValue</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span><br><span class="line">id </span><br><span class="line">objc_autoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_autorelease(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id</span><br><span class="line">objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (acceptOptimizedReturn() == ReturnAtPlus1) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_retain(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARC 对内存调用函数进行了优化，即 ARC 相关的函数不通过 OC 的消息发送机制，而是直接调用底层的 C 函数，而且 ARC 是在编译阶段有编译器自动添加引用计数函数调用，而不是运行时判断。综上，ARC 性能要优于 MRC。</p>
<h5 id="PerformSelector-问题"><a href="#PerformSelector-问题" class="headerlink" title="PerformSelector 问题"></a>PerformSelector 问题</h5><p>当我们调用 performSelector 时来看一个比较经典的警告：</p>
<p><code>PerformSelector may cause a leak because its selector is unknown</code></p>
<p>当我们了解完 ARC 的原理后，这个就不难解释了，对于 <code>performSelector</code> 返回值是 id，对于以下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)newP &#123;    </span><br><span class="line">    return [Person new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    SEL sel = NSSelectorFromString(@&quot;newP&quot;);</span><br><span class="line">    Person * person = [self performSelector:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 person 为强指针，会对 performSelector 的返回值进行一次 retain 操作，然后在 person 离开作用域时进行一次 release 操作。</p>
<p>而如果 sel 是以 new、copy、mutableCopy、alloc 开头的，则返回的对象时带有一个引用计数的，所以 person 只进行了一次 retain 和一次 release，此时引用计数还是为 1，这就会发生内存泄漏问题。</p>
<h5 id="NSInvocation-返回值问题"><a href="#NSInvocation-返回值问题" class="headerlink" title="NSInvocation 返回值问题"></a>NSInvocation 返回值问题</h5><p>当我们使用 NSInvocation 的 <code>getReturnValue</code>获取返回值时，看苹果的声明，这个函数由于不知道返回值类型，只进行指针赋值不进行对象的内存管理操作，所以结合上面讲到的 ARC 内存管理问题我们就要考虑如何避免内存问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)newP &#123;</span><br><span class="line">    return [Person new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)createPerson &#123;</span><br><span class="line">    return [Person new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    Person * targetPerson = [Person new];</span><br><span class="line">    SEL sel = @selector(newP);</span><br><span class="line">    NSMethodSignature * signature = [self methodSignatureForSelector:sel];</span><br><span class="line">    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">    invocation.selector = sel;</span><br><span class="line">    [invocation invokeWithTarget:targetPerson];</span><br><span class="line">    </span><br><span class="line">    __strong Person * returnValue;</span><br><span class="line">    [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先当被调用函数是以<code>new</code>，<code>copy</code>,<code>mutableCopy</code>和<code>alloc</code>开头的特殊函数时，函数返回的的对象持有引用计数，所以我们设置<code>returnValue</code>的类型是<code>__strong</code>，这样在这个<code>returnValue</code>的作用域结束时，会进行<code>release</code>，内存处理正常。</p>
<p>当被调用的函数是 createPerson 时，由于函数内部最后执行了 autorelease，如果此时我们再使用 strong 指针的话，就会导致内存泄漏问题。所以这里我们要使用 autoreleasing 来修饰 returnValue。</p>
<h3 id="子线程的-Autorelease-是怎样维护的"><a href="#子线程的-Autorelease-是怎样维护的" class="headerlink" title="子线程的 Autorelease 是怎样维护的"></a>子线程的 Autorelease 是怎样维护的</h3><p>前面一章中我们知道了主线程的 autorelease 对象是由 AutoreleasePoolPage 对象管理的，并且 AutoreleasePoolPage 的push 和 pop 操作是由主线程中在 RunLoop 中注册的两个 observer 维护的。那么在子线程中 autorelease 对象是如何维护的呢？因为我们知道子线程一般是没有 RunLoop的，那么在子线程中是如何维护的呢？来源码中找下答案：</p>
<p>子线程 AutoreleasePoolPage 创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    // 加入 autorealease 对象到 page 的入口函数</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line">    ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">    // 调用 autoreleaseFast</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果当前 page 为空</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary = false;</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        pushExtraBoundary = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        return setEmptyPoolPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line">    // Install the first page.</span><br><span class="line">    // 关键来了：如果 page 为空则创建 page 对象</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    // Push a boundary on behalf of the previously-placeholder&apos;d pool.</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Push the requested object or pool.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子线程 AutoreleasePoolPage 管理对象的释放，在线程退出时会调用 <code>pthread_exit</code>方法，最终回来到 <code>tls_dealloc</code> 函数。由于 objc 的源码不能调试到 pthread_exit 方法，所以这里我们只能看关于 AutoreleasePoolPage 的相关源码，当 if (!page-&gt;empty()) 满足时执行：objc_autoreleasePoolPop(page-&gt;begin()); 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void tls_dealloc(void *p) </span><br><span class="line">&#123;</span><br><span class="line">    if (p == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reinstate TLS value while we work</span><br><span class="line">    setHotPage((AutoreleasePoolPage *)p);</span><br><span class="line"></span><br><span class="line">    if (AutoreleasePoolPage *page = coldPage()) &#123;</span><br><span class="line">        if (!page-&gt;empty()) objc_autoreleasePoolPop(page-&gt;begin());  // pop all of the pools</span><br><span class="line">        if (slowpath(DebugMissingPools || DebugPoolAllocation)) &#123;</span><br><span class="line">            // pop() killed the pages already</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            page-&gt;kill();  // free all of the pages</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // clear TLS value so TLS destruction doesn&apos;t loop</span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，子线程的 autorelease 对象也是由 AutoreleasePoolPage 来管理的，再加入page时如果 page 为空则新建一个。</p>
<p>在线程退出时则会调用 <code>tls_dealloc</code> 方法，然后进行 pop 操作 来释放所有相关的 autorelease 对象。</p>
<p>参考：</p>
<ul>
<li><a href="[https://suhou.github.io/2018/01/21/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E7%9C%8B%E6%BA%90%E7%A0%81----%E5%AD%90%E7%BA%BF%E7%A8%8BAutoRelease%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E9%87%8A%E6%94%BE/](https://suhou.github.io/2018/01/21/带着问题看源码----子线程AutoRelease对象何时释放/">带着问题看源码—-子线程AutoRelease对象何时释放</a>)</li>
<li><a href="http://luoxianming.cn/2017/05/06/arc/" target="_blank" rel="noopener">ARC原理探究</a></li>
</ul>
</div><div class="tags"><a href="/tags/内存管理、RunLoop、Autorelease/"><i class="fa fa-tag"></i>内存管理、RunLoop、Autorelease</a></div><div class="post-nav"><a class="next" href="/2020/08/08/内存管理原理探究/">内存管理原理探究</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/KVC/" style="font-size: 15px;">KVC</a> <a href="/tags/block-循环引用/" style="font-size: 15px;">block 循环引用</a> <a href="/tags/block/" style="font-size: 15px;">block</a> <a href="/tags/category-原理/" style="font-size: 15px;">category 原理</a> <a href="/tags/block-变量捕获/" style="font-size: 15px;">block 变量捕获</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/KVO/" style="font-size: 15px;">KVO</a> <a href="/tags/block-内存管理/" style="font-size: 15px;">block 内存管理</a> <a href="/tags/block-原理/" style="font-size: 15px;">block 原理</a> <a href="/tags/block-类型、copy/" style="font-size: 15px;">block 类型、copy</a> <a href="/tags/内存管理、RunLoop、Autorelease/" style="font-size: 15px;">内存管理、RunLoop、Autorelease</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a> <a href="/tags/内存管理/" style="font-size: 15px;">内存管理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/内存管理原理探究-续/">内存管理原理探究-续</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/内存管理原理探究/">内存管理原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/多线程/">多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/RunLoop原理探究/">RunLoop原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/20/Runtime原理探究/">Runtime原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block6-循环引用/">block6-循环引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block5-block内存管理/">block5-block内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/block3-block原理/">block4-__block原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block3-类型、copy原理/">block3-类型、copy原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block2-变量的捕获/">block2-变量的捕获</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">白夜追凶.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>