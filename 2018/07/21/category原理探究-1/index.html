<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>category原理探究-1 | 白夜追凶</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">category原理探究-1</h1><a id="logo" href="/.">白夜追凶</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">category原理探究-1</h1><div class="post-meta">2018年07月21日</div><div class="post-content"><h3 id="category探究准备"><a href="#category探究准备" class="headerlink" title="category探究准备"></a>category探究准备</h3><p>先来创建我们测试需要的类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Animal类 --&gt;</span></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">- (void)animal;</span><br><span class="line">@end</span><br><span class="line"><span class="comment">&lt;!-- Animal+Eat分类 --&gt;</span></span><br><span class="line">@interface Animal (Eat) <span class="tag">&lt;<span class="name">NSCopying,</span> <span class="attr">NSCoding</span>&gt;</span></span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">- (void)eat;</span><br><span class="line">@end</span><br><span class="line"><span class="comment">&lt;!-- Animal+Play分类 --&gt;</span></span><br><span class="line">@interface Animal (Play)</span><br><span class="line">- (void)play;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以Eat分类为例，请出 <code>clang</code> 命令：<code>clang -rewrite-objc Animal+Eat.m</code> ，生成.cpp文件。</p>
<h3 id="category的真面目"><a href="#category的真面目" class="headerlink" title="category的真面目"></a>category的真面目</h3><p>在.cpp文件最下面可以找到category被编译后的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code> 这里的name表示的是 <code>类名</code> 而不是category的名字。</li>
<li><code>cls</code> 要扩展的类对象，编译期间值为空，在被runtime加载时根据name对应到类对象。</li>
<li><code>instance_methods</code> category所有的实例方法。</li>
<li><code>class_methods</code> category所有的类方法。</li>
<li><code>protocols</code> category实现的所有协议。</li>
<li><code>properties</code> category的所有属性。</li>
</ul>
<p>再来看看我们的Animal+Eat被编译成了什么：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct <span class="variable">_category_t</span> <span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_Animal_</span>$<span class="variable">_Eat</span> <span class="variable">__attribute__</span> ((used, section (<span class="string">"__DATA,__objc_const"</span>))) =  &#123;</span><br><span class="line">	<span class="string">"Animal"</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Animal,</span></span><br><span class="line">	(const struct <span class="variable">_method_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_INSTANCE_METHODS_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(const struct <span class="variable">_protocol_list_t</span> *)&amp;<span class="variable">_OBJC_CATEGORY_PROTOCOLS_</span>$<span class="variable">_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">	(const struct <span class="variable">_prop_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_PROP_LIST_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看一下结构体的名称：<code>_OBJC_$_CATEGORY_Animal_$_Eat</code>，最后面的Eat就是我们分类的名称，前面有表示CATEGORY和类名Animal，这也就是为什么同一个类的category不能重名的原因了。<br>再对应一下其他的结构，例如instance_methods：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Eat __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"eat"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_Eat_eat&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们里面只有一个 <code>eat</code> 方法，被编译后为 <code>_I_Animal_Eat_eat</code>。</p>
<p>最后可以看到所有的category被放到了一个数组中，存在了 <code>__DATA</code> 段下的 <code>__objc_catlist section</code> 里了：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct <span class="variable">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class="number">1</span>] <span class="variable">__attribute__</span>((used, section (<span class="string">"__DATA, __objc_catlist,regular,no_dead_strip"</span>)))= &#123;</span><br><span class="line">	&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_Animal_</span>$<span class="variable">_Eat</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里编译期间的工作就做完了，接下来进入runtime。</p>
<h3 id="runtime加载category"><a href="#runtime加载category" class="headerlink" title="runtime加载category"></a>runtime加载category</h3><p>先下载一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。</p>
<p>大致加载的流程如下：</p>
<ul>
<li>找到runtime的入口：<code>objc-os.mm</code> 的 <code>_objc_init</code> 方法，在library加载前由libSystem dyld调用，进行初始化操作。</li>
<li>调用map_images方法将文件中的image map到内存。</li>
<li>调用_read_images方法初始化map后的image。</li>
<li>找到 <code>Discover categories</code> 可以看到 <code>category_t</code> 是通过 <code>_getObjc2CategoryList</code> 方法初始化的，这个方法拿出来看看：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">   <span class="built_in"> type </span>*name(const headerType *mhdr, size_t *outCount) &#123;              \</span><br><span class="line">        return getDataSection&lt;type&gt;(mhdr, sectname, <span class="literal">nil</span>, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">   <span class="built_in"> type </span>*name(const header_info *hi, size_t *outCount) &#123;               \</span><br><span class="line">        return getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, <span class="literal">nil</span>, outCount); \</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GETSECT(_getObjc2CategoryList, category_t *, <span class="string">"__objc_catlist"</span>);</span><br></pre></td></tr></table></figure>
<p>看到这里有没有很熟悉，在这里加载的 <code>__objc_catlist</code> 就是在编译期间存放的数据。</p>
<p>来看一下加载的源码：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取出 category 数据 此处为数组代表一个类所有的分类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">	   </span><br><span class="line">	  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	  * 按顺序取出 category_t </span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">	  category_t *cat = catlist[i];</span><br><span class="line">	  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	  * remapClass：加载category_t的class指针</span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">	  C<span class="function"><span class="title">lass</span> cls = remapClass(cat-&gt;</span>cls);</span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span><span class="function"><span class="title">protocols</span>  ||  cat-&gt;</span>instanceProperties) </span><br><span class="line">	  &#123;</span><br><span class="line">	      addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">	      <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">	      	remethodizeClass(cls);</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	</span><br><span class="line">	  <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span><span class="function"><span class="title">protocols</span> ||  (hasClassProperties &amp;&amp; cat-&gt;</span>_classProperties)) </span><br><span class="line">	  &#123;</span><br><span class="line">	      <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>ISA(), hi);</span><br><span class="line">	      <span class="function"><span class="title">if</span> (cls-&gt;</span>ISA()-&gt;isRealized()) &#123;</span><br><span class="line">	      	<span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>ISA());</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到每次循环中 <code>category_t</code> 的加载 <code>addUnattachedCategoryForClass</code> 方法有两个调用，对比一下参数可以发现第二个参数不同 cls 和 cls-&gt;ISA()，再结合判断条件的 cat-&gt;instanceMethods 和 cat-&gt;classMethods，这两次的加载是将category中的信息分别加载到类和元类中，然后再调用 <code>remethodizeClass</code> 重新组织结构。接下来调用附加信息的方法 <code>attachCategories</code> ，将分类的信息附加到类中：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为元类</span></span><br><span class="line"><span class="comment">    */</span> 	</span><br><span class="line">    <span class="function"><span class="title">bool</span> isMeta = cls-&gt;</span>isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **) </span><br><span class="line">        <span class="function"><span class="title">malloc</span>(cats-&gt;</span>count * sizeof(*mlists));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 属性数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        <span class="function"><span class="title">malloc</span>(cats-&gt;</span>count * sizeof(*proplists));</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 协议数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        <span class="function"><span class="title">malloc</span>(cats-&gt;</span>count * sizeof(*protolists));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ********** 注意 ：这里是倒序循环 **********</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">auto</span>&amp; entry = cats-&gt;</span>list[i];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类的方法列表 (根据 isMeta 来判断取实例方法还是类方法)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">method_list_t</span> *mlist = entry.cat-&gt;</span>methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 将分类方法列表正序添加到 mlists</span></span><br><span class="line"><span class="comment">            */</span>        </span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类的属性列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            <span class="function"><span class="title">entry</span>.cat-&gt;</span>propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 将分类属性列表正序添加到 proplists</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取出某个分类的协议列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="title">protocol_list_t</span> *protolist = entry.cat-&gt;</span>protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 将分类协议列表正序添加到 protolists</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 取出类的信息数据  class_rw_t</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">auto</span> rw = cls-&gt;</span><span class="keyword">data</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化方法的一些信息，比如有没有实现retain、release、allocWithZone等方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将所有分类的方法、属性、协议列表附加到类的方法、属性、协议列表中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>protocols.attachLists(protolists, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的while循环可以看到加载方法、协议、属性的时候是 <code>倒序</code> 加载的，是不是想到了什么？如果Animal类和两个分类都有一个 <code>-(void)run</code> 方法，那么最终会调用哪个里面的run方法呢？答案当然是最后加载的那个run方法，不过没有被调用的run方法并没有被 <code>覆盖</code> ，方法还在那里只是按顺序没有被调用。</p>
<p>最后看一下 <code>methods.attachLists</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将分类的 方法、协议、属性等信息附加到类中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">	<span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 重新分配内存（大小为： oldCount addedCount 原有count和要添加的count总和）</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">	<span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 重新布局</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists,</span><br><span class="line">		 oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists,</span><br><span class="line">		 addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新布局的时候有两个方法：</p>
<ul>
<li><code>memmove</code>：<code>void *memmove(void *__dst, const void *__src, size_t __len);</code> 可以看到是将src变量的数据移动到dst，所以最终是将 array()-&gt;lists 的数据移动到了 array()-&gt;lists + addedCount 的位置。</li>
<li><code>memcpy</code>：<code>void    *memcpy(void *__dst, const void *__src, size_t __n);</code> 可以看到是将src变量的数据copy到dst，所以最终是将分类中的信息 <code>addedLists</code> copy 到 array()-&gt;lists 的位置。</li>
</ul>
<p>正如我们上面说的run方法，Animal类中的run方法是被最后加载的，因为Animal类中的方法列表被移动到了分类的后面，加载的时候会先调用分类中的方法，而且可以看到Animal中的run方法确实没有被覆盖，只是调用的时候发现分类中有不会再调用Animal的run方法而已。</p>
<h3 id="class-extention与category"><a href="#class-extention与category" class="headerlink" title="class extention与category"></a>class extention与category</h3><p>上面知道了category，我们再来看看class extention，class extention算是一种特殊的分类（匿名分类），那么我们可以思考平时在 .m 文件的匿名分类中写的私有属性、方法等在加载的时候会不会和分类一样呢？我们来验证一下，在Animal的 .m 文件里添加属性 height 和方法 test：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> Animal ()</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) int height;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">test</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">Animal</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animal</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">test</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>用clang命令来编译 Animal：<code>clang -rewrite-objc Animal.m</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 元类结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">_class_ro_t</span></span> _OBJC_METACLASS_RO_$_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">_class_t</span></span>), <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">_class_t</span></span>), </span><br><span class="line">	(unsigned int)<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="string">"Animal"</span>,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">_class_ro_t</span></span> _OBJC_CLASS_RO_$_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="number">0</span>, __OFFSETOFIVAR__(<span class="class"><span class="keyword">struct</span> <span class="title">Animal</span></span>, _height), <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">Animal_IMPL</span></span>), </span><br><span class="line">	(unsigned int)<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="string">"Animal"</span>,</span><br><span class="line">	(<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">_method_list_t</span></span> *)&amp;_OBJC_$_INSTANCE_METHODS_Animal,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	(<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">_ivar_list_t</span></span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_Animal,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/***************************************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以看到类中方法列表 ‘_INSTANCE_METHODS_Animal’对应下面的结构</span></span><br><span class="line"><span class="comment">* animal、test、height、setHeight 方法都在类结构中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*<span class="title">_method_list_t</span></span>*/ &#123;</span><br><span class="line">	unsigned int entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">_objc_method</span></span> method_list[<span class="number">4</span>];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">4</span>,</span><br><span class="line">	&#123;&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"animal"</span>, <span class="string">"v16@0:8"</span>, (void *)_I_Animal_animal&#125;,</span><br><span class="line">	&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"test"</span>, <span class="string">"v16@0:8"</span>, (void *)_I_Animal_test&#125;,</span><br><span class="line">	&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"height"</span>, <span class="string">"i16@0:8"</span>, (void *)_I_Animal_height&#125;,</span><br><span class="line">	&#123;(<span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span></span> *)<span class="string">"setHeight:"</span>, <span class="string">"v20@0:8i16"</span>, (void *)_I_Animal_setHeight_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译的结果如上，可以看到匿名类别的编译结果并不是 <code>category_t</code> 的类型在 runtime 时加载的，而是直接在编译期间将相关的属性方法等加载到了类中，匿名分类声明的属性方法相当于在类的 .h 文件的声明。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/07/22/category原理探究-2/">category原理探究-2</a><a class="next" href="/2018/07/19/KVO-KVC的原理探究-KVC篇/">KVO-KVC的原理探究 - KVC篇</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/内存管理、RunLoop、Autorelease/" style="font-size: 15px;">内存管理、RunLoop、Autorelease</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/内存管理原理探究-续/">内存管理原理探究-续</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/08/内存管理原理探究/">内存管理原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/05/多线程/">多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/29/RunLoop原理探究/">RunLoop原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/20/Runtime原理探究/">Runtime原理探究</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block6-循环引用/">block6-循环引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/06/block5-block内存管理/">block5-block内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/block3-block原理/">block4-__block原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block3-类型、copy原理/">block3-类型、copy原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/02/block2-变量的捕获/">block2-变量的捕获</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">白夜追凶.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>