<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> category原理探究-1 · 北漂猿的入门到放弃</title><meta name="description" content="category原理探究-1 - Key"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="北漂猿的入门到放弃"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">category原理探究-1</h1><div class="post-info">2018年07月21日</div><div class="post-content"><h3 id="category探究准备"><a href="#category探究准备" class="headerlink" title="category探究准备"></a>category探究准备</h3><p>先来创建我们测试需要的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Animal类 --&gt;</span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">- (void)animal;</span><br><span class="line">@end</span><br><span class="line">&lt;!-- Animal+Eat分类 --&gt;</span><br><span class="line">@interface Animal (Eat) &lt;NSCopying, NSCoding&gt;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">- (void)eat;</span><br><span class="line">@end</span><br><span class="line">&lt;!-- Animal+Play分类 --&gt;</span><br><span class="line">@interface Animal (Play)</span><br><span class="line">- (void)play;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以Eat分类为例，请出 <code>clang</code> 命令：<code>clang -rewrite-objc Animal+Eat.m</code> ，生成.cpp文件。</p>
<h3 id="category的真面目"><a href="#category的真面目" class="headerlink" title="category的真面目"></a>category的真面目</h3><p>在.cpp文件最下面可以找到category被编译后的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	struct _class_t *cls;</span><br><span class="line">	const struct _method_list_t *instance_methods;</span><br><span class="line">	const struct _method_list_t *class_methods;</span><br><span class="line">	const struct _protocol_list_t *protocols;</span><br><span class="line">	const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code> 这里的name表示的是 <code>类名</code> 而不是category的名字。</li>
<li><code>cls</code> 要扩展的类对象，编译期间值为空，在被runtime加载时根据name对应到类对象。</li>
<li><code>instance_methods</code> category所有的实例方法。</li>
<li><code>class_methods</code> category所有的类方法。</li>
<li><code>protocols</code> category实现的所有协议。</li>
<li><code>properties</code> category的所有属性。</li>
</ul>
<p>再来看看我们的Animal+Eat被编译成了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t _OBJC_$_CATEGORY_Animal_$_Eat __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =  &#123;</span><br><span class="line">	&quot;Animal&quot;,</span><br><span class="line">	0, // &amp;OBJC_CLASS_$_Animal,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Eat,</span><br><span class="line">	0,</span><br><span class="line">	(const struct _protocol_list_t *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_Animal_$_Eat,</span><br><span class="line">	(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Animal_$_Eat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看一下结构体的名称：<code>_OBJC_$_CATEGORY_Animal_$_Eat</code>，最后面的Eat就是我们分类的名称，前面有表示CATEGORY和类名Animal，这也就是为什么同一个类的category不能重名的原因了。<br>再对应一下其他的结构，例如instance_methods：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Eat __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	1,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;eat&quot;, &quot;v16@0:8&quot;, (void *)_I_Animal_Eat_eat&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们里面只有一个 <code>eat</code> 方法，被编译后为 <code>_I_Animal_Eat_eat</code>。</p>
<p>最后可以看到所有的category被放到了一个数组中，存在了 <code>__DATA</code> 段下的 <code>__objc_catlist section</code> 里了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">	&amp;_OBJC_$_CATEGORY_Animal_$_Eat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里编译期间的工作就做完了，接下来进入runtime。</p>
<h3 id="runtime加载category"><a href="#runtime加载category" class="headerlink" title="runtime加载category"></a>runtime加载category</h3><p>先下载一下苹果官方runtime的源码 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener"><strong>这里</strong></a>，当然官方的编译是失败，要想调试runtime的请看 <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener"><strong>这里</strong></a>。</p>
<p>大致加载的流程如下：</p>
<ul>
<li>找到runtime的入口：<code>objc-os.mm</code> 的 <code>_objc_init</code> 方法，在library加载前由libSystem dyld调用，进行初始化操作。</li>
<li>调用map_images方法将文件中的image map到内存。</li>
<li>调用_read_images方法初始化map后的image。</li>
<li>找到 <code>Discover categories</code> 可以看到 <code>category_t</code> 是通过 <code>_getObjc2CategoryList</code> 方法初始化的，这个方法拿出来看看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define GETSECT(name, type, sectname)                                   \</span><br><span class="line">    type *name(const headerType *mhdr, size_t *outCount) &#123;              \</span><br><span class="line">        return getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    type *name(const header_info *hi, size_t *outCount) &#123;               \</span><br><span class="line">        return getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, nil, outCount); \</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;);</span><br></pre></td></tr></table></figure>
<p>看到这里有没有很熟悉，在这里加载的 <code>__objc_catlist</code> 就是在编译期间存放的数据。</p>
<p>来看一下加载的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">for (EACH_HEADER) &#123;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">   * 取出 category 数据 此处为数组代表一个类所有的分类</span><br><span class="line">   */</span><br><span class="line">   category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">   for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">	   </span><br><span class="line">	  /**</span><br><span class="line">	  * 按顺序取出 category_t </span><br><span class="line">	  */</span><br><span class="line">	  category_t *cat = catlist[i];</span><br><span class="line">	  /**</span><br><span class="line">	  * remapClass：加载category_t的class指针</span><br><span class="line">	  */</span><br><span class="line">	  Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">	  </span><br><span class="line">	  if (cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties) </span><br><span class="line">	  &#123;</span><br><span class="line">	      addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">	      if (cls-&gt;isRealized()) &#123;</span><br><span class="line">	      	remethodizeClass(cls);</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	</span><br><span class="line">	  if (cat-&gt;classMethods  ||  cat-&gt;protocols ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">	  &#123;</span><br><span class="line">	      addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">	      if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">	      	remethodizeClass(cls-&gt;ISA());</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到每次循环中 <code>category_t</code> 的加载 <code>addUnattachedCategoryForClass</code> 方法有两个调用，对比一下参数可以发现第二个参数不同 cls 和 cls-&gt;ISA()，再结合判断条件的 cat-&gt;instanceMethods 和 cat-&gt;classMethods，这两次的加载是将category中的信息分别加载到类和元类中，然后再调用 <code>remethodizeClass</code> 重新组织结构。接下来调用附加信息的方法 <code>attachCategories</code> ，将分类的信息附加到类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">    * 是否为元类</span><br><span class="line">    */ 	</span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 方法数组</span><br><span class="line">    */</span><br><span class="line">    method_list_t **mlists = (method_list_t **) </span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    /**</span><br><span class="line">    * 属性数组</span><br><span class="line">    */</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">   /**</span><br><span class="line">    * 协议数组</span><br><span class="line">    */</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line">    /**</span><br><span class="line">    ********** 注意 ：这里是倒序循环 **********</span><br><span class="line">    */</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类</span><br><span class="line">        */</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类的方法列表 (根据 isMeta 来判断取实例方法还是类方法)</span><br><span class="line">        */</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 将分类方法列表正序添加到 mlists</span><br><span class="line">            */        </span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类的属性列表</span><br><span class="line">        */</span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 将分类属性列表正序添加到 proplists</span><br><span class="line">            */  </span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">        * 取出某个分类的协议列表</span><br><span class="line">        */</span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 将分类协议列表正序添加到 protolists</span><br><span class="line">            */  </span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 取出类的信息数据  class_rw_t</span><br><span class="line">    */</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">    /**</span><br><span class="line">    * 初始化方法的一些信息，比如有没有实现retain、release、allocWithZone等方法。</span><br><span class="line">    */</span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    /**</span><br><span class="line">    * 将所有分类的方法、属性、协议列表附加到类的方法、属性、协议列表中。</span><br><span class="line">    */</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的while循环可以看到加载方法、协议、属性的时候是 <code>倒序</code> 加载的，是不是想到了什么？如果Animal类和两个分类都有一个 <code>-(void)run</code> 方法，那么最终会调用哪个里面的run方法呢？答案当然是最后加载的那个run方法，不过没有被调用的run方法并没有被 <code>覆盖</code> ，方法还在那里只是按顺序没有被调用。</p>
<p>最后看一下 <code>methods.attachLists</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 将分类的 方法、协议、属性等信息附加到类中</span><br><span class="line">*/</span><br><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">	 </span><br><span class="line">	uint32_t oldCount = array()-&gt;count;</span><br><span class="line">	uint32_t newCount = oldCount + addedCount;</span><br><span class="line">	/**</span><br><span class="line">	* 重新分配内存（大小为： oldCount addedCount 原有count和要添加的count总和）</span><br><span class="line">	*/ </span><br><span class="line">	setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">	array()-&gt;count = newCount;</span><br><span class="line">	/**</span><br><span class="line">	* 重新布局</span><br><span class="line">	*/</span><br><span class="line">	memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">		 oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">	memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">		 addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新布局的时候有两个方法：</p>
<ul>
<li><code>memmove</code>：<code>void *memmove(void *__dst, const void *__src, size_t __len);</code> 可以看到是将src变量的数据移动到dst，所以最终是将 array()-&gt;lists 的数据移动到了 array()-&gt;lists + addedCount 的位置。</li>
<li><code>memcpy</code>：<code>void    *memcpy(void *__dst, const void *__src, size_t __n);</code> 可以看到是将src变量的数据copy到dst，所以最终是将分类中的信息 <code>addedLists</code> copy 到 array()-&gt;lists 的位置。</li>
</ul>
<p>正如我们上面说的run方法，Animal类中的run方法是被最后加载的，因为Animal类中的方法列表被移动到了分类的后面，加载的时候会先调用分类中的方法，而且可以看到Animal中的run方法确实没有被覆盖，只是调用的时候发现分类中有不会再调用Animal的run方法而已。</p>
<h3 id="class-extention与category"><a href="#class-extention与category" class="headerlink" title="class extention与category"></a>class extention与category</h3><p>上面知道了category，我们再来看看class extention，class extention算是一种特殊的分类（匿名分类），那么我们可以思考平时在 .m 文件的匿名分类中写的私有属性、方法等在加载的时候会不会和分类一样呢？我们来验证一下，在Animal的 .m 文件里添加属性 height 和方法 test：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal ()</span><br><span class="line">@property (nonatomic, assign) int height;</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">- (void)animal &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>用clang命令来编译 Animal：<code>clang -rewrite-objc Animal.m</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 元类结构</span><br><span class="line">*/</span><br><span class="line">static struct _class_ro_t _OBJC_METACLASS_RO_$_Animal __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	1, sizeof(struct _class_t), sizeof(struct _class_t), </span><br><span class="line">	(unsigned int)0, </span><br><span class="line">	0, </span><br><span class="line">	&quot;Animal&quot;,</span><br><span class="line">	0, </span><br><span class="line">	0, </span><br><span class="line">	0, </span><br><span class="line">	0, </span><br><span class="line">	0, </span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line">* 类结构</span><br><span class="line">*/</span><br><span class="line">static struct _class_ro_t _OBJC_CLASS_RO_$_Animal __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	0, __OFFSETOFIVAR__(struct Animal, _height), sizeof(struct Animal_IMPL), </span><br><span class="line">	(unsigned int)0, </span><br><span class="line">	0, </span><br><span class="line">	&quot;Animal&quot;,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_Animal,</span><br><span class="line">	0, </span><br><span class="line">	(const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_Animal,</span><br><span class="line">	0, </span><br><span class="line">	0, </span><br><span class="line">&#125;;</span><br><span class="line">/***************************************/</span><br><span class="line">/**</span><br><span class="line">* 可以看到类中方法列表 ‘_INSTANCE_METHODS_Animal’对应下面的结构</span><br><span class="line">* animal、test、height、setHeight 方法都在类结构中</span><br><span class="line">*/</span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[4];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Animal __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	4,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;animal&quot;, &quot;v16@0:8&quot;, (void *)_I_Animal_animal&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_Animal_test&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;height&quot;, &quot;i16@0:8&quot;, (void *)_I_Animal_height&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;setHeight:&quot;, &quot;v20@0:8i16&quot;, (void *)_I_Animal_setHeight_&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译的结果如上，可以看到匿名类别的编译结果并不是 <code>category_t</code> 的类型在 runtime 时加载的，而是直接在编译期间将相关的属性方法等加载到了类中，匿名分类声明的属性方法相当于在类的 .h 文件的声明。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/19/KVO-KVC的原理探究-KVC篇/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Key</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>